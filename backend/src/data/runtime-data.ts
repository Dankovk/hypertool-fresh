/**
 * Auto-generated runtime library data
 * Generated at: 2025-11-16T21:38:59.427Z
 *
 * This file is generated by scripts/transform-runtime.ts
 * Do not edit manually - run 'bun run transform:runtime' to regenerate
 */

export const RUNTIME_DATA = {
  "files": {
    "/__hypertool__/index.js": "var __create = Object.create;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __toESM = (mod, isNodeMode, target) => {\n  target = mod != null ? __create(__getProtoOf(mod)) : {};\n  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target;\n  for (let key of __getOwnPropNames(mod))\n    if (!__hasOwnProp.call(to, key))\n      __defProp(to, key, {\n        get: () => mod[key],\n        enumerable: true\n      });\n  return to;\n};\nvar __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);\n\n// ../../node_modules/.bun/react@18.3.1/node_modules/react/cjs/react.development.js\nvar require_react_development = __commonJS((exports, module) => {\n  if (true) {\n    (function() {\n      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error);\n      }\n      var ReactVersion = \"18.3.1\";\n      var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n      var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n      var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n      var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n      var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n      var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n      var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n      var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n      var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n      var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n      var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n      var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n      var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n      var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n      function getIteratorFn(maybeIterable) {\n        if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n          return null;\n        }\n        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n        if (typeof maybeIterator === \"function\") {\n          return maybeIterator;\n        }\n        return null;\n      }\n      var ReactCurrentDispatcher = {\n        current: null\n      };\n      var ReactCurrentBatchConfig = {\n        transition: null\n      };\n      var ReactCurrentActQueue = {\n        current: null,\n        isBatchingLegacy: false,\n        didScheduleLegacyUpdate: false\n      };\n      var ReactCurrentOwner = {\n        current: null\n      };\n      var ReactDebugCurrentFrame = {};\n      var currentExtraStackFrame = null;\n      function setExtraStackFrame(stack) {\n        {\n          currentExtraStackFrame = stack;\n        }\n      }\n      {\n        ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {\n          {\n            currentExtraStackFrame = stack;\n          }\n        };\n        ReactDebugCurrentFrame.getCurrentStack = null;\n        ReactDebugCurrentFrame.getStackAddendum = function() {\n          var stack = \"\";\n          if (currentExtraStackFrame) {\n            stack += currentExtraStackFrame;\n          }\n          var impl = ReactDebugCurrentFrame.getCurrentStack;\n          if (impl) {\n            stack += impl() || \"\";\n          }\n          return stack;\n        };\n      }\n      var enableScopeAPI = false;\n      var enableCacheElement = false;\n      var enableTransitionTracing = false;\n      var enableLegacyHidden = false;\n      var enableDebugTracing = false;\n      var ReactSharedInternals = {\n        ReactCurrentDispatcher,\n        ReactCurrentBatchConfig,\n        ReactCurrentOwner\n      };\n      {\n        ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;\n        ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;\n      }\n      function warn(format) {\n        {\n          {\n            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {\n              args[_key - 1] = arguments[_key];\n            }\n            printWarning(\"warn\", format, args);\n          }\n        }\n      }\n      function error(format) {\n        {\n          {\n            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;_key2 < _len2; _key2++) {\n              args[_key2 - 1] = arguments[_key2];\n            }\n            printWarning(\"error\", format, args);\n          }\n        }\n      }\n      function printWarning(level, format, args) {\n        {\n          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;\n          var stack = ReactDebugCurrentFrame2.getStackAddendum();\n          if (stack !== \"\") {\n            format += \"%s\";\n            args = args.concat([stack]);\n          }\n          var argsWithFormat = args.map(function(item) {\n            return String(item);\n          });\n          argsWithFormat.unshift(\"Warning: \" + format);\n          Function.prototype.apply.call(console[level], console, argsWithFormat);\n        }\n      }\n      var didWarnStateUpdateForUnmountedComponent = {};\n      function warnNoop(publicInstance, callerName) {\n        {\n          var _constructor = publicInstance.constructor;\n          var componentName = _constructor && (_constructor.displayName || _constructor.name) || \"ReactClass\";\n          var warningKey = componentName + \".\" + callerName;\n          if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n            return;\n          }\n          error(\"Can't call %s on a component that is not yet mounted. \" + \"This is a no-op, but it might indicate a bug in your application. \" + \"Instead, assign to `this.state` directly or define a `state = {};` \" + \"class property with the desired state in the %s component.\", callerName, componentName);\n          didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n        }\n      }\n      var ReactNoopUpdateQueue = {\n        isMounted: function(publicInstance) {\n          return false;\n        },\n        enqueueForceUpdate: function(publicInstance, callback, callerName) {\n          warnNoop(publicInstance, \"forceUpdate\");\n        },\n        enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {\n          warnNoop(publicInstance, \"replaceState\");\n        },\n        enqueueSetState: function(publicInstance, partialState, callback, callerName) {\n          warnNoop(publicInstance, \"setState\");\n        }\n      };\n      var assign = Object.assign;\n      var emptyObject = {};\n      {\n        Object.freeze(emptyObject);\n      }\n      function Component(props, context, updater) {\n        this.props = props;\n        this.context = context;\n        this.refs = emptyObject;\n        this.updater = updater || ReactNoopUpdateQueue;\n      }\n      Component.prototype.isReactComponent = {};\n      Component.prototype.setState = function(partialState, callback) {\n        if (typeof partialState !== \"object\" && typeof partialState !== \"function\" && partialState != null) {\n          throw new Error(\"setState(...): takes an object of state variables to update or a \" + \"function which returns an object of state variables.\");\n        }\n        this.updater.enqueueSetState(this, partialState, callback, \"setState\");\n      };\n      Component.prototype.forceUpdate = function(callback) {\n        this.updater.enqueueForceUpdate(this, callback, \"forceUpdate\");\n      };\n      {\n        var deprecatedAPIs = {\n          isMounted: [\"isMounted\", \"Instead, make sure to clean up subscriptions and pending requests in \" + \"componentWillUnmount to prevent memory leaks.\"],\n          replaceState: [\"replaceState\", \"Refactor your code to use setState instead (see \" + \"https://github.com/facebook/react/issues/3236).\"]\n        };\n        var defineDeprecationWarning = function(methodName, info) {\n          Object.defineProperty(Component.prototype, methodName, {\n            get: function() {\n              warn(\"%s(...) is deprecated in plain JavaScript React classes. %s\", info[0], info[1]);\n              return;\n            }\n          });\n        };\n        for (var fnName in deprecatedAPIs) {\n          if (deprecatedAPIs.hasOwnProperty(fnName)) {\n            defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n          }\n        }\n      }\n      function ComponentDummy() {}\n      ComponentDummy.prototype = Component.prototype;\n      function PureComponent(props, context, updater) {\n        this.props = props;\n        this.context = context;\n        this.refs = emptyObject;\n        this.updater = updater || ReactNoopUpdateQueue;\n      }\n      var pureComponentPrototype = PureComponent.prototype = new ComponentDummy;\n      pureComponentPrototype.constructor = PureComponent;\n      assign(pureComponentPrototype, Component.prototype);\n      pureComponentPrototype.isPureReactComponent = true;\n      function createRef() {\n        var refObject = {\n          current: null\n        };\n        {\n          Object.seal(refObject);\n        }\n        return refObject;\n      }\n      var isArrayImpl = Array.isArray;\n      function isArray(a) {\n        return isArrayImpl(a);\n      }\n      function typeName(value) {\n        {\n          var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n          var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\";\n          return type;\n        }\n      }\n      function willCoercionThrow(value) {\n        {\n          try {\n            testStringCoercion(value);\n            return false;\n          } catch (e) {\n            return true;\n          }\n        }\n      }\n      function testStringCoercion(value) {\n        return \"\" + value;\n      }\n      function checkKeyStringCoercion(value) {\n        {\n          if (willCoercionThrow(value)) {\n            error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before before using it here.\", typeName(value));\n            return testStringCoercion(value);\n          }\n        }\n      }\n      function getWrappedName(outerType, innerType, wrapperName) {\n        var displayName = outerType.displayName;\n        if (displayName) {\n          return displayName;\n        }\n        var functionName = innerType.displayName || innerType.name || \"\";\n        return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n      }\n      function getContextName(type) {\n        return type.displayName || \"Context\";\n      }\n      function getComponentNameFromType(type) {\n        if (type == null) {\n          return null;\n        }\n        {\n          if (typeof type.tag === \"number\") {\n            error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n          }\n        }\n        if (typeof type === \"function\") {\n          return type.displayName || type.name || null;\n        }\n        if (typeof type === \"string\") {\n          return type;\n        }\n        switch (type) {\n          case REACT_FRAGMENT_TYPE:\n            return \"Fragment\";\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_PROFILER_TYPE:\n            return \"Profiler\";\n          case REACT_STRICT_MODE_TYPE:\n            return \"StrictMode\";\n          case REACT_SUSPENSE_TYPE:\n            return \"Suspense\";\n          case REACT_SUSPENSE_LIST_TYPE:\n            return \"SuspenseList\";\n        }\n        if (typeof type === \"object\") {\n          switch (type.$$typeof) {\n            case REACT_CONTEXT_TYPE:\n              var context = type;\n              return getContextName(context) + \".Consumer\";\n            case REACT_PROVIDER_TYPE:\n              var provider = type;\n              return getContextName(provider._context) + \".Provider\";\n            case REACT_FORWARD_REF_TYPE:\n              return getWrappedName(type, type.render, \"ForwardRef\");\n            case REACT_MEMO_TYPE:\n              var outerName = type.displayName || null;\n              if (outerName !== null) {\n                return outerName;\n              }\n              return getComponentNameFromType(type.type) || \"Memo\";\n            case REACT_LAZY_TYPE: {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n              try {\n                return getComponentNameFromType(init(payload));\n              } catch (x) {\n                return null;\n              }\n            }\n          }\n        }\n        return null;\n      }\n      var hasOwnProperty = Object.prototype.hasOwnProperty;\n      var RESERVED_PROPS = {\n        key: true,\n        ref: true,\n        __self: true,\n        __source: true\n      };\n      var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;\n      {\n        didWarnAboutStringRefs = {};\n      }\n      function hasValidRef(config) {\n        {\n          if (hasOwnProperty.call(config, \"ref\")) {\n            var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n            if (getter && getter.isReactWarning) {\n              return false;\n            }\n          }\n        }\n        return config.ref !== undefined;\n      }\n      function hasValidKey(config) {\n        {\n          if (hasOwnProperty.call(config, \"key\")) {\n            var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n            if (getter && getter.isReactWarning) {\n              return false;\n            }\n          }\n        }\n        return config.key !== undefined;\n      }\n      function defineKeyPropWarningGetter(props, displayName) {\n        var warnAboutAccessingKey = function() {\n          {\n            if (!specialPropKeyWarningShown) {\n              specialPropKeyWarningShown = true;\n              error(\"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n            }\n          }\n        };\n        warnAboutAccessingKey.isReactWarning = true;\n        Object.defineProperty(props, \"key\", {\n          get: warnAboutAccessingKey,\n          configurable: true\n        });\n      }\n      function defineRefPropWarningGetter(props, displayName) {\n        var warnAboutAccessingRef = function() {\n          {\n            if (!specialPropRefWarningShown) {\n              specialPropRefWarningShown = true;\n              error(\"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n            }\n          }\n        };\n        warnAboutAccessingRef.isReactWarning = true;\n        Object.defineProperty(props, \"ref\", {\n          get: warnAboutAccessingRef,\n          configurable: true\n        });\n      }\n      function warnIfStringRefCannotBeAutoConverted(config) {\n        {\n          if (typeof config.ref === \"string\" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {\n            var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n            if (!didWarnAboutStringRefs[componentName]) {\n              error('Component \"%s\" contains the string ref \"%s\". ' + \"Support for string refs will be removed in a future major release. \" + \"This case cannot be automatically converted to an arrow function. \" + \"We ask you to manually fix this case by using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", componentName, config.ref);\n              didWarnAboutStringRefs[componentName] = true;\n            }\n          }\n        }\n      }\n      var ReactElement = function(type, key, ref, self, source, owner, props) {\n        var element = {\n          $$typeof: REACT_ELEMENT_TYPE,\n          type,\n          key,\n          ref,\n          props,\n          _owner: owner\n        };\n        {\n          element._store = {};\n          Object.defineProperty(element._store, \"validated\", {\n            configurable: false,\n            enumerable: false,\n            writable: true,\n            value: false\n          });\n          Object.defineProperty(element, \"_self\", {\n            configurable: false,\n            enumerable: false,\n            writable: false,\n            value: self\n          });\n          Object.defineProperty(element, \"_source\", {\n            configurable: false,\n            enumerable: false,\n            writable: false,\n            value: source\n          });\n          if (Object.freeze) {\n            Object.freeze(element.props);\n            Object.freeze(element);\n          }\n        }\n        return element;\n      };\n      function createElement(type, config, children) {\n        var propName;\n        var props = {};\n        var key = null;\n        var ref = null;\n        var self = null;\n        var source = null;\n        if (config != null) {\n          if (hasValidRef(config)) {\n            ref = config.ref;\n            {\n              warnIfStringRefCannotBeAutoConverted(config);\n            }\n          }\n          if (hasValidKey(config)) {\n            {\n              checkKeyStringCoercion(config.key);\n            }\n            key = \"\" + config.key;\n          }\n          self = config.__self === undefined ? null : config.__self;\n          source = config.__source === undefined ? null : config.__source;\n          for (propName in config) {\n            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n              props[propName] = config[propName];\n            }\n          }\n        }\n        var childrenLength = arguments.length - 2;\n        if (childrenLength === 1) {\n          props.children = children;\n        } else if (childrenLength > 1) {\n          var childArray = Array(childrenLength);\n          for (var i = 0;i < childrenLength; i++) {\n            childArray[i] = arguments[i + 2];\n          }\n          {\n            if (Object.freeze) {\n              Object.freeze(childArray);\n            }\n          }\n          props.children = childArray;\n        }\n        if (type && type.defaultProps) {\n          var defaultProps = type.defaultProps;\n          for (propName in defaultProps) {\n            if (props[propName] === undefined) {\n              props[propName] = defaultProps[propName];\n            }\n          }\n        }\n        {\n          if (key || ref) {\n            var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n            if (key) {\n              defineKeyPropWarningGetter(props, displayName);\n            }\n            if (ref) {\n              defineRefPropWarningGetter(props, displayName);\n            }\n          }\n        }\n        return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n      }\n      function cloneAndReplaceKey(oldElement, newKey) {\n        var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n        return newElement;\n      }\n      function cloneElement(element, config, children) {\n        if (element === null || element === undefined) {\n          throw new Error(\"React.cloneElement(...): The argument must be a React element, but you passed \" + element + \".\");\n        }\n        var propName;\n        var props = assign({}, element.props);\n        var key = element.key;\n        var ref = element.ref;\n        var self = element._self;\n        var source = element._source;\n        var owner = element._owner;\n        if (config != null) {\n          if (hasValidRef(config)) {\n            ref = config.ref;\n            owner = ReactCurrentOwner.current;\n          }\n          if (hasValidKey(config)) {\n            {\n              checkKeyStringCoercion(config.key);\n            }\n            key = \"\" + config.key;\n          }\n          var defaultProps;\n          if (element.type && element.type.defaultProps) {\n            defaultProps = element.type.defaultProps;\n          }\n          for (propName in config) {\n            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n              if (config[propName] === undefined && defaultProps !== undefined) {\n                props[propName] = defaultProps[propName];\n              } else {\n                props[propName] = config[propName];\n              }\n            }\n          }\n        }\n        var childrenLength = arguments.length - 2;\n        if (childrenLength === 1) {\n          props.children = children;\n        } else if (childrenLength > 1) {\n          var childArray = Array(childrenLength);\n          for (var i = 0;i < childrenLength; i++) {\n            childArray[i] = arguments[i + 2];\n          }\n          props.children = childArray;\n        }\n        return ReactElement(element.type, key, ref, self, source, owner, props);\n      }\n      function isValidElement(object) {\n        return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n      }\n      var SEPARATOR = \".\";\n      var SUBSEPARATOR = \":\";\n      function escape(key) {\n        var escapeRegex = /[=:]/g;\n        var escaperLookup = {\n          \"=\": \"=0\",\n          \":\": \"=2\"\n        };\n        var escapedString = key.replace(escapeRegex, function(match) {\n          return escaperLookup[match];\n        });\n        return \"$\" + escapedString;\n      }\n      var didWarnAboutMaps = false;\n      var userProvidedKeyEscapeRegex = /\\/+/g;\n      function escapeUserProvidedKey(text) {\n        return text.replace(userProvidedKeyEscapeRegex, \"$&/\");\n      }\n      function getElementKey(element, index) {\n        if (typeof element === \"object\" && element !== null && element.key != null) {\n          {\n            checkKeyStringCoercion(element.key);\n          }\n          return escape(\"\" + element.key);\n        }\n        return index.toString(36);\n      }\n      function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n        var type = typeof children;\n        if (type === \"undefined\" || type === \"boolean\") {\n          children = null;\n        }\n        var invokeCallback = false;\n        if (children === null) {\n          invokeCallback = true;\n        } else {\n          switch (type) {\n            case \"string\":\n            case \"number\":\n              invokeCallback = true;\n              break;\n            case \"object\":\n              switch (children.$$typeof) {\n                case REACT_ELEMENT_TYPE:\n                case REACT_PORTAL_TYPE:\n                  invokeCallback = true;\n              }\n          }\n        }\n        if (invokeCallback) {\n          var _child = children;\n          var mappedChild = callback(_child);\n          var childKey = nameSoFar === \"\" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;\n          if (isArray(mappedChild)) {\n            var escapedChildKey = \"\";\n            if (childKey != null) {\n              escapedChildKey = escapeUserProvidedKey(childKey) + \"/\";\n            }\n            mapIntoArray(mappedChild, array, escapedChildKey, \"\", function(c) {\n              return c;\n            });\n          } else if (mappedChild != null) {\n            if (isValidElement(mappedChild)) {\n              {\n                if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {\n                  checkKeyStringCoercion(mappedChild.key);\n                }\n              }\n              mappedChild = cloneAndReplaceKey(mappedChild, escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey(\"\" + mappedChild.key) + \"/\" : \"\") + childKey);\n            }\n            array.push(mappedChild);\n          }\n          return 1;\n        }\n        var child;\n        var nextName;\n        var subtreeCount = 0;\n        var nextNamePrefix = nameSoFar === \"\" ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n        if (isArray(children)) {\n          for (var i = 0;i < children.length; i++) {\n            child = children[i];\n            nextName = nextNamePrefix + getElementKey(child, i);\n            subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n          }\n        } else {\n          var iteratorFn = getIteratorFn(children);\n          if (typeof iteratorFn === \"function\") {\n            var iterableChildren = children;\n            {\n              if (iteratorFn === iterableChildren.entries) {\n                if (!didWarnAboutMaps) {\n                  warn(\"Using Maps as children is not supported. \" + \"Use an array of keyed ReactElements instead.\");\n                }\n                didWarnAboutMaps = true;\n              }\n            }\n            var iterator = iteratorFn.call(iterableChildren);\n            var step;\n            var ii = 0;\n            while (!(step = iterator.next()).done) {\n              child = step.value;\n              nextName = nextNamePrefix + getElementKey(child, ii++);\n              subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n            }\n          } else if (type === \"object\") {\n            var childrenString = String(children);\n            throw new Error(\"Objects are not valid as a React child (found: \" + (childrenString === \"[object Object]\" ? \"object with keys {\" + Object.keys(children).join(\", \") + \"}\" : childrenString) + \"). \" + \"If you meant to render a collection of children, use an array \" + \"instead.\");\n          }\n        }\n        return subtreeCount;\n      }\n      function mapChildren(children, func, context) {\n        if (children == null) {\n          return children;\n        }\n        var result = [];\n        var count = 0;\n        mapIntoArray(children, result, \"\", \"\", function(child) {\n          return func.call(context, child, count++);\n        });\n        return result;\n      }\n      function countChildren(children) {\n        var n = 0;\n        mapChildren(children, function() {\n          n++;\n        });\n        return n;\n      }\n      function forEachChildren(children, forEachFunc, forEachContext) {\n        mapChildren(children, function() {\n          forEachFunc.apply(this, arguments);\n        }, forEachContext);\n      }\n      function toArray(children) {\n        return mapChildren(children, function(child) {\n          return child;\n        }) || [];\n      }\n      function onlyChild(children) {\n        if (!isValidElement(children)) {\n          throw new Error(\"React.Children.only expected to receive a single React element child.\");\n        }\n        return children;\n      }\n      function createContext(defaultValue) {\n        var context = {\n          $$typeof: REACT_CONTEXT_TYPE,\n          _currentValue: defaultValue,\n          _currentValue2: defaultValue,\n          _threadCount: 0,\n          Provider: null,\n          Consumer: null,\n          _defaultValue: null,\n          _globalName: null\n        };\n        context.Provider = {\n          $$typeof: REACT_PROVIDER_TYPE,\n          _context: context\n        };\n        var hasWarnedAboutUsingNestedContextConsumers = false;\n        var hasWarnedAboutUsingConsumerProvider = false;\n        var hasWarnedAboutDisplayNameOnConsumer = false;\n        {\n          var Consumer = {\n            $$typeof: REACT_CONTEXT_TYPE,\n            _context: context\n          };\n          Object.defineProperties(Consumer, {\n            Provider: {\n              get: function() {\n                if (!hasWarnedAboutUsingConsumerProvider) {\n                  hasWarnedAboutUsingConsumerProvider = true;\n                  error(\"Rendering <Context.Consumer.Provider> is not supported and will be removed in \" + \"a future major release. Did you mean to render <Context.Provider> instead?\");\n                }\n                return context.Provider;\n              },\n              set: function(_Provider) {\n                context.Provider = _Provider;\n              }\n            },\n            _currentValue: {\n              get: function() {\n                return context._currentValue;\n              },\n              set: function(_currentValue) {\n                context._currentValue = _currentValue;\n              }\n            },\n            _currentValue2: {\n              get: function() {\n                return context._currentValue2;\n              },\n              set: function(_currentValue2) {\n                context._currentValue2 = _currentValue2;\n              }\n            },\n            _threadCount: {\n              get: function() {\n                return context._threadCount;\n              },\n              set: function(_threadCount) {\n                context._threadCount = _threadCount;\n              }\n            },\n            Consumer: {\n              get: function() {\n                if (!hasWarnedAboutUsingNestedContextConsumers) {\n                  hasWarnedAboutUsingNestedContextConsumers = true;\n                  error(\"Rendering <Context.Consumer.Consumer> is not supported and will be removed in \" + \"a future major release. Did you mean to render <Context.Consumer> instead?\");\n                }\n                return context.Consumer;\n              }\n            },\n            displayName: {\n              get: function() {\n                return context.displayName;\n              },\n              set: function(displayName) {\n                if (!hasWarnedAboutDisplayNameOnConsumer) {\n                  warn(\"Setting `displayName` on Context.Consumer has no effect. \" + \"You should set it directly on the context with Context.displayName = '%s'.\", displayName);\n                  hasWarnedAboutDisplayNameOnConsumer = true;\n                }\n              }\n            }\n          });\n          context.Consumer = Consumer;\n        }\n        {\n          context._currentRenderer = null;\n          context._currentRenderer2 = null;\n        }\n        return context;\n      }\n      var Uninitialized = -1;\n      var Pending = 0;\n      var Resolved = 1;\n      var Rejected = 2;\n      function lazyInitializer(payload) {\n        if (payload._status === Uninitialized) {\n          var ctor = payload._result;\n          var thenable = ctor();\n          thenable.then(function(moduleObject2) {\n            if (payload._status === Pending || payload._status === Uninitialized) {\n              var resolved = payload;\n              resolved._status = Resolved;\n              resolved._result = moduleObject2;\n            }\n          }, function(error2) {\n            if (payload._status === Pending || payload._status === Uninitialized) {\n              var rejected = payload;\n              rejected._status = Rejected;\n              rejected._result = error2;\n            }\n          });\n          if (payload._status === Uninitialized) {\n            var pending = payload;\n            pending._status = Pending;\n            pending._result = thenable;\n          }\n        }\n        if (payload._status === Resolved) {\n          var moduleObject = payload._result;\n          {\n            if (moduleObject === undefined) {\n              error(\"lazy: Expected the result of a dynamic imp\" + \"ort() call. \" + `Instead received: %s\n\nYour code should look like: \n  ` + \"const MyComponent = lazy(() => imp\" + `ort('./MyComponent'))\n\n` + \"Did you accidentally put curly braces around the import?\", moduleObject);\n            }\n          }\n          {\n            if (!(\"default\" in moduleObject)) {\n              error(\"lazy: Expected the result of a dynamic imp\" + \"ort() call. \" + `Instead received: %s\n\nYour code should look like: \n  ` + \"const MyComponent = lazy(() => imp\" + \"ort('./MyComponent'))\", moduleObject);\n            }\n          }\n          return moduleObject.default;\n        } else {\n          throw payload._result;\n        }\n      }\n      function lazy(ctor) {\n        var payload = {\n          _status: Uninitialized,\n          _result: ctor\n        };\n        var lazyType = {\n          $$typeof: REACT_LAZY_TYPE,\n          _payload: payload,\n          _init: lazyInitializer\n        };\n        {\n          var defaultProps;\n          var propTypes;\n          Object.defineProperties(lazyType, {\n            defaultProps: {\n              configurable: true,\n              get: function() {\n                return defaultProps;\n              },\n              set: function(newDefaultProps) {\n                error(\"React.lazy(...): It is not supported to assign `defaultProps` to \" + \"a lazy component import. Either specify them where the component \" + \"is defined, or create a wrapping component around it.\");\n                defaultProps = newDefaultProps;\n                Object.defineProperty(lazyType, \"defaultProps\", {\n                  enumerable: true\n                });\n              }\n            },\n            propTypes: {\n              configurable: true,\n              get: function() {\n                return propTypes;\n              },\n              set: function(newPropTypes) {\n                error(\"React.lazy(...): It is not supported to assign `propTypes` to \" + \"a lazy component import. Either specify them where the component \" + \"is defined, or create a wrapping component around it.\");\n                propTypes = newPropTypes;\n                Object.defineProperty(lazyType, \"propTypes\", {\n                  enumerable: true\n                });\n              }\n            }\n          });\n        }\n        return lazyType;\n      }\n      function forwardRef(render) {\n        {\n          if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\n            error(\"forwardRef requires a render function but received a `memo` \" + \"component. Instead of forwardRef(memo(...)), use \" + \"memo(forwardRef(...)).\");\n          } else if (typeof render !== \"function\") {\n            error(\"forwardRef requires a render function but was given %s.\", render === null ? \"null\" : typeof render);\n          } else {\n            if (render.length !== 0 && render.length !== 2) {\n              error(\"forwardRef render functions accept exactly two parameters: props and ref. %s\", render.length === 1 ? \"Did you forget to use the ref parameter?\" : \"Any additional parameter will be undefined.\");\n            }\n          }\n          if (render != null) {\n            if (render.defaultProps != null || render.propTypes != null) {\n              error(\"forwardRef render functions do not support propTypes or defaultProps. \" + \"Did you accidentally pass a React component?\");\n            }\n          }\n        }\n        var elementType = {\n          $$typeof: REACT_FORWARD_REF_TYPE,\n          render\n        };\n        {\n          var ownName;\n          Object.defineProperty(elementType, \"displayName\", {\n            enumerable: false,\n            configurable: true,\n            get: function() {\n              return ownName;\n            },\n            set: function(name) {\n              ownName = name;\n              if (!render.name && !render.displayName) {\n                render.displayName = name;\n              }\n            }\n          });\n        }\n        return elementType;\n      }\n      var REACT_MODULE_REFERENCE;\n      {\n        REACT_MODULE_REFERENCE = Symbol.for(\"react.module.reference\");\n      }\n      function isValidElementType(type) {\n        if (typeof type === \"string\" || typeof type === \"function\") {\n          return true;\n        }\n        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n          return true;\n        }\n        if (typeof type === \"object\" && type !== null) {\n          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n            return true;\n          }\n        }\n        return false;\n      }\n      function memo(type, compare) {\n        {\n          if (!isValidElementType(type)) {\n            error(\"memo: The first argument must be a component. Instead \" + \"received: %s\", type === null ? \"null\" : typeof type);\n          }\n        }\n        var elementType = {\n          $$typeof: REACT_MEMO_TYPE,\n          type,\n          compare: compare === undefined ? null : compare\n        };\n        {\n          var ownName;\n          Object.defineProperty(elementType, \"displayName\", {\n            enumerable: false,\n            configurable: true,\n            get: function() {\n              return ownName;\n            },\n            set: function(name) {\n              ownName = name;\n              if (!type.name && !type.displayName) {\n                type.displayName = name;\n              }\n            }\n          });\n        }\n        return elementType;\n      }\n      function resolveDispatcher() {\n        var dispatcher = ReactCurrentDispatcher.current;\n        {\n          if (dispatcher === null) {\n            error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for\" + ` one of the following reasons:\n` + `1. You might have mismatching versions of React and the renderer (such as React DOM)\n` + `2. You might be breaking the Rules of Hooks\n` + `3. You might have more than one copy of React in the same app\n` + \"See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.\");\n          }\n        }\n        return dispatcher;\n      }\n      function useContext(Context) {\n        var dispatcher = resolveDispatcher();\n        {\n          if (Context._context !== undefined) {\n            var realContext = Context._context;\n            if (realContext.Consumer === Context) {\n              error(\"Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be \" + \"removed in a future major release. Did you mean to call useContext(Context) instead?\");\n            } else if (realContext.Provider === Context) {\n              error(\"Calling useContext(Context.Provider) is not supported. \" + \"Did you mean to call useContext(Context) instead?\");\n            }\n          }\n        }\n        return dispatcher.useContext(Context);\n      }\n      function useState(initialState) {\n        var dispatcher = resolveDispatcher();\n        return dispatcher.useState(initialState);\n      }\n      function useReducer(reducer, initialArg, init) {\n        var dispatcher = resolveDispatcher();\n        return dispatcher.useReducer(reducer, initialArg, init);\n      }\n      function useRef(initialValue) {\n        var dispatcher = resolveDispatcher();\n        return dispatcher.useRef(initialValue);\n      }\n      function useEffect(create, deps) {\n        var dispatcher = resolveDispatcher();\n        return dispatcher.useEffect(create, deps);\n      }\n      function useInsertionEffect(create, deps) {\n        var dispatcher = resolveDispatcher();\n        return dispatcher.useInsertionEffect(create, deps);\n      }\n      function useLayoutEffect(create, deps) {\n        var dispatcher = resolveDispatcher();\n        return dispatcher.useLayoutEffect(create, deps);\n      }\n      function useCallback(callback, deps) {\n        var dispatcher = resolveDispatcher();\n        return dispatcher.useCallback(callback, deps);\n      }\n      function useMemo(create, deps) {\n        var dispatcher = resolveDispatcher();\n        return dispatcher.useMemo(create, deps);\n      }\n      function useImperativeHandle(ref, create, deps) {\n        var dispatcher = resolveDispatcher();\n        return dispatcher.useImperativeHandle(ref, create, deps);\n      }\n      function useDebugValue(value, formatterFn) {\n        {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useDebugValue(value, formatterFn);\n        }\n      }\n      function useTransition() {\n        var dispatcher = resolveDispatcher();\n        return dispatcher.useTransition();\n      }\n      function useDeferredValue(value) {\n        var dispatcher = resolveDispatcher();\n        return dispatcher.useDeferredValue(value);\n      }\n      function useId() {\n        var dispatcher = resolveDispatcher();\n        return dispatcher.useId();\n      }\n      function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n        var dispatcher = resolveDispatcher();\n        return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n      }\n      var disabledDepth = 0;\n      var prevLog;\n      var prevInfo;\n      var prevWarn;\n      var prevError;\n      var prevGroup;\n      var prevGroupCollapsed;\n      var prevGroupEnd;\n      function disabledLog() {}\n      disabledLog.__reactDisabledLog = true;\n      function disableLogs() {\n        {\n          if (disabledDepth === 0) {\n            prevLog = console.log;\n            prevInfo = console.info;\n            prevWarn = console.warn;\n            prevError = console.error;\n            prevGroup = console.group;\n            prevGroupCollapsed = console.groupCollapsed;\n            prevGroupEnd = console.groupEnd;\n            var props = {\n              configurable: true,\n              enumerable: true,\n              value: disabledLog,\n              writable: true\n            };\n            Object.defineProperties(console, {\n              info: props,\n              log: props,\n              warn: props,\n              error: props,\n              group: props,\n              groupCollapsed: props,\n              groupEnd: props\n            });\n          }\n          disabledDepth++;\n        }\n      }\n      function reenableLogs() {\n        {\n          disabledDepth--;\n          if (disabledDepth === 0) {\n            var props = {\n              configurable: true,\n              enumerable: true,\n              writable: true\n            };\n            Object.defineProperties(console, {\n              log: assign({}, props, {\n                value: prevLog\n              }),\n              info: assign({}, props, {\n                value: prevInfo\n              }),\n              warn: assign({}, props, {\n                value: prevWarn\n              }),\n              error: assign({}, props, {\n                value: prevError\n              }),\n              group: assign({}, props, {\n                value: prevGroup\n              }),\n              groupCollapsed: assign({}, props, {\n                value: prevGroupCollapsed\n              }),\n              groupEnd: assign({}, props, {\n                value: prevGroupEnd\n              })\n            });\n          }\n          if (disabledDepth < 0) {\n            error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n          }\n        }\n      }\n      var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;\n      var prefix;\n      function describeBuiltInComponentFrame(name, source, ownerFn) {\n        {\n          if (prefix === undefined) {\n            try {\n              throw Error();\n            } catch (x) {\n              var match = x.stack.trim().match(/\\n( *(at )?)/);\n              prefix = match && match[1] || \"\";\n            }\n          }\n          return `\n` + prefix + name;\n        }\n      }\n      var reentry = false;\n      var componentFrameCache;\n      {\n        var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n        componentFrameCache = new PossiblyWeakMap;\n      }\n      function describeNativeComponentFrame(fn, construct) {\n        if (!fn || reentry) {\n          return \"\";\n        }\n        {\n          var frame = componentFrameCache.get(fn);\n          if (frame !== undefined) {\n            return frame;\n          }\n        }\n        var control;\n        reentry = true;\n        var previousPrepareStackTrace = Error.prepareStackTrace;\n        Error.prepareStackTrace = undefined;\n        var previousDispatcher;\n        {\n          previousDispatcher = ReactCurrentDispatcher$1.current;\n          ReactCurrentDispatcher$1.current = null;\n          disableLogs();\n        }\n        try {\n          if (construct) {\n            var Fake = function() {\n              throw Error();\n            };\n            Object.defineProperty(Fake.prototype, \"props\", {\n              set: function() {\n                throw Error();\n              }\n            });\n            if (typeof Reflect === \"object\" && Reflect.construct) {\n              try {\n                Reflect.construct(Fake, []);\n              } catch (x) {\n                control = x;\n              }\n              Reflect.construct(fn, [], Fake);\n            } else {\n              try {\n                Fake.call();\n              } catch (x) {\n                control = x;\n              }\n              fn.call(Fake.prototype);\n            }\n          } else {\n            try {\n              throw Error();\n            } catch (x) {\n              control = x;\n            }\n            fn();\n          }\n        } catch (sample) {\n          if (sample && control && typeof sample.stack === \"string\") {\n            var sampleLines = sample.stack.split(`\n`);\n            var controlLines = control.stack.split(`\n`);\n            var s = sampleLines.length - 1;\n            var c = controlLines.length - 1;\n            while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n              c--;\n            }\n            for (;s >= 1 && c >= 0; s--, c--) {\n              if (sampleLines[s] !== controlLines[c]) {\n                if (s !== 1 || c !== 1) {\n                  do {\n                    s--;\n                    c--;\n                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                      var _frame = `\n` + sampleLines[s].replace(\" at new \", \" at \");\n                      if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                        _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                      }\n                      {\n                        if (typeof fn === \"function\") {\n                          componentFrameCache.set(fn, _frame);\n                        }\n                      }\n                      return _frame;\n                    }\n                  } while (s >= 1 && c >= 0);\n                }\n                break;\n              }\n            }\n          }\n        } finally {\n          reentry = false;\n          {\n            ReactCurrentDispatcher$1.current = previousDispatcher;\n            reenableLogs();\n          }\n          Error.prepareStackTrace = previousPrepareStackTrace;\n        }\n        var name = fn ? fn.displayName || fn.name : \"\";\n        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n        {\n          if (typeof fn === \"function\") {\n            componentFrameCache.set(fn, syntheticFrame);\n          }\n        }\n        return syntheticFrame;\n      }\n      function describeFunctionComponentFrame(fn, source, ownerFn) {\n        {\n          return describeNativeComponentFrame(fn, false);\n        }\n      }\n      function shouldConstruct(Component2) {\n        var prototype = Component2.prototype;\n        return !!(prototype && prototype.isReactComponent);\n      }\n      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n        if (type == null) {\n          return \"\";\n        }\n        if (typeof type === \"function\") {\n          {\n            return describeNativeComponentFrame(type, shouldConstruct(type));\n          }\n        }\n        if (typeof type === \"string\") {\n          return describeBuiltInComponentFrame(type);\n        }\n        switch (type) {\n          case REACT_SUSPENSE_TYPE:\n            return describeBuiltInComponentFrame(\"Suspense\");\n          case REACT_SUSPENSE_LIST_TYPE:\n            return describeBuiltInComponentFrame(\"SuspenseList\");\n        }\n        if (typeof type === \"object\") {\n          switch (type.$$typeof) {\n            case REACT_FORWARD_REF_TYPE:\n              return describeFunctionComponentFrame(type.render);\n            case REACT_MEMO_TYPE:\n              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n            case REACT_LAZY_TYPE: {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n              try {\n                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n              } catch (x) {}\n            }\n          }\n        }\n        return \"\";\n      }\n      var loggedTypeFailures = {};\n      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n      function setCurrentlyValidatingElement(element) {\n        {\n          if (element) {\n            var owner = element._owner;\n            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n          } else {\n            ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n          }\n        }\n      }\n      function checkPropTypes(typeSpecs, values, location, componentName, element) {\n        {\n          var has = Function.call.bind(hasOwnProperty);\n          for (var typeSpecName in typeSpecs) {\n            if (has(typeSpecs, typeSpecName)) {\n              var error$1 = undefined;\n              try {\n                if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                  var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                  err.name = \"Invariant Violation\";\n                  throw err;\n                }\n                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n              } catch (ex) {\n                error$1 = ex;\n              }\n              if (error$1 && !(error$1 instanceof Error)) {\n                setCurrentlyValidatingElement(element);\n                error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                setCurrentlyValidatingElement(null);\n              }\n              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                loggedTypeFailures[error$1.message] = true;\n                setCurrentlyValidatingElement(element);\n                error(\"Failed %s type: %s\", location, error$1.message);\n                setCurrentlyValidatingElement(null);\n              }\n            }\n          }\n        }\n      }\n      function setCurrentlyValidatingElement$1(element) {\n        {\n          if (element) {\n            var owner = element._owner;\n            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n            setExtraStackFrame(stack);\n          } else {\n            setExtraStackFrame(null);\n          }\n        }\n      }\n      var propTypesMisspellWarningShown;\n      {\n        propTypesMisspellWarningShown = false;\n      }\n      function getDeclarationErrorAddendum() {\n        if (ReactCurrentOwner.current) {\n          var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n          if (name) {\n            return `\n\nCheck the render method of \\`` + name + \"`.\";\n          }\n        }\n        return \"\";\n      }\n      function getSourceInfoErrorAddendum(source) {\n        if (source !== undefined) {\n          var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n          var lineNumber = source.lineNumber;\n          return `\n\nCheck your code at ` + fileName + \":\" + lineNumber + \".\";\n        }\n        return \"\";\n      }\n      function getSourceInfoErrorAddendumForProps(elementProps) {\n        if (elementProps !== null && elementProps !== undefined) {\n          return getSourceInfoErrorAddendum(elementProps.__source);\n        }\n        return \"\";\n      }\n      var ownerHasKeyUseWarning = {};\n      function getCurrentComponentErrorInfo(parentType) {\n        var info = getDeclarationErrorAddendum();\n        if (!info) {\n          var parentName = typeof parentType === \"string\" ? parentType : parentType.displayName || parentType.name;\n          if (parentName) {\n            info = `\n\nCheck the top-level render call using <` + parentName + \">.\";\n          }\n        }\n        return info;\n      }\n      function validateExplicitKey(element, parentType) {\n        if (!element._store || element._store.validated || element.key != null) {\n          return;\n        }\n        element._store.validated = true;\n        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n          return;\n        }\n        ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n        var childOwner = \"\";\n        if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n          childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n        }\n        {\n          setCurrentlyValidatingElement$1(element);\n          error('Each child in a list should have a unique \"key\" prop.' + \"%s%s See https://reactjs.org/link/warning-keys for more information.\", currentComponentErrorInfo, childOwner);\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n      function validateChildKeys(node, parentType) {\n        if (typeof node !== \"object\") {\n          return;\n        }\n        if (isArray(node)) {\n          for (var i = 0;i < node.length; i++) {\n            var child = node[i];\n            if (isValidElement(child)) {\n              validateExplicitKey(child, parentType);\n            }\n          }\n        } else if (isValidElement(node)) {\n          if (node._store) {\n            node._store.validated = true;\n          }\n        } else if (node) {\n          var iteratorFn = getIteratorFn(node);\n          if (typeof iteratorFn === \"function\") {\n            if (iteratorFn !== node.entries) {\n              var iterator = iteratorFn.call(node);\n              var step;\n              while (!(step = iterator.next()).done) {\n                if (isValidElement(step.value)) {\n                  validateExplicitKey(step.value, parentType);\n                }\n              }\n            }\n          }\n        }\n      }\n      function validatePropTypes(element) {\n        {\n          var type = element.type;\n          if (type === null || type === undefined || typeof type === \"string\") {\n            return;\n          }\n          var propTypes;\n          if (typeof type === \"function\") {\n            propTypes = type.propTypes;\n          } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {\n            propTypes = type.propTypes;\n          } else {\n            return;\n          }\n          if (propTypes) {\n            var name = getComponentNameFromType(type);\n            checkPropTypes(propTypes, element.props, \"prop\", name, element);\n          } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n            propTypesMisspellWarningShown = true;\n            var _name = getComponentNameFromType(type);\n            error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n          }\n          if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n            error(\"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\");\n          }\n        }\n      }\n      function validateFragmentProps(fragment) {\n        {\n          var keys = Object.keys(fragment.props);\n          for (var i = 0;i < keys.length; i++) {\n            var key = keys[i];\n            if (key !== \"children\" && key !== \"key\") {\n              setCurrentlyValidatingElement$1(fragment);\n              error(\"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.\", key);\n              setCurrentlyValidatingElement$1(null);\n              break;\n            }\n          }\n          if (fragment.ref !== null) {\n            setCurrentlyValidatingElement$1(fragment);\n            error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n            setCurrentlyValidatingElement$1(null);\n          }\n        }\n      }\n      function createElementWithValidation(type, props, children) {\n        var validType = isValidElementType(type);\n        if (!validType) {\n          var info = \"\";\n          if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n            info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n          }\n          var sourceInfo = getSourceInfoErrorAddendumForProps(props);\n          if (sourceInfo) {\n            info += sourceInfo;\n          } else {\n            info += getDeclarationErrorAddendum();\n          }\n          var typeString;\n          if (type === null) {\n            typeString = \"null\";\n          } else if (isArray(type)) {\n            typeString = \"array\";\n          } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n            typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n            info = \" Did you accidentally export a JSX literal instead of a component?\";\n          } else {\n            typeString = typeof type;\n          }\n          {\n            error(\"React.createElement: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n          }\n        }\n        var element = createElement.apply(this, arguments);\n        if (element == null) {\n          return element;\n        }\n        if (validType) {\n          for (var i = 2;i < arguments.length; i++) {\n            validateChildKeys(arguments[i], type);\n          }\n        }\n        if (type === REACT_FRAGMENT_TYPE) {\n          validateFragmentProps(element);\n        } else {\n          validatePropTypes(element);\n        }\n        return element;\n      }\n      var didWarnAboutDeprecatedCreateFactory = false;\n      function createFactoryWithValidation(type) {\n        var validatedFactory = createElementWithValidation.bind(null, type);\n        validatedFactory.type = type;\n        {\n          if (!didWarnAboutDeprecatedCreateFactory) {\n            didWarnAboutDeprecatedCreateFactory = true;\n            warn(\"React.createFactory() is deprecated and will be removed in \" + \"a future major release. Consider using JSX \" + \"or use React.createElement() directly instead.\");\n          }\n          Object.defineProperty(validatedFactory, \"type\", {\n            enumerable: false,\n            get: function() {\n              warn(\"Factory.type is deprecated. Access the class directly \" + \"before passing it to createFactory.\");\n              Object.defineProperty(this, \"type\", {\n                value: type\n              });\n              return type;\n            }\n          });\n        }\n        return validatedFactory;\n      }\n      function cloneElementWithValidation(element, props, children) {\n        var newElement = cloneElement.apply(this, arguments);\n        for (var i = 2;i < arguments.length; i++) {\n          validateChildKeys(arguments[i], newElement.type);\n        }\n        validatePropTypes(newElement);\n        return newElement;\n      }\n      function startTransition(scope, options) {\n        var prevTransition = ReactCurrentBatchConfig.transition;\n        ReactCurrentBatchConfig.transition = {};\n        var currentTransition = ReactCurrentBatchConfig.transition;\n        {\n          ReactCurrentBatchConfig.transition._updatedFibers = new Set;\n        }\n        try {\n          scope();\n        } finally {\n          ReactCurrentBatchConfig.transition = prevTransition;\n          {\n            if (prevTransition === null && currentTransition._updatedFibers) {\n              var updatedFibersCount = currentTransition._updatedFibers.size;\n              if (updatedFibersCount > 10) {\n                warn(\"Detected a large number of updates inside startTransition. \" + \"If this is due to a subscription please re-write it to use React provided hooks. \" + \"Otherwise concurrent mode guarantees are off the table.\");\n              }\n              currentTransition._updatedFibers.clear();\n            }\n          }\n        }\n      }\n      var didWarnAboutMessageChannel = false;\n      var enqueueTaskImpl = null;\n      function enqueueTask(task) {\n        if (enqueueTaskImpl === null) {\n          try {\n            var requireString = (\"require\" + Math.random()).slice(0, 7);\n            var nodeRequire = module && module[requireString];\n            enqueueTaskImpl = nodeRequire.call(module, \"timers\").setImmediate;\n          } catch (_err) {\n            enqueueTaskImpl = function(callback) {\n              {\n                if (didWarnAboutMessageChannel === false) {\n                  didWarnAboutMessageChannel = true;\n                  if (typeof MessageChannel === \"undefined\") {\n                    error(\"This browser does not have a MessageChannel implementation, \" + \"so enqueuing tasks via await act(async () => ...) will fail. \" + \"Please file an issue at https://github.com/facebook/react/issues \" + \"if you encounter this warning.\");\n                  }\n                }\n              }\n              var channel = new MessageChannel;\n              channel.port1.onmessage = callback;\n              channel.port2.postMessage(undefined);\n            };\n          }\n        }\n        return enqueueTaskImpl(task);\n      }\n      var actScopeDepth = 0;\n      var didWarnNoAwaitAct = false;\n      function act(callback) {\n        {\n          var prevActScopeDepth = actScopeDepth;\n          actScopeDepth++;\n          if (ReactCurrentActQueue.current === null) {\n            ReactCurrentActQueue.current = [];\n          }\n          var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;\n          var result;\n          try {\n            ReactCurrentActQueue.isBatchingLegacy = true;\n            result = callback();\n            if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {\n              var queue = ReactCurrentActQueue.current;\n              if (queue !== null) {\n                ReactCurrentActQueue.didScheduleLegacyUpdate = false;\n                flushActQueue(queue);\n              }\n            }\n          } catch (error2) {\n            popActScope(prevActScopeDepth);\n            throw error2;\n          } finally {\n            ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;\n          }\n          if (result !== null && typeof result === \"object\" && typeof result.then === \"function\") {\n            var thenableResult = result;\n            var wasAwaited = false;\n            var thenable = {\n              then: function(resolve, reject) {\n                wasAwaited = true;\n                thenableResult.then(function(returnValue2) {\n                  popActScope(prevActScopeDepth);\n                  if (actScopeDepth === 0) {\n                    recursivelyFlushAsyncActWork(returnValue2, resolve, reject);\n                  } else {\n                    resolve(returnValue2);\n                  }\n                }, function(error2) {\n                  popActScope(prevActScopeDepth);\n                  reject(error2);\n                });\n              }\n            };\n            {\n              if (!didWarnNoAwaitAct && typeof Promise !== \"undefined\") {\n                Promise.resolve().then(function() {}).then(function() {\n                  if (!wasAwaited) {\n                    didWarnNoAwaitAct = true;\n                    error(\"You called act(async () => ...) without await. \" + \"This could lead to unexpected testing behaviour, \" + \"interleaving multiple act calls and mixing their \" + \"scopes. \" + \"You should - await act(async () => ...);\");\n                  }\n                });\n              }\n            }\n            return thenable;\n          } else {\n            var returnValue = result;\n            popActScope(prevActScopeDepth);\n            if (actScopeDepth === 0) {\n              var _queue = ReactCurrentActQueue.current;\n              if (_queue !== null) {\n                flushActQueue(_queue);\n                ReactCurrentActQueue.current = null;\n              }\n              var _thenable = {\n                then: function(resolve, reject) {\n                  if (ReactCurrentActQueue.current === null) {\n                    ReactCurrentActQueue.current = [];\n                    recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n                  } else {\n                    resolve(returnValue);\n                  }\n                }\n              };\n              return _thenable;\n            } else {\n              var _thenable2 = {\n                then: function(resolve, reject) {\n                  resolve(returnValue);\n                }\n              };\n              return _thenable2;\n            }\n          }\n        }\n      }\n      function popActScope(prevActScopeDepth) {\n        {\n          if (prevActScopeDepth !== actScopeDepth - 1) {\n            error(\"You seem to have overlapping act() calls, this is not supported. \" + \"Be sure to await previous act() calls before making a new one. \");\n          }\n          actScopeDepth = prevActScopeDepth;\n        }\n      }\n      function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {\n        {\n          var queue = ReactCurrentActQueue.current;\n          if (queue !== null) {\n            try {\n              flushActQueue(queue);\n              enqueueTask(function() {\n                if (queue.length === 0) {\n                  ReactCurrentActQueue.current = null;\n                  resolve(returnValue);\n                } else {\n                  recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n                }\n              });\n            } catch (error2) {\n              reject(error2);\n            }\n          } else {\n            resolve(returnValue);\n          }\n        }\n      }\n      var isFlushing = false;\n      function flushActQueue(queue) {\n        {\n          if (!isFlushing) {\n            isFlushing = true;\n            var i = 0;\n            try {\n              for (;i < queue.length; i++) {\n                var callback = queue[i];\n                do {\n                  callback = callback(true);\n                } while (callback !== null);\n              }\n              queue.length = 0;\n            } catch (error2) {\n              queue = queue.slice(i + 1);\n              throw error2;\n            } finally {\n              isFlushing = false;\n            }\n          }\n        }\n      }\n      var createElement$1 = createElementWithValidation;\n      var cloneElement$1 = cloneElementWithValidation;\n      var createFactory = createFactoryWithValidation;\n      var Children = {\n        map: mapChildren,\n        forEach: forEachChildren,\n        count: countChildren,\n        toArray,\n        only: onlyChild\n      };\n      exports.Children = Children;\n      exports.Component = Component;\n      exports.Fragment = REACT_FRAGMENT_TYPE;\n      exports.Profiler = REACT_PROFILER_TYPE;\n      exports.PureComponent = PureComponent;\n      exports.StrictMode = REACT_STRICT_MODE_TYPE;\n      exports.Suspense = REACT_SUSPENSE_TYPE;\n      exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;\n      exports.act = act;\n      exports.cloneElement = cloneElement$1;\n      exports.createContext = createContext;\n      exports.createElement = createElement$1;\n      exports.createFactory = createFactory;\n      exports.createRef = createRef;\n      exports.forwardRef = forwardRef;\n      exports.isValidElement = isValidElement;\n      exports.lazy = lazy;\n      exports.memo = memo;\n      exports.startTransition = startTransition;\n      exports.unstable_act = act;\n      exports.useCallback = useCallback;\n      exports.useContext = useContext;\n      exports.useDebugValue = useDebugValue;\n      exports.useDeferredValue = useDeferredValue;\n      exports.useEffect = useEffect;\n      exports.useId = useId;\n      exports.useImperativeHandle = useImperativeHandle;\n      exports.useInsertionEffect = useInsertionEffect;\n      exports.useLayoutEffect = useLayoutEffect;\n      exports.useMemo = useMemo;\n      exports.useReducer = useReducer;\n      exports.useRef = useRef;\n      exports.useState = useState;\n      exports.useSyncExternalStore = useSyncExternalStore;\n      exports.useTransition = useTransition;\n      exports.version = ReactVersion;\n      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error);\n      }\n    })();\n  }\n});\n\n// ../../node_modules/.bun/react@18.3.1/node_modules/react/index.js\nvar require_react = __commonJS((exports, module) => {\n  var react_development = __toESM(require_react_development(), 1);\n  if (false) {} else {\n    module.exports = react_development;\n  }\n});\n\n// ../../node_modules/.bun/scheduler@0.23.2/node_modules/scheduler/cjs/scheduler.development.js\nvar require_scheduler_development = __commonJS((exports) => {\n  if (true) {\n    (function() {\n      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error);\n      }\n      var enableSchedulerDebugging = false;\n      var enableProfiling = false;\n      var frameYieldMs = 5;\n      function push(heap, node) {\n        var index = heap.length;\n        heap.push(node);\n        siftUp(heap, node, index);\n      }\n      function peek(heap) {\n        return heap.length === 0 ? null : heap[0];\n      }\n      function pop(heap) {\n        if (heap.length === 0) {\n          return null;\n        }\n        var first = heap[0];\n        var last = heap.pop();\n        if (last !== first) {\n          heap[0] = last;\n          siftDown(heap, last, 0);\n        }\n        return first;\n      }\n      function siftUp(heap, node, i) {\n        var index = i;\n        while (index > 0) {\n          var parentIndex = index - 1 >>> 1;\n          var parent = heap[parentIndex];\n          if (compare(parent, node) > 0) {\n            heap[parentIndex] = node;\n            heap[index] = parent;\n            index = parentIndex;\n          } else {\n            return;\n          }\n        }\n      }\n      function siftDown(heap, node, i) {\n        var index = i;\n        var length = heap.length;\n        var halfLength = length >>> 1;\n        while (index < halfLength) {\n          var leftIndex = (index + 1) * 2 - 1;\n          var left = heap[leftIndex];\n          var rightIndex = leftIndex + 1;\n          var right = heap[rightIndex];\n          if (compare(left, node) < 0) {\n            if (rightIndex < length && compare(right, left) < 0) {\n              heap[index] = right;\n              heap[rightIndex] = node;\n              index = rightIndex;\n            } else {\n              heap[index] = left;\n              heap[leftIndex] = node;\n              index = leftIndex;\n            }\n          } else if (rightIndex < length && compare(right, node) < 0) {\n            heap[index] = right;\n            heap[rightIndex] = node;\n            index = rightIndex;\n          } else {\n            return;\n          }\n        }\n      }\n      function compare(a, b) {\n        var diff = a.sortIndex - b.sortIndex;\n        return diff !== 0 ? diff : a.id - b.id;\n      }\n      var ImmediatePriority = 1;\n      var UserBlockingPriority = 2;\n      var NormalPriority = 3;\n      var LowPriority = 4;\n      var IdlePriority = 5;\n      function markTaskErrored(task, ms) {}\n      var hasPerformanceNow = typeof performance === \"object\" && typeof performance.now === \"function\";\n      if (hasPerformanceNow) {\n        var localPerformance = performance;\n        exports.unstable_now = function() {\n          return localPerformance.now();\n        };\n      } else {\n        var localDate = Date;\n        var initialTime = localDate.now();\n        exports.unstable_now = function() {\n          return localDate.now() - initialTime;\n        };\n      }\n      var maxSigned31BitInt = 1073741823;\n      var IMMEDIATE_PRIORITY_TIMEOUT = -1;\n      var USER_BLOCKING_PRIORITY_TIMEOUT = 250;\n      var NORMAL_PRIORITY_TIMEOUT = 5000;\n      var LOW_PRIORITY_TIMEOUT = 1e4;\n      var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;\n      var taskQueue = [];\n      var timerQueue = [];\n      var taskIdCounter = 1;\n      var currentTask = null;\n      var currentPriorityLevel = NormalPriority;\n      var isPerformingWork = false;\n      var isHostCallbackScheduled = false;\n      var isHostTimeoutScheduled = false;\n      var localSetTimeout = typeof setTimeout === \"function\" ? setTimeout : null;\n      var localClearTimeout = typeof clearTimeout === \"function\" ? clearTimeout : null;\n      var localSetImmediate = typeof setImmediate !== \"undefined\" ? setImmediate : null;\n      var isInputPending = typeof navigator !== \"undefined\" && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;\n      function advanceTimers(currentTime) {\n        var timer = peek(timerQueue);\n        while (timer !== null) {\n          if (timer.callback === null) {\n            pop(timerQueue);\n          } else if (timer.startTime <= currentTime) {\n            pop(timerQueue);\n            timer.sortIndex = timer.expirationTime;\n            push(taskQueue, timer);\n          } else {\n            return;\n          }\n          timer = peek(timerQueue);\n        }\n      }\n      function handleTimeout(currentTime) {\n        isHostTimeoutScheduled = false;\n        advanceTimers(currentTime);\n        if (!isHostCallbackScheduled) {\n          if (peek(taskQueue) !== null) {\n            isHostCallbackScheduled = true;\n            requestHostCallback(flushWork);\n          } else {\n            var firstTimer = peek(timerQueue);\n            if (firstTimer !== null) {\n              requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n            }\n          }\n        }\n      }\n      function flushWork(hasTimeRemaining, initialTime2) {\n        isHostCallbackScheduled = false;\n        if (isHostTimeoutScheduled) {\n          isHostTimeoutScheduled = false;\n          cancelHostTimeout();\n        }\n        isPerformingWork = true;\n        var previousPriorityLevel = currentPriorityLevel;\n        try {\n          if (enableProfiling) {\n            try {\n              return workLoop(hasTimeRemaining, initialTime2);\n            } catch (error) {\n              if (currentTask !== null) {\n                var currentTime = exports.unstable_now();\n                markTaskErrored(currentTask, currentTime);\n                currentTask.isQueued = false;\n              }\n              throw error;\n            }\n          } else {\n            return workLoop(hasTimeRemaining, initialTime2);\n          }\n        } finally {\n          currentTask = null;\n          currentPriorityLevel = previousPriorityLevel;\n          isPerformingWork = false;\n        }\n      }\n      function workLoop(hasTimeRemaining, initialTime2) {\n        var currentTime = initialTime2;\n        advanceTimers(currentTime);\n        currentTask = peek(taskQueue);\n        while (currentTask !== null && !enableSchedulerDebugging) {\n          if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n            break;\n          }\n          var callback = currentTask.callback;\n          if (typeof callback === \"function\") {\n            currentTask.callback = null;\n            currentPriorityLevel = currentTask.priorityLevel;\n            var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n            var continuationCallback = callback(didUserCallbackTimeout);\n            currentTime = exports.unstable_now();\n            if (typeof continuationCallback === \"function\") {\n              currentTask.callback = continuationCallback;\n            } else {\n              if (currentTask === peek(taskQueue)) {\n                pop(taskQueue);\n              }\n            }\n            advanceTimers(currentTime);\n          } else {\n            pop(taskQueue);\n          }\n          currentTask = peek(taskQueue);\n        }\n        if (currentTask !== null) {\n          return true;\n        } else {\n          var firstTimer = peek(timerQueue);\n          if (firstTimer !== null) {\n            requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n          }\n          return false;\n        }\n      }\n      function unstable_runWithPriority(priorityLevel, eventHandler) {\n        switch (priorityLevel) {\n          case ImmediatePriority:\n          case UserBlockingPriority:\n          case NormalPriority:\n          case LowPriority:\n          case IdlePriority:\n            break;\n          default:\n            priorityLevel = NormalPriority;\n        }\n        var previousPriorityLevel = currentPriorityLevel;\n        currentPriorityLevel = priorityLevel;\n        try {\n          return eventHandler();\n        } finally {\n          currentPriorityLevel = previousPriorityLevel;\n        }\n      }\n      function unstable_next(eventHandler) {\n        var priorityLevel;\n        switch (currentPriorityLevel) {\n          case ImmediatePriority:\n          case UserBlockingPriority:\n          case NormalPriority:\n            priorityLevel = NormalPriority;\n            break;\n          default:\n            priorityLevel = currentPriorityLevel;\n            break;\n        }\n        var previousPriorityLevel = currentPriorityLevel;\n        currentPriorityLevel = priorityLevel;\n        try {\n          return eventHandler();\n        } finally {\n          currentPriorityLevel = previousPriorityLevel;\n        }\n      }\n      function unstable_wrapCallback(callback) {\n        var parentPriorityLevel = currentPriorityLevel;\n        return function() {\n          var previousPriorityLevel = currentPriorityLevel;\n          currentPriorityLevel = parentPriorityLevel;\n          try {\n            return callback.apply(this, arguments);\n          } finally {\n            currentPriorityLevel = previousPriorityLevel;\n          }\n        };\n      }\n      function unstable_scheduleCallback(priorityLevel, callback, options) {\n        var currentTime = exports.unstable_now();\n        var startTime2;\n        if (typeof options === \"object\" && options !== null) {\n          var delay = options.delay;\n          if (typeof delay === \"number\" && delay > 0) {\n            startTime2 = currentTime + delay;\n          } else {\n            startTime2 = currentTime;\n          }\n        } else {\n          startTime2 = currentTime;\n        }\n        var timeout;\n        switch (priorityLevel) {\n          case ImmediatePriority:\n            timeout = IMMEDIATE_PRIORITY_TIMEOUT;\n            break;\n          case UserBlockingPriority:\n            timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\n            break;\n          case IdlePriority:\n            timeout = IDLE_PRIORITY_TIMEOUT;\n            break;\n          case LowPriority:\n            timeout = LOW_PRIORITY_TIMEOUT;\n            break;\n          case NormalPriority:\n          default:\n            timeout = NORMAL_PRIORITY_TIMEOUT;\n            break;\n        }\n        var expirationTime = startTime2 + timeout;\n        var newTask = {\n          id: taskIdCounter++,\n          callback,\n          priorityLevel,\n          startTime: startTime2,\n          expirationTime,\n          sortIndex: -1\n        };\n        if (startTime2 > currentTime) {\n          newTask.sortIndex = startTime2;\n          push(timerQueue, newTask);\n          if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n            if (isHostTimeoutScheduled) {\n              cancelHostTimeout();\n            } else {\n              isHostTimeoutScheduled = true;\n            }\n            requestHostTimeout(handleTimeout, startTime2 - currentTime);\n          }\n        } else {\n          newTask.sortIndex = expirationTime;\n          push(taskQueue, newTask);\n          if (!isHostCallbackScheduled && !isPerformingWork) {\n            isHostCallbackScheduled = true;\n            requestHostCallback(flushWork);\n          }\n        }\n        return newTask;\n      }\n      function unstable_pauseExecution() {}\n      function unstable_continueExecution() {\n        if (!isHostCallbackScheduled && !isPerformingWork) {\n          isHostCallbackScheduled = true;\n          requestHostCallback(flushWork);\n        }\n      }\n      function unstable_getFirstCallbackNode() {\n        return peek(taskQueue);\n      }\n      function unstable_cancelCallback(task) {\n        task.callback = null;\n      }\n      function unstable_getCurrentPriorityLevel() {\n        return currentPriorityLevel;\n      }\n      var isMessageLoopRunning = false;\n      var scheduledHostCallback = null;\n      var taskTimeoutID = -1;\n      var frameInterval = frameYieldMs;\n      var startTime = -1;\n      function shouldYieldToHost() {\n        var timeElapsed = exports.unstable_now() - startTime;\n        if (timeElapsed < frameInterval) {\n          return false;\n        }\n        return true;\n      }\n      function requestPaint() {}\n      function forceFrameRate(fps) {\n        if (fps < 0 || fps > 125) {\n          console[\"error\"](\"forceFrameRate takes a positive int between 0 and 125, \" + \"forcing frame rates higher than 125 fps is not supported\");\n          return;\n        }\n        if (fps > 0) {\n          frameInterval = Math.floor(1000 / fps);\n        } else {\n          frameInterval = frameYieldMs;\n        }\n      }\n      var performWorkUntilDeadline = function() {\n        if (scheduledHostCallback !== null) {\n          var currentTime = exports.unstable_now();\n          startTime = currentTime;\n          var hasTimeRemaining = true;\n          var hasMoreWork = true;\n          try {\n            hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n          } finally {\n            if (hasMoreWork) {\n              schedulePerformWorkUntilDeadline();\n            } else {\n              isMessageLoopRunning = false;\n              scheduledHostCallback = null;\n            }\n          }\n        } else {\n          isMessageLoopRunning = false;\n        }\n      };\n      var schedulePerformWorkUntilDeadline;\n      if (typeof localSetImmediate === \"function\") {\n        schedulePerformWorkUntilDeadline = function() {\n          localSetImmediate(performWorkUntilDeadline);\n        };\n      } else if (typeof MessageChannel !== \"undefined\") {\n        var channel = new MessageChannel;\n        var port = channel.port2;\n        channel.port1.onmessage = performWorkUntilDeadline;\n        schedulePerformWorkUntilDeadline = function() {\n          port.postMessage(null);\n        };\n      } else {\n        schedulePerformWorkUntilDeadline = function() {\n          localSetTimeout(performWorkUntilDeadline, 0);\n        };\n      }\n      function requestHostCallback(callback) {\n        scheduledHostCallback = callback;\n        if (!isMessageLoopRunning) {\n          isMessageLoopRunning = true;\n          schedulePerformWorkUntilDeadline();\n        }\n      }\n      function requestHostTimeout(callback, ms) {\n        taskTimeoutID = localSetTimeout(function() {\n          callback(exports.unstable_now());\n        }, ms);\n      }\n      function cancelHostTimeout() {\n        localClearTimeout(taskTimeoutID);\n        taskTimeoutID = -1;\n      }\n      var unstable_requestPaint = requestPaint;\n      var unstable_Profiling = null;\n      exports.unstable_IdlePriority = IdlePriority;\n      exports.unstable_ImmediatePriority = ImmediatePriority;\n      exports.unstable_LowPriority = LowPriority;\n      exports.unstable_NormalPriority = NormalPriority;\n      exports.unstable_Profiling = unstable_Profiling;\n      exports.unstable_UserBlockingPriority = UserBlockingPriority;\n      exports.unstable_cancelCallback = unstable_cancelCallback;\n      exports.unstable_continueExecution = unstable_continueExecution;\n      exports.unstable_forceFrameRate = forceFrameRate;\n      exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n      exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\n      exports.unstable_next = unstable_next;\n      exports.unstable_pauseExecution = unstable_pauseExecution;\n      exports.unstable_requestPaint = unstable_requestPaint;\n      exports.unstable_runWithPriority = unstable_runWithPriority;\n      exports.unstable_scheduleCallback = unstable_scheduleCallback;\n      exports.unstable_shouldYield = shouldYieldToHost;\n      exports.unstable_wrapCallback = unstable_wrapCallback;\n      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error);\n      }\n    })();\n  }\n});\n\n// ../../node_modules/.bun/scheduler@0.23.2/node_modules/scheduler/index.js\nvar require_scheduler = __commonJS((exports, module) => {\n  var scheduler_development = __toESM(require_scheduler_development(), 1);\n  if (false) {} else {\n    module.exports = scheduler_development;\n  }\n});\n\n// ../../node_modules/.bun/react-dom@18.3.1+f4eacebf2041cd4f/node_modules/react-dom/cjs/react-dom.development.js\nvar require_react_dom_development = __commonJS((exports) => {\n  var React = __toESM(require_react(), 1);\n  var Scheduler = __toESM(require_scheduler(), 1);\n  if (true) {\n    (function() {\n      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error);\n      }\n      var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n      var suppressWarning = false;\n      function setSuppressWarning(newSuppressWarning) {\n        {\n          suppressWarning = newSuppressWarning;\n        }\n      }\n      function warn(format) {\n        {\n          if (!suppressWarning) {\n            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {\n              args[_key - 1] = arguments[_key];\n            }\n            printWarning(\"warn\", format, args);\n          }\n        }\n      }\n      function error(format) {\n        {\n          if (!suppressWarning) {\n            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;_key2 < _len2; _key2++) {\n              args[_key2 - 1] = arguments[_key2];\n            }\n            printWarning(\"error\", format, args);\n          }\n        }\n      }\n      function printWarning(level, format, args) {\n        {\n          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;\n          var stack = ReactDebugCurrentFrame2.getStackAddendum();\n          if (stack !== \"\") {\n            format += \"%s\";\n            args = args.concat([stack]);\n          }\n          var argsWithFormat = args.map(function(item) {\n            return String(item);\n          });\n          argsWithFormat.unshift(\"Warning: \" + format);\n          Function.prototype.apply.call(console[level], console, argsWithFormat);\n        }\n      }\n      var FunctionComponent = 0;\n      var ClassComponent = 1;\n      var IndeterminateComponent = 2;\n      var HostRoot = 3;\n      var HostPortal = 4;\n      var HostComponent = 5;\n      var HostText = 6;\n      var Fragment = 7;\n      var Mode = 8;\n      var ContextConsumer = 9;\n      var ContextProvider = 10;\n      var ForwardRef = 11;\n      var Profiler = 12;\n      var SuspenseComponent = 13;\n      var MemoComponent = 14;\n      var SimpleMemoComponent = 15;\n      var LazyComponent = 16;\n      var IncompleteClassComponent = 17;\n      var DehydratedFragment = 18;\n      var SuspenseListComponent = 19;\n      var ScopeComponent = 21;\n      var OffscreenComponent = 22;\n      var LegacyHiddenComponent = 23;\n      var CacheComponent = 24;\n      var TracingMarkerComponent = 25;\n      var enableClientRenderFallbackOnTextMismatch = true;\n      var enableNewReconciler = false;\n      var enableLazyContextPropagation = false;\n      var enableLegacyHidden = false;\n      var enableSuspenseAvoidThisFallback = false;\n      var disableCommentsAsDOMContainers = true;\n      var enableCustomElementPropertySupport = false;\n      var warnAboutStringRefs = true;\n      var enableSchedulingProfiler = true;\n      var enableProfilerTimer = true;\n      var enableProfilerCommitHooks = true;\n      var allNativeEvents = new Set;\n      var registrationNameDependencies = {};\n      var possibleRegistrationNames = {};\n      function registerTwoPhaseEvent(registrationName, dependencies) {\n        registerDirectEvent(registrationName, dependencies);\n        registerDirectEvent(registrationName + \"Capture\", dependencies);\n      }\n      function registerDirectEvent(registrationName, dependencies) {\n        {\n          if (registrationNameDependencies[registrationName]) {\n            error(\"EventRegistry: More than one plugin attempted to publish the same \" + \"registration name, `%s`.\", registrationName);\n          }\n        }\n        registrationNameDependencies[registrationName] = dependencies;\n        {\n          var lowerCasedName = registrationName.toLowerCase();\n          possibleRegistrationNames[lowerCasedName] = registrationName;\n          if (registrationName === \"onDoubleClick\") {\n            possibleRegistrationNames.ondblclick = registrationName;\n          }\n        }\n        for (var i = 0;i < dependencies.length; i++) {\n          allNativeEvents.add(dependencies[i]);\n        }\n      }\n      var canUseDOM = !!(typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\");\n      var hasOwnProperty = Object.prototype.hasOwnProperty;\n      function typeName(value) {\n        {\n          var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n          var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\";\n          return type;\n        }\n      }\n      function willCoercionThrow(value) {\n        {\n          try {\n            testStringCoercion(value);\n            return false;\n          } catch (e) {\n            return true;\n          }\n        }\n      }\n      function testStringCoercion(value) {\n        return \"\" + value;\n      }\n      function checkAttributeStringCoercion(value, attributeName) {\n        {\n          if (willCoercionThrow(value)) {\n            error(\"The provided `%s` attribute is an unsupported type %s.\" + \" This value must be coerced to a string before before using it here.\", attributeName, typeName(value));\n            return testStringCoercion(value);\n          }\n        }\n      }\n      function checkKeyStringCoercion(value) {\n        {\n          if (willCoercionThrow(value)) {\n            error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before before using it here.\", typeName(value));\n            return testStringCoercion(value);\n          }\n        }\n      }\n      function checkPropStringCoercion(value, propName) {\n        {\n          if (willCoercionThrow(value)) {\n            error(\"The provided `%s` prop is an unsupported type %s.\" + \" This value must be coerced to a string before before using it here.\", propName, typeName(value));\n            return testStringCoercion(value);\n          }\n        }\n      }\n      function checkCSSPropertyStringCoercion(value, propName) {\n        {\n          if (willCoercionThrow(value)) {\n            error(\"The provided `%s` CSS property is an unsupported type %s.\" + \" This value must be coerced to a string before before using it here.\", propName, typeName(value));\n            return testStringCoercion(value);\n          }\n        }\n      }\n      function checkHtmlStringCoercion(value) {\n        {\n          if (willCoercionThrow(value)) {\n            error(\"The provided HTML markup uses a value of unsupported type %s.\" + \" This value must be coerced to a string before before using it here.\", typeName(value));\n            return testStringCoercion(value);\n          }\n        }\n      }\n      function checkFormFieldValueStringCoercion(value) {\n        {\n          if (willCoercionThrow(value)) {\n            error(\"Form field values (value, checked, defaultValue, or defaultChecked props)\" + \" must be strings, not %s.\" + \" This value must be coerced to a string before before using it here.\", typeName(value));\n            return testStringCoercion(value);\n          }\n        }\n      }\n      var RESERVED = 0;\n      var STRING = 1;\n      var BOOLEANISH_STRING = 2;\n      var BOOLEAN = 3;\n      var OVERLOADED_BOOLEAN = 4;\n      var NUMERIC = 5;\n      var POSITIVE_NUMERIC = 6;\n      var ATTRIBUTE_NAME_START_CHAR = \":A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\n      var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + \"\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\n      var VALID_ATTRIBUTE_NAME_REGEX = new RegExp(\"^[\" + ATTRIBUTE_NAME_START_CHAR + \"][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n      var illegalAttributeNameCache = {};\n      var validatedAttributeNameCache = {};\n      function isAttributeNameSafe(attributeName) {\n        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {\n          return true;\n        }\n        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {\n          return false;\n        }\n        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {\n          validatedAttributeNameCache[attributeName] = true;\n          return true;\n        }\n        illegalAttributeNameCache[attributeName] = true;\n        {\n          error(\"Invalid attribute name: `%s`\", attributeName);\n        }\n        return false;\n      }\n      function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {\n        if (propertyInfo !== null) {\n          return propertyInfo.type === RESERVED;\n        }\n        if (isCustomComponentTag) {\n          return false;\n        }\n        if (name.length > 2 && (name[0] === \"o\" || name[0] === \"O\") && (name[1] === \"n\" || name[1] === \"N\")) {\n          return true;\n        }\n        return false;\n      }\n      function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {\n        if (propertyInfo !== null && propertyInfo.type === RESERVED) {\n          return false;\n        }\n        switch (typeof value) {\n          case \"function\":\n          case \"symbol\":\n            return true;\n          case \"boolean\": {\n            if (isCustomComponentTag) {\n              return false;\n            }\n            if (propertyInfo !== null) {\n              return !propertyInfo.acceptsBooleans;\n            } else {\n              var prefix2 = name.toLowerCase().slice(0, 5);\n              return prefix2 !== \"data-\" && prefix2 !== \"aria-\";\n            }\n          }\n          default:\n            return false;\n        }\n      }\n      function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {\n        if (value === null || typeof value === \"undefined\") {\n          return true;\n        }\n        if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {\n          return true;\n        }\n        if (isCustomComponentTag) {\n          return false;\n        }\n        if (propertyInfo !== null) {\n          switch (propertyInfo.type) {\n            case BOOLEAN:\n              return !value;\n            case OVERLOADED_BOOLEAN:\n              return value === false;\n            case NUMERIC:\n              return isNaN(value);\n            case POSITIVE_NUMERIC:\n              return isNaN(value) || value < 1;\n          }\n        }\n        return false;\n      }\n      function getPropertyInfo(name) {\n        return properties.hasOwnProperty(name) ? properties[name] : null;\n      }\n      function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {\n        this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;\n        this.attributeName = attributeName;\n        this.attributeNamespace = attributeNamespace;\n        this.mustUseProperty = mustUseProperty;\n        this.propertyName = name;\n        this.type = type;\n        this.sanitizeURL = sanitizeURL2;\n        this.removeEmptyString = removeEmptyString;\n      }\n      var properties = {};\n      var reservedProps = [\n        \"children\",\n        \"dangerouslySetInnerHTML\",\n        \"defaultValue\",\n        \"defaultChecked\",\n        \"innerHTML\",\n        \"suppressContentEditableWarning\",\n        \"suppressHydrationWarning\",\n        \"style\"\n      ];\n      reservedProps.forEach(function(name) {\n        properties[name] = new PropertyInfoRecord(name, RESERVED, false, name, null, false, false);\n      });\n      [[\"acceptCharset\", \"accept-charset\"], [\"className\", \"class\"], [\"htmlFor\", \"for\"], [\"httpEquiv\", \"http-equiv\"]].forEach(function(_ref) {\n        var name = _ref[0], attributeName = _ref[1];\n        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);\n      });\n      [\"contentEditable\", \"draggable\", \"spellCheck\", \"value\"].forEach(function(name) {\n        properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name.toLowerCase(), null, false, false);\n      });\n      [\"autoReverse\", \"externalResourcesRequired\", \"focusable\", \"preserveAlpha\"].forEach(function(name) {\n        properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name, null, false, false);\n      });\n      [\n        \"allowFullScreen\",\n        \"async\",\n        \"autoFocus\",\n        \"autoPlay\",\n        \"controls\",\n        \"default\",\n        \"defer\",\n        \"disabled\",\n        \"disablePictureInPicture\",\n        \"disableRemotePlayback\",\n        \"formNoValidate\",\n        \"hidden\",\n        \"loop\",\n        \"noModule\",\n        \"noValidate\",\n        \"open\",\n        \"playsInline\",\n        \"readOnly\",\n        \"required\",\n        \"reversed\",\n        \"scoped\",\n        \"seamless\",\n        \"itemScope\"\n      ].forEach(function(name) {\n        properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, name.toLowerCase(), null, false, false);\n      });\n      [\n        \"checked\",\n        \"multiple\",\n        \"muted\",\n        \"selected\"\n      ].forEach(function(name) {\n        properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, name, null, false, false);\n      });\n      [\n        \"capture\",\n        \"download\"\n      ].forEach(function(name) {\n        properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, name, null, false, false);\n      });\n      [\n        \"cols\",\n        \"rows\",\n        \"size\",\n        \"span\"\n      ].forEach(function(name) {\n        properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, name, null, false, false);\n      });\n      [\"rowSpan\", \"start\"].forEach(function(name) {\n        properties[name] = new PropertyInfoRecord(name, NUMERIC, false, name.toLowerCase(), null, false, false);\n      });\n      var CAMELIZE = /[\\-\\:]([a-z])/g;\n      var capitalize = function(token) {\n        return token[1].toUpperCase();\n      };\n      [\n        \"accent-height\",\n        \"alignment-baseline\",\n        \"arabic-form\",\n        \"baseline-shift\",\n        \"cap-height\",\n        \"clip-path\",\n        \"clip-rule\",\n        \"color-interpolation\",\n        \"color-interpolation-filters\",\n        \"color-profile\",\n        \"color-rendering\",\n        \"dominant-baseline\",\n        \"enable-background\",\n        \"fill-opacity\",\n        \"fill-rule\",\n        \"flood-color\",\n        \"flood-opacity\",\n        \"font-family\",\n        \"font-size\",\n        \"font-size-adjust\",\n        \"font-stretch\",\n        \"font-style\",\n        \"font-variant\",\n        \"font-weight\",\n        \"glyph-name\",\n        \"glyph-orientation-horizontal\",\n        \"glyph-orientation-vertical\",\n        \"horiz-adv-x\",\n        \"horiz-origin-x\",\n        \"image-rendering\",\n        \"letter-spacing\",\n        \"lighting-color\",\n        \"marker-end\",\n        \"marker-mid\",\n        \"marker-start\",\n        \"overline-position\",\n        \"overline-thickness\",\n        \"paint-order\",\n        \"panose-1\",\n        \"pointer-events\",\n        \"rendering-intent\",\n        \"shape-rendering\",\n        \"stop-color\",\n        \"stop-opacity\",\n        \"strikethrough-position\",\n        \"strikethrough-thickness\",\n        \"stroke-dasharray\",\n        \"stroke-dashoffset\",\n        \"stroke-linecap\",\n        \"stroke-linejoin\",\n        \"stroke-miterlimit\",\n        \"stroke-opacity\",\n        \"stroke-width\",\n        \"text-anchor\",\n        \"text-decoration\",\n        \"text-rendering\",\n        \"underline-position\",\n        \"underline-thickness\",\n        \"unicode-bidi\",\n        \"unicode-range\",\n        \"units-per-em\",\n        \"v-alphabetic\",\n        \"v-hanging\",\n        \"v-ideographic\",\n        \"v-mathematical\",\n        \"vector-effect\",\n        \"vert-adv-y\",\n        \"vert-origin-x\",\n        \"vert-origin-y\",\n        \"word-spacing\",\n        \"writing-mode\",\n        \"xmlns:xlink\",\n        \"x-height\"\n      ].forEach(function(attributeName) {\n        var name = attributeName.replace(CAMELIZE, capitalize);\n        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);\n      });\n      [\n        \"xlink:actuate\",\n        \"xlink:arcrole\",\n        \"xlink:role\",\n        \"xlink:show\",\n        \"xlink:title\",\n        \"xlink:type\"\n      ].forEach(function(attributeName) {\n        var name = attributeName.replace(CAMELIZE, capitalize);\n        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, \"http://www.w3.org/1999/xlink\", false, false);\n      });\n      [\n        \"xml:base\",\n        \"xml:lang\",\n        \"xml:space\"\n      ].forEach(function(attributeName) {\n        var name = attributeName.replace(CAMELIZE, capitalize);\n        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, \"http://www.w3.org/XML/1998/namespace\", false, false);\n      });\n      [\"tabIndex\", \"crossOrigin\"].forEach(function(attributeName) {\n        properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, false, false);\n      });\n      var xlinkHref = \"xlinkHref\";\n      properties[xlinkHref] = new PropertyInfoRecord(\"xlinkHref\", STRING, false, \"xlink:href\", \"http://www.w3.org/1999/xlink\", true, false);\n      [\"src\", \"href\", \"action\", \"formAction\"].forEach(function(attributeName) {\n        properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, true, true);\n      });\n      var isJavaScriptProtocol = /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*\\:/i;\n      var didWarn = false;\n      function sanitizeURL(url) {\n        {\n          if (!didWarn && isJavaScriptProtocol.test(url)) {\n            didWarn = true;\n            error(\"A future version of React will block javascript: URLs as a security precaution. \" + \"Use event handlers instead if you can. If you need to generate unsafe HTML try \" + \"using dangerouslySetInnerHTML instead. React was passed %s.\", JSON.stringify(url));\n          }\n        }\n      }\n      function getValueForProperty(node, name, expected, propertyInfo) {\n        {\n          if (propertyInfo.mustUseProperty) {\n            var propertyName = propertyInfo.propertyName;\n            return node[propertyName];\n          } else {\n            {\n              checkAttributeStringCoercion(expected, name);\n            }\n            if (propertyInfo.sanitizeURL) {\n              sanitizeURL(\"\" + expected);\n            }\n            var attributeName = propertyInfo.attributeName;\n            var stringValue = null;\n            if (propertyInfo.type === OVERLOADED_BOOLEAN) {\n              if (node.hasAttribute(attributeName)) {\n                var value = node.getAttribute(attributeName);\n                if (value === \"\") {\n                  return true;\n                }\n                if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n                  return value;\n                }\n                if (value === \"\" + expected) {\n                  return expected;\n                }\n                return value;\n              }\n            } else if (node.hasAttribute(attributeName)) {\n              if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n                return node.getAttribute(attributeName);\n              }\n              if (propertyInfo.type === BOOLEAN) {\n                return expected;\n              }\n              stringValue = node.getAttribute(attributeName);\n            }\n            if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n              return stringValue === null ? expected : stringValue;\n            } else if (stringValue === \"\" + expected) {\n              return expected;\n            } else {\n              return stringValue;\n            }\n          }\n        }\n      }\n      function getValueForAttribute(node, name, expected, isCustomComponentTag) {\n        {\n          if (!isAttributeNameSafe(name)) {\n            return;\n          }\n          if (!node.hasAttribute(name)) {\n            return expected === undefined ? undefined : null;\n          }\n          var value = node.getAttribute(name);\n          {\n            checkAttributeStringCoercion(expected, name);\n          }\n          if (value === \"\" + expected) {\n            return expected;\n          }\n          return value;\n        }\n      }\n      function setValueForProperty(node, name, value, isCustomComponentTag) {\n        var propertyInfo = getPropertyInfo(name);\n        if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {\n          return;\n        }\n        if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {\n          value = null;\n        }\n        if (isCustomComponentTag || propertyInfo === null) {\n          if (isAttributeNameSafe(name)) {\n            var _attributeName = name;\n            if (value === null) {\n              node.removeAttribute(_attributeName);\n            } else {\n              {\n                checkAttributeStringCoercion(value, name);\n              }\n              node.setAttribute(_attributeName, \"\" + value);\n            }\n          }\n          return;\n        }\n        var mustUseProperty = propertyInfo.mustUseProperty;\n        if (mustUseProperty) {\n          var propertyName = propertyInfo.propertyName;\n          if (value === null) {\n            var type = propertyInfo.type;\n            node[propertyName] = type === BOOLEAN ? false : \"\";\n          } else {\n            node[propertyName] = value;\n          }\n          return;\n        }\n        var { attributeName, attributeNamespace } = propertyInfo;\n        if (value === null) {\n          node.removeAttribute(attributeName);\n        } else {\n          var _type = propertyInfo.type;\n          var attributeValue;\n          if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {\n            attributeValue = \"\";\n          } else {\n            {\n              {\n                checkAttributeStringCoercion(value, attributeName);\n              }\n              attributeValue = \"\" + value;\n            }\n            if (propertyInfo.sanitizeURL) {\n              sanitizeURL(attributeValue.toString());\n            }\n          }\n          if (attributeNamespace) {\n            node.setAttributeNS(attributeNamespace, attributeName, attributeValue);\n          } else {\n            node.setAttribute(attributeName, attributeValue);\n          }\n        }\n      }\n      var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n      var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n      var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n      var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n      var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n      var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n      var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n      var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n      var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n      var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n      var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n      var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n      var REACT_SCOPE_TYPE = Symbol.for(\"react.scope\");\n      var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for(\"react.debug_trace_mode\");\n      var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n      var REACT_LEGACY_HIDDEN_TYPE = Symbol.for(\"react.legacy_hidden\");\n      var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n      var REACT_TRACING_MARKER_TYPE = Symbol.for(\"react.tracing_marker\");\n      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n      var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n      function getIteratorFn(maybeIterable) {\n        if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n          return null;\n        }\n        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n        if (typeof maybeIterator === \"function\") {\n          return maybeIterator;\n        }\n        return null;\n      }\n      var assign = Object.assign;\n      var disabledDepth = 0;\n      var prevLog;\n      var prevInfo;\n      var prevWarn;\n      var prevError;\n      var prevGroup;\n      var prevGroupCollapsed;\n      var prevGroupEnd;\n      function disabledLog() {}\n      disabledLog.__reactDisabledLog = true;\n      function disableLogs() {\n        {\n          if (disabledDepth === 0) {\n            prevLog = console.log;\n            prevInfo = console.info;\n            prevWarn = console.warn;\n            prevError = console.error;\n            prevGroup = console.group;\n            prevGroupCollapsed = console.groupCollapsed;\n            prevGroupEnd = console.groupEnd;\n            var props = {\n              configurable: true,\n              enumerable: true,\n              value: disabledLog,\n              writable: true\n            };\n            Object.defineProperties(console, {\n              info: props,\n              log: props,\n              warn: props,\n              error: props,\n              group: props,\n              groupCollapsed: props,\n              groupEnd: props\n            });\n          }\n          disabledDepth++;\n        }\n      }\n      function reenableLogs() {\n        {\n          disabledDepth--;\n          if (disabledDepth === 0) {\n            var props = {\n              configurable: true,\n              enumerable: true,\n              writable: true\n            };\n            Object.defineProperties(console, {\n              log: assign({}, props, {\n                value: prevLog\n              }),\n              info: assign({}, props, {\n                value: prevInfo\n              }),\n              warn: assign({}, props, {\n                value: prevWarn\n              }),\n              error: assign({}, props, {\n                value: prevError\n              }),\n              group: assign({}, props, {\n                value: prevGroup\n              }),\n              groupCollapsed: assign({}, props, {\n                value: prevGroupCollapsed\n              }),\n              groupEnd: assign({}, props, {\n                value: prevGroupEnd\n              })\n            });\n          }\n          if (disabledDepth < 0) {\n            error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n          }\n        }\n      }\n      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n      var prefix;\n      function describeBuiltInComponentFrame(name, source, ownerFn) {\n        {\n          if (prefix === undefined) {\n            try {\n              throw Error();\n            } catch (x) {\n              var match = x.stack.trim().match(/\\n( *(at )?)/);\n              prefix = match && match[1] || \"\";\n            }\n          }\n          return `\n` + prefix + name;\n        }\n      }\n      var reentry = false;\n      var componentFrameCache;\n      {\n        var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n        componentFrameCache = new PossiblyWeakMap;\n      }\n      function describeNativeComponentFrame(fn, construct) {\n        if (!fn || reentry) {\n          return \"\";\n        }\n        {\n          var frame = componentFrameCache.get(fn);\n          if (frame !== undefined) {\n            return frame;\n          }\n        }\n        var control;\n        reentry = true;\n        var previousPrepareStackTrace = Error.prepareStackTrace;\n        Error.prepareStackTrace = undefined;\n        var previousDispatcher;\n        {\n          previousDispatcher = ReactCurrentDispatcher.current;\n          ReactCurrentDispatcher.current = null;\n          disableLogs();\n        }\n        try {\n          if (construct) {\n            var Fake = function() {\n              throw Error();\n            };\n            Object.defineProperty(Fake.prototype, \"props\", {\n              set: function() {\n                throw Error();\n              }\n            });\n            if (typeof Reflect === \"object\" && Reflect.construct) {\n              try {\n                Reflect.construct(Fake, []);\n              } catch (x) {\n                control = x;\n              }\n              Reflect.construct(fn, [], Fake);\n            } else {\n              try {\n                Fake.call();\n              } catch (x) {\n                control = x;\n              }\n              fn.call(Fake.prototype);\n            }\n          } else {\n            try {\n              throw Error();\n            } catch (x) {\n              control = x;\n            }\n            fn();\n          }\n        } catch (sample) {\n          if (sample && control && typeof sample.stack === \"string\") {\n            var sampleLines = sample.stack.split(`\n`);\n            var controlLines = control.stack.split(`\n`);\n            var s = sampleLines.length - 1;\n            var c = controlLines.length - 1;\n            while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n              c--;\n            }\n            for (;s >= 1 && c >= 0; s--, c--) {\n              if (sampleLines[s] !== controlLines[c]) {\n                if (s !== 1 || c !== 1) {\n                  do {\n                    s--;\n                    c--;\n                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                      var _frame = `\n` + sampleLines[s].replace(\" at new \", \" at \");\n                      if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                        _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                      }\n                      {\n                        if (typeof fn === \"function\") {\n                          componentFrameCache.set(fn, _frame);\n                        }\n                      }\n                      return _frame;\n                    }\n                  } while (s >= 1 && c >= 0);\n                }\n                break;\n              }\n            }\n          }\n        } finally {\n          reentry = false;\n          {\n            ReactCurrentDispatcher.current = previousDispatcher;\n            reenableLogs();\n          }\n          Error.prepareStackTrace = previousPrepareStackTrace;\n        }\n        var name = fn ? fn.displayName || fn.name : \"\";\n        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n        {\n          if (typeof fn === \"function\") {\n            componentFrameCache.set(fn, syntheticFrame);\n          }\n        }\n        return syntheticFrame;\n      }\n      function describeClassComponentFrame(ctor, source, ownerFn) {\n        {\n          return describeNativeComponentFrame(ctor, true);\n        }\n      }\n      function describeFunctionComponentFrame(fn, source, ownerFn) {\n        {\n          return describeNativeComponentFrame(fn, false);\n        }\n      }\n      function shouldConstruct(Component) {\n        var prototype = Component.prototype;\n        return !!(prototype && prototype.isReactComponent);\n      }\n      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n        if (type == null) {\n          return \"\";\n        }\n        if (typeof type === \"function\") {\n          {\n            return describeNativeComponentFrame(type, shouldConstruct(type));\n          }\n        }\n        if (typeof type === \"string\") {\n          return describeBuiltInComponentFrame(type);\n        }\n        switch (type) {\n          case REACT_SUSPENSE_TYPE:\n            return describeBuiltInComponentFrame(\"Suspense\");\n          case REACT_SUSPENSE_LIST_TYPE:\n            return describeBuiltInComponentFrame(\"SuspenseList\");\n        }\n        if (typeof type === \"object\") {\n          switch (type.$$typeof) {\n            case REACT_FORWARD_REF_TYPE:\n              return describeFunctionComponentFrame(type.render);\n            case REACT_MEMO_TYPE:\n              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n            case REACT_LAZY_TYPE: {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n              try {\n                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n              } catch (x) {}\n            }\n          }\n        }\n        return \"\";\n      }\n      function describeFiber(fiber) {\n        var owner = fiber._debugOwner ? fiber._debugOwner.type : null;\n        var source = fiber._debugSource;\n        switch (fiber.tag) {\n          case HostComponent:\n            return describeBuiltInComponentFrame(fiber.type);\n          case LazyComponent:\n            return describeBuiltInComponentFrame(\"Lazy\");\n          case SuspenseComponent:\n            return describeBuiltInComponentFrame(\"Suspense\");\n          case SuspenseListComponent:\n            return describeBuiltInComponentFrame(\"SuspenseList\");\n          case FunctionComponent:\n          case IndeterminateComponent:\n          case SimpleMemoComponent:\n            return describeFunctionComponentFrame(fiber.type);\n          case ForwardRef:\n            return describeFunctionComponentFrame(fiber.type.render);\n          case ClassComponent:\n            return describeClassComponentFrame(fiber.type);\n          default:\n            return \"\";\n        }\n      }\n      function getStackByFiberInDevAndProd(workInProgress2) {\n        try {\n          var info = \"\";\n          var node = workInProgress2;\n          do {\n            info += describeFiber(node);\n            node = node.return;\n          } while (node);\n          return info;\n        } catch (x) {\n          return `\nError generating stack: ` + x.message + `\n` + x.stack;\n        }\n      }\n      function getWrappedName(outerType, innerType, wrapperName) {\n        var displayName = outerType.displayName;\n        if (displayName) {\n          return displayName;\n        }\n        var functionName = innerType.displayName || innerType.name || \"\";\n        return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n      }\n      function getContextName(type) {\n        return type.displayName || \"Context\";\n      }\n      function getComponentNameFromType(type) {\n        if (type == null) {\n          return null;\n        }\n        {\n          if (typeof type.tag === \"number\") {\n            error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n          }\n        }\n        if (typeof type === \"function\") {\n          return type.displayName || type.name || null;\n        }\n        if (typeof type === \"string\") {\n          return type;\n        }\n        switch (type) {\n          case REACT_FRAGMENT_TYPE:\n            return \"Fragment\";\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_PROFILER_TYPE:\n            return \"Profiler\";\n          case REACT_STRICT_MODE_TYPE:\n            return \"StrictMode\";\n          case REACT_SUSPENSE_TYPE:\n            return \"Suspense\";\n          case REACT_SUSPENSE_LIST_TYPE:\n            return \"SuspenseList\";\n        }\n        if (typeof type === \"object\") {\n          switch (type.$$typeof) {\n            case REACT_CONTEXT_TYPE:\n              var context = type;\n              return getContextName(context) + \".Consumer\";\n            case REACT_PROVIDER_TYPE:\n              var provider = type;\n              return getContextName(provider._context) + \".Provider\";\n            case REACT_FORWARD_REF_TYPE:\n              return getWrappedName(type, type.render, \"ForwardRef\");\n            case REACT_MEMO_TYPE:\n              var outerName = type.displayName || null;\n              if (outerName !== null) {\n                return outerName;\n              }\n              return getComponentNameFromType(type.type) || \"Memo\";\n            case REACT_LAZY_TYPE: {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n              try {\n                return getComponentNameFromType(init(payload));\n              } catch (x) {\n                return null;\n              }\n            }\n          }\n        }\n        return null;\n      }\n      function getWrappedName$1(outerType, innerType, wrapperName) {\n        var functionName = innerType.displayName || innerType.name || \"\";\n        return outerType.displayName || (functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName);\n      }\n      function getContextName$1(type) {\n        return type.displayName || \"Context\";\n      }\n      function getComponentNameFromFiber(fiber) {\n        var { tag, type } = fiber;\n        switch (tag) {\n          case CacheComponent:\n            return \"Cache\";\n          case ContextConsumer:\n            var context = type;\n            return getContextName$1(context) + \".Consumer\";\n          case ContextProvider:\n            var provider = type;\n            return getContextName$1(provider._context) + \".Provider\";\n          case DehydratedFragment:\n            return \"DehydratedFragment\";\n          case ForwardRef:\n            return getWrappedName$1(type, type.render, \"ForwardRef\");\n          case Fragment:\n            return \"Fragment\";\n          case HostComponent:\n            return type;\n          case HostPortal:\n            return \"Portal\";\n          case HostRoot:\n            return \"Root\";\n          case HostText:\n            return \"Text\";\n          case LazyComponent:\n            return getComponentNameFromType(type);\n          case Mode:\n            if (type === REACT_STRICT_MODE_TYPE) {\n              return \"StrictMode\";\n            }\n            return \"Mode\";\n          case OffscreenComponent:\n            return \"Offscreen\";\n          case Profiler:\n            return \"Profiler\";\n          case ScopeComponent:\n            return \"Scope\";\n          case SuspenseComponent:\n            return \"Suspense\";\n          case SuspenseListComponent:\n            return \"SuspenseList\";\n          case TracingMarkerComponent:\n            return \"TracingMarker\";\n          case ClassComponent:\n          case FunctionComponent:\n          case IncompleteClassComponent:\n          case IndeterminateComponent:\n          case MemoComponent:\n          case SimpleMemoComponent:\n            if (typeof type === \"function\") {\n              return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n              return type;\n            }\n            break;\n        }\n        return null;\n      }\n      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n      var current = null;\n      var isRendering = false;\n      function getCurrentFiberOwnerNameInDevOrNull() {\n        {\n          if (current === null) {\n            return null;\n          }\n          var owner = current._debugOwner;\n          if (owner !== null && typeof owner !== \"undefined\") {\n            return getComponentNameFromFiber(owner);\n          }\n        }\n        return null;\n      }\n      function getCurrentFiberStackInDev() {\n        {\n          if (current === null) {\n            return \"\";\n          }\n          return getStackByFiberInDevAndProd(current);\n        }\n      }\n      function resetCurrentFiber() {\n        {\n          ReactDebugCurrentFrame.getCurrentStack = null;\n          current = null;\n          isRendering = false;\n        }\n      }\n      function setCurrentFiber(fiber) {\n        {\n          ReactDebugCurrentFrame.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;\n          current = fiber;\n          isRendering = false;\n        }\n      }\n      function getCurrentFiber() {\n        {\n          return current;\n        }\n      }\n      function setIsRendering(rendering) {\n        {\n          isRendering = rendering;\n        }\n      }\n      function toString(value) {\n        return \"\" + value;\n      }\n      function getToStringValue(value) {\n        switch (typeof value) {\n          case \"boolean\":\n          case \"number\":\n          case \"string\":\n          case \"undefined\":\n            return value;\n          case \"object\":\n            {\n              checkFormFieldValueStringCoercion(value);\n            }\n            return value;\n          default:\n            return \"\";\n        }\n      }\n      var hasReadOnlyValue = {\n        button: true,\n        checkbox: true,\n        image: true,\n        hidden: true,\n        radio: true,\n        reset: true,\n        submit: true\n      };\n      function checkControlledValueProps(tagName, props) {\n        {\n          if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {\n            error(\"You provided a `value` prop to a form field without an \" + \"`onChange` handler. This will render a read-only field. If \" + \"the field should be mutable use `defaultValue`. Otherwise, \" + \"set either `onChange` or `readOnly`.\");\n          }\n          if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {\n            error(\"You provided a `checked` prop to a form field without an \" + \"`onChange` handler. This will render a read-only field. If \" + \"the field should be mutable use `defaultChecked`. Otherwise, \" + \"set either `onChange` or `readOnly`.\");\n          }\n        }\n      }\n      function isCheckable(elem) {\n        var type = elem.type;\n        var nodeName = elem.nodeName;\n        return nodeName && nodeName.toLowerCase() === \"input\" && (type === \"checkbox\" || type === \"radio\");\n      }\n      function getTracker(node) {\n        return node._valueTracker;\n      }\n      function detachTracker(node) {\n        node._valueTracker = null;\n      }\n      function getValueFromNode(node) {\n        var value = \"\";\n        if (!node) {\n          return value;\n        }\n        if (isCheckable(node)) {\n          value = node.checked ? \"true\" : \"false\";\n        } else {\n          value = node.value;\n        }\n        return value;\n      }\n      function trackValueOnNode(node) {\n        var valueField = isCheckable(node) ? \"checked\" : \"value\";\n        var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);\n        {\n          checkFormFieldValueStringCoercion(node[valueField]);\n        }\n        var currentValue = \"\" + node[valueField];\n        if (node.hasOwnProperty(valueField) || typeof descriptor === \"undefined\" || typeof descriptor.get !== \"function\" || typeof descriptor.set !== \"function\") {\n          return;\n        }\n        var { get: get2, set: set2 } = descriptor;\n        Object.defineProperty(node, valueField, {\n          configurable: true,\n          get: function() {\n            return get2.call(this);\n          },\n          set: function(value) {\n            {\n              checkFormFieldValueStringCoercion(value);\n            }\n            currentValue = \"\" + value;\n            set2.call(this, value);\n          }\n        });\n        Object.defineProperty(node, valueField, {\n          enumerable: descriptor.enumerable\n        });\n        var tracker = {\n          getValue: function() {\n            return currentValue;\n          },\n          setValue: function(value) {\n            {\n              checkFormFieldValueStringCoercion(value);\n            }\n            currentValue = \"\" + value;\n          },\n          stopTracking: function() {\n            detachTracker(node);\n            delete node[valueField];\n          }\n        };\n        return tracker;\n      }\n      function track(node) {\n        if (getTracker(node)) {\n          return;\n        }\n        node._valueTracker = trackValueOnNode(node);\n      }\n      function updateValueIfChanged(node) {\n        if (!node) {\n          return false;\n        }\n        var tracker = getTracker(node);\n        if (!tracker) {\n          return true;\n        }\n        var lastValue = tracker.getValue();\n        var nextValue = getValueFromNode(node);\n        if (nextValue !== lastValue) {\n          tracker.setValue(nextValue);\n          return true;\n        }\n        return false;\n      }\n      function getActiveElement(doc) {\n        doc = doc || (typeof document !== \"undefined\" ? document : undefined);\n        if (typeof doc === \"undefined\") {\n          return null;\n        }\n        try {\n          return doc.activeElement || doc.body;\n        } catch (e) {\n          return doc.body;\n        }\n      }\n      var didWarnValueDefaultValue = false;\n      var didWarnCheckedDefaultChecked = false;\n      var didWarnControlledToUncontrolled = false;\n      var didWarnUncontrolledToControlled = false;\n      function isControlled(props) {\n        var usesChecked = props.type === \"checkbox\" || props.type === \"radio\";\n        return usesChecked ? props.checked != null : props.value != null;\n      }\n      function getHostProps(element, props) {\n        var node = element;\n        var checked = props.checked;\n        var hostProps = assign({}, props, {\n          defaultChecked: undefined,\n          defaultValue: undefined,\n          value: undefined,\n          checked: checked != null ? checked : node._wrapperState.initialChecked\n        });\n        return hostProps;\n      }\n      function initWrapperState(element, props) {\n        {\n          checkControlledValueProps(\"input\", props);\n          if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {\n            error(\"%s contains an input of type %s with both checked and defaultChecked props. \" + \"Input elements must be either controlled or uncontrolled \" + \"(specify either the checked prop, or the defaultChecked prop, but not \" + \"both). Decide between using a controlled or uncontrolled input \" + \"element and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\", getCurrentFiberOwnerNameInDevOrNull() || \"A component\", props.type);\n            didWarnCheckedDefaultChecked = true;\n          }\n          if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {\n            error(\"%s contains an input of type %s with both value and defaultValue props. \" + \"Input elements must be either controlled or uncontrolled \" + \"(specify either the value prop, or the defaultValue prop, but not \" + \"both). Decide between using a controlled or uncontrolled input \" + \"element and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\", getCurrentFiberOwnerNameInDevOrNull() || \"A component\", props.type);\n            didWarnValueDefaultValue = true;\n          }\n        }\n        var node = element;\n        var defaultValue = props.defaultValue == null ? \"\" : props.defaultValue;\n        node._wrapperState = {\n          initialChecked: props.checked != null ? props.checked : props.defaultChecked,\n          initialValue: getToStringValue(props.value != null ? props.value : defaultValue),\n          controlled: isControlled(props)\n        };\n      }\n      function updateChecked(element, props) {\n        var node = element;\n        var checked = props.checked;\n        if (checked != null) {\n          setValueForProperty(node, \"checked\", checked, false);\n        }\n      }\n      function updateWrapper(element, props) {\n        var node = element;\n        {\n          var controlled = isControlled(props);\n          if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {\n            error(\"A component is changing an uncontrolled input to be controlled. \" + \"This is likely caused by the value changing from undefined to \" + \"a defined value, which should not happen. \" + \"Decide between using a controlled or uncontrolled input \" + \"element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components\");\n            didWarnUncontrolledToControlled = true;\n          }\n          if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {\n            error(\"A component is changing a controlled input to be uncontrolled. \" + \"This is likely caused by the value changing from a defined to \" + \"undefined, which should not happen. \" + \"Decide between using a controlled or uncontrolled input \" + \"element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components\");\n            didWarnControlledToUncontrolled = true;\n          }\n        }\n        updateChecked(element, props);\n        var value = getToStringValue(props.value);\n        var type = props.type;\n        if (value != null) {\n          if (type === \"number\") {\n            if (value === 0 && node.value === \"\" || node.value != value) {\n              node.value = toString(value);\n            }\n          } else if (node.value !== toString(value)) {\n            node.value = toString(value);\n          }\n        } else if (type === \"submit\" || type === \"reset\") {\n          node.removeAttribute(\"value\");\n          return;\n        }\n        {\n          if (props.hasOwnProperty(\"value\")) {\n            setDefaultValue(node, props.type, value);\n          } else if (props.hasOwnProperty(\"defaultValue\")) {\n            setDefaultValue(node, props.type, getToStringValue(props.defaultValue));\n          }\n        }\n        {\n          if (props.checked == null && props.defaultChecked != null) {\n            node.defaultChecked = !!props.defaultChecked;\n          }\n        }\n      }\n      function postMountWrapper(element, props, isHydrating2) {\n        var node = element;\n        if (props.hasOwnProperty(\"value\") || props.hasOwnProperty(\"defaultValue\")) {\n          var type = props.type;\n          var isButton = type === \"submit\" || type === \"reset\";\n          if (isButton && (props.value === undefined || props.value === null)) {\n            return;\n          }\n          var initialValue = toString(node._wrapperState.initialValue);\n          if (!isHydrating2) {\n            {\n              if (initialValue !== node.value) {\n                node.value = initialValue;\n              }\n            }\n          }\n          {\n            node.defaultValue = initialValue;\n          }\n        }\n        var name = node.name;\n        if (name !== \"\") {\n          node.name = \"\";\n        }\n        {\n          node.defaultChecked = !node.defaultChecked;\n          node.defaultChecked = !!node._wrapperState.initialChecked;\n        }\n        if (name !== \"\") {\n          node.name = name;\n        }\n      }\n      function restoreControlledState(element, props) {\n        var node = element;\n        updateWrapper(node, props);\n        updateNamedCousins(node, props);\n      }\n      function updateNamedCousins(rootNode, props) {\n        var name = props.name;\n        if (props.type === \"radio\" && name != null) {\n          var queryRoot = rootNode;\n          while (queryRoot.parentNode) {\n            queryRoot = queryRoot.parentNode;\n          }\n          {\n            checkAttributeStringCoercion(name, \"name\");\n          }\n          var group = queryRoot.querySelectorAll(\"input[name=\" + JSON.stringify(\"\" + name) + '][type=\"radio\"]');\n          for (var i = 0;i < group.length; i++) {\n            var otherNode = group[i];\n            if (otherNode === rootNode || otherNode.form !== rootNode.form) {\n              continue;\n            }\n            var otherProps = getFiberCurrentPropsFromNode(otherNode);\n            if (!otherProps) {\n              throw new Error(\"ReactDOMInput: Mixing React and non-React radio inputs with the \" + \"same `name` is not supported.\");\n            }\n            updateValueIfChanged(otherNode);\n            updateWrapper(otherNode, otherProps);\n          }\n        }\n      }\n      function setDefaultValue(node, type, value) {\n        if (type !== \"number\" || getActiveElement(node.ownerDocument) !== node) {\n          if (value == null) {\n            node.defaultValue = toString(node._wrapperState.initialValue);\n          } else if (node.defaultValue !== toString(value)) {\n            node.defaultValue = toString(value);\n          }\n        }\n      }\n      var didWarnSelectedSetOnOption = false;\n      var didWarnInvalidChild = false;\n      var didWarnInvalidInnerHTML = false;\n      function validateProps(element, props) {\n        {\n          if (props.value == null) {\n            if (typeof props.children === \"object\" && props.children !== null) {\n              React.Children.forEach(props.children, function(child) {\n                if (child == null) {\n                  return;\n                }\n                if (typeof child === \"string\" || typeof child === \"number\") {\n                  return;\n                }\n                if (!didWarnInvalidChild) {\n                  didWarnInvalidChild = true;\n                  error(\"Cannot infer the option value of complex children. \" + \"Pass a `value` prop or use a plain string as children to <option>.\");\n                }\n              });\n            } else if (props.dangerouslySetInnerHTML != null) {\n              if (!didWarnInvalidInnerHTML) {\n                didWarnInvalidInnerHTML = true;\n                error(\"Pass a `value` prop if you set dangerouslyInnerHTML so React knows \" + \"which value should be selected.\");\n              }\n            }\n          }\n          if (props.selected != null && !didWarnSelectedSetOnOption) {\n            error(\"Use the `defaultValue` or `value` props on <select> instead of \" + \"setting `selected` on <option>.\");\n            didWarnSelectedSetOnOption = true;\n          }\n        }\n      }\n      function postMountWrapper$1(element, props) {\n        if (props.value != null) {\n          element.setAttribute(\"value\", toString(getToStringValue(props.value)));\n        }\n      }\n      var isArrayImpl = Array.isArray;\n      function isArray(a) {\n        return isArrayImpl(a);\n      }\n      var didWarnValueDefaultValue$1;\n      {\n        didWarnValueDefaultValue$1 = false;\n      }\n      function getDeclarationErrorAddendum() {\n        var ownerName = getCurrentFiberOwnerNameInDevOrNull();\n        if (ownerName) {\n          return `\n\nCheck the render method of \\`` + ownerName + \"`.\";\n        }\n        return \"\";\n      }\n      var valuePropNames = [\"value\", \"defaultValue\"];\n      function checkSelectPropTypes(props) {\n        {\n          checkControlledValueProps(\"select\", props);\n          for (var i = 0;i < valuePropNames.length; i++) {\n            var propName = valuePropNames[i];\n            if (props[propName] == null) {\n              continue;\n            }\n            var propNameIsArray = isArray(props[propName]);\n            if (props.multiple && !propNameIsArray) {\n              error(\"The `%s` prop supplied to <select> must be an array if \" + \"`multiple` is true.%s\", propName, getDeclarationErrorAddendum());\n            } else if (!props.multiple && propNameIsArray) {\n              error(\"The `%s` prop supplied to <select> must be a scalar \" + \"value if `multiple` is false.%s\", propName, getDeclarationErrorAddendum());\n            }\n          }\n        }\n      }\n      function updateOptions(node, multiple, propValue, setDefaultSelected) {\n        var options2 = node.options;\n        if (multiple) {\n          var selectedValues = propValue;\n          var selectedValue = {};\n          for (var i = 0;i < selectedValues.length; i++) {\n            selectedValue[\"$\" + selectedValues[i]] = true;\n          }\n          for (var _i = 0;_i < options2.length; _i++) {\n            var selected = selectedValue.hasOwnProperty(\"$\" + options2[_i].value);\n            if (options2[_i].selected !== selected) {\n              options2[_i].selected = selected;\n            }\n            if (selected && setDefaultSelected) {\n              options2[_i].defaultSelected = true;\n            }\n          }\n        } else {\n          var _selectedValue = toString(getToStringValue(propValue));\n          var defaultSelected = null;\n          for (var _i2 = 0;_i2 < options2.length; _i2++) {\n            if (options2[_i2].value === _selectedValue) {\n              options2[_i2].selected = true;\n              if (setDefaultSelected) {\n                options2[_i2].defaultSelected = true;\n              }\n              return;\n            }\n            if (defaultSelected === null && !options2[_i2].disabled) {\n              defaultSelected = options2[_i2];\n            }\n          }\n          if (defaultSelected !== null) {\n            defaultSelected.selected = true;\n          }\n        }\n      }\n      function getHostProps$1(element, props) {\n        return assign({}, props, {\n          value: undefined\n        });\n      }\n      function initWrapperState$1(element, props) {\n        var node = element;\n        {\n          checkSelectPropTypes(props);\n        }\n        node._wrapperState = {\n          wasMultiple: !!props.multiple\n        };\n        {\n          if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {\n            error(\"Select elements must be either controlled or uncontrolled \" + \"(specify either the value prop, or the defaultValue prop, but not \" + \"both). Decide between using a controlled or uncontrolled select \" + \"element and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\");\n            didWarnValueDefaultValue$1 = true;\n          }\n        }\n      }\n      function postMountWrapper$2(element, props) {\n        var node = element;\n        node.multiple = !!props.multiple;\n        var value = props.value;\n        if (value != null) {\n          updateOptions(node, !!props.multiple, value, false);\n        } else if (props.defaultValue != null) {\n          updateOptions(node, !!props.multiple, props.defaultValue, true);\n        }\n      }\n      function postUpdateWrapper(element, props) {\n        var node = element;\n        var wasMultiple = node._wrapperState.wasMultiple;\n        node._wrapperState.wasMultiple = !!props.multiple;\n        var value = props.value;\n        if (value != null) {\n          updateOptions(node, !!props.multiple, value, false);\n        } else if (wasMultiple !== !!props.multiple) {\n          if (props.defaultValue != null) {\n            updateOptions(node, !!props.multiple, props.defaultValue, true);\n          } else {\n            updateOptions(node, !!props.multiple, props.multiple ? [] : \"\", false);\n          }\n        }\n      }\n      function restoreControlledState$1(element, props) {\n        var node = element;\n        var value = props.value;\n        if (value != null) {\n          updateOptions(node, !!props.multiple, value, false);\n        }\n      }\n      var didWarnValDefaultVal = false;\n      function getHostProps$2(element, props) {\n        var node = element;\n        if (props.dangerouslySetInnerHTML != null) {\n          throw new Error(\"`dangerouslySetInnerHTML` does not make sense on <textarea>.\");\n        }\n        var hostProps = assign({}, props, {\n          value: undefined,\n          defaultValue: undefined,\n          children: toString(node._wrapperState.initialValue)\n        });\n        return hostProps;\n      }\n      function initWrapperState$2(element, props) {\n        var node = element;\n        {\n          checkControlledValueProps(\"textarea\", props);\n          if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {\n            error(\"%s contains a textarea with both value and defaultValue props. \" + \"Textarea elements must be either controlled or uncontrolled \" + \"(specify either the value prop, or the defaultValue prop, but not \" + \"both). Decide between using a controlled or uncontrolled textarea \" + \"and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\", getCurrentFiberOwnerNameInDevOrNull() || \"A component\");\n            didWarnValDefaultVal = true;\n          }\n        }\n        var initialValue = props.value;\n        if (initialValue == null) {\n          var { children, defaultValue } = props;\n          if (children != null) {\n            {\n              error(\"Use the `defaultValue` or `value` props instead of setting \" + \"children on <textarea>.\");\n            }\n            {\n              if (defaultValue != null) {\n                throw new Error(\"If you supply `defaultValue` on a <textarea>, do not pass children.\");\n              }\n              if (isArray(children)) {\n                if (children.length > 1) {\n                  throw new Error(\"<textarea> can only have at most one child.\");\n                }\n                children = children[0];\n              }\n              defaultValue = children;\n            }\n          }\n          if (defaultValue == null) {\n            defaultValue = \"\";\n          }\n          initialValue = defaultValue;\n        }\n        node._wrapperState = {\n          initialValue: getToStringValue(initialValue)\n        };\n      }\n      function updateWrapper$1(element, props) {\n        var node = element;\n        var value = getToStringValue(props.value);\n        var defaultValue = getToStringValue(props.defaultValue);\n        if (value != null) {\n          var newValue = toString(value);\n          if (newValue !== node.value) {\n            node.value = newValue;\n          }\n          if (props.defaultValue == null && node.defaultValue !== newValue) {\n            node.defaultValue = newValue;\n          }\n        }\n        if (defaultValue != null) {\n          node.defaultValue = toString(defaultValue);\n        }\n      }\n      function postMountWrapper$3(element, props) {\n        var node = element;\n        var textContent = node.textContent;\n        if (textContent === node._wrapperState.initialValue) {\n          if (textContent !== \"\" && textContent !== null) {\n            node.value = textContent;\n          }\n        }\n      }\n      function restoreControlledState$2(element, props) {\n        updateWrapper$1(element, props);\n      }\n      var HTML_NAMESPACE = \"http://www.w3.org/1999/xhtml\";\n      var MATH_NAMESPACE = \"http://www.w3.org/1998/Math/MathML\";\n      var SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\n      function getIntrinsicNamespace(type) {\n        switch (type) {\n          case \"svg\":\n            return SVG_NAMESPACE;\n          case \"math\":\n            return MATH_NAMESPACE;\n          default:\n            return HTML_NAMESPACE;\n        }\n      }\n      function getChildNamespace(parentNamespace, type) {\n        if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {\n          return getIntrinsicNamespace(type);\n        }\n        if (parentNamespace === SVG_NAMESPACE && type === \"foreignObject\") {\n          return HTML_NAMESPACE;\n        }\n        return parentNamespace;\n      }\n      var createMicrosoftUnsafeLocalFunction = function(func) {\n        if (typeof MSApp !== \"undefined\" && MSApp.execUnsafeLocalFunction) {\n          return function(arg0, arg1, arg2, arg3) {\n            MSApp.execUnsafeLocalFunction(function() {\n              return func(arg0, arg1, arg2, arg3);\n            });\n          };\n        } else {\n          return func;\n        }\n      };\n      var reusableSVGContainer;\n      var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node, html) {\n        if (node.namespaceURI === SVG_NAMESPACE) {\n          if (!(\"innerHTML\" in node)) {\n            reusableSVGContainer = reusableSVGContainer || document.createElement(\"div\");\n            reusableSVGContainer.innerHTML = \"<svg>\" + html.valueOf().toString() + \"</svg>\";\n            var svgNode = reusableSVGContainer.firstChild;\n            while (node.firstChild) {\n              node.removeChild(node.firstChild);\n            }\n            while (svgNode.firstChild) {\n              node.appendChild(svgNode.firstChild);\n            }\n            return;\n          }\n        }\n        node.innerHTML = html;\n      });\n      var ELEMENT_NODE = 1;\n      var TEXT_NODE = 3;\n      var COMMENT_NODE = 8;\n      var DOCUMENT_NODE = 9;\n      var DOCUMENT_FRAGMENT_NODE = 11;\n      var setTextContent = function(node, text) {\n        if (text) {\n          var firstChild = node.firstChild;\n          if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {\n            firstChild.nodeValue = text;\n            return;\n          }\n        }\n        node.textContent = text;\n      };\n      var shorthandToLonghand = {\n        animation: [\"animationDelay\", \"animationDirection\", \"animationDuration\", \"animationFillMode\", \"animationIterationCount\", \"animationName\", \"animationPlayState\", \"animationTimingFunction\"],\n        background: [\"backgroundAttachment\", \"backgroundClip\", \"backgroundColor\", \"backgroundImage\", \"backgroundOrigin\", \"backgroundPositionX\", \"backgroundPositionY\", \"backgroundRepeat\", \"backgroundSize\"],\n        backgroundPosition: [\"backgroundPositionX\", \"backgroundPositionY\"],\n        border: [\"borderBottomColor\", \"borderBottomStyle\", \"borderBottomWidth\", \"borderImageOutset\", \"borderImageRepeat\", \"borderImageSlice\", \"borderImageSource\", \"borderImageWidth\", \"borderLeftColor\", \"borderLeftStyle\", \"borderLeftWidth\", \"borderRightColor\", \"borderRightStyle\", \"borderRightWidth\", \"borderTopColor\", \"borderTopStyle\", \"borderTopWidth\"],\n        borderBlockEnd: [\"borderBlockEndColor\", \"borderBlockEndStyle\", \"borderBlockEndWidth\"],\n        borderBlockStart: [\"borderBlockStartColor\", \"borderBlockStartStyle\", \"borderBlockStartWidth\"],\n        borderBottom: [\"borderBottomColor\", \"borderBottomStyle\", \"borderBottomWidth\"],\n        borderColor: [\"borderBottomColor\", \"borderLeftColor\", \"borderRightColor\", \"borderTopColor\"],\n        borderImage: [\"borderImageOutset\", \"borderImageRepeat\", \"borderImageSlice\", \"borderImageSource\", \"borderImageWidth\"],\n        borderInlineEnd: [\"borderInlineEndColor\", \"borderInlineEndStyle\", \"borderInlineEndWidth\"],\n        borderInlineStart: [\"borderInlineStartColor\", \"borderInlineStartStyle\", \"borderInlineStartWidth\"],\n        borderLeft: [\"borderLeftColor\", \"borderLeftStyle\", \"borderLeftWidth\"],\n        borderRadius: [\"borderBottomLeftRadius\", \"borderBottomRightRadius\", \"borderTopLeftRadius\", \"borderTopRightRadius\"],\n        borderRight: [\"borderRightColor\", \"borderRightStyle\", \"borderRightWidth\"],\n        borderStyle: [\"borderBottomStyle\", \"borderLeftStyle\", \"borderRightStyle\", \"borderTopStyle\"],\n        borderTop: [\"borderTopColor\", \"borderTopStyle\", \"borderTopWidth\"],\n        borderWidth: [\"borderBottomWidth\", \"borderLeftWidth\", \"borderRightWidth\", \"borderTopWidth\"],\n        columnRule: [\"columnRuleColor\", \"columnRuleStyle\", \"columnRuleWidth\"],\n        columns: [\"columnCount\", \"columnWidth\"],\n        flex: [\"flexBasis\", \"flexGrow\", \"flexShrink\"],\n        flexFlow: [\"flexDirection\", \"flexWrap\"],\n        font: [\"fontFamily\", \"fontFeatureSettings\", \"fontKerning\", \"fontLanguageOverride\", \"fontSize\", \"fontSizeAdjust\", \"fontStretch\", \"fontStyle\", \"fontVariant\", \"fontVariantAlternates\", \"fontVariantCaps\", \"fontVariantEastAsian\", \"fontVariantLigatures\", \"fontVariantNumeric\", \"fontVariantPosition\", \"fontWeight\", \"lineHeight\"],\n        fontVariant: [\"fontVariantAlternates\", \"fontVariantCaps\", \"fontVariantEastAsian\", \"fontVariantLigatures\", \"fontVariantNumeric\", \"fontVariantPosition\"],\n        gap: [\"columnGap\", \"rowGap\"],\n        grid: [\"gridAutoColumns\", \"gridAutoFlow\", \"gridAutoRows\", \"gridTemplateAreas\", \"gridTemplateColumns\", \"gridTemplateRows\"],\n        gridArea: [\"gridColumnEnd\", \"gridColumnStart\", \"gridRowEnd\", \"gridRowStart\"],\n        gridColumn: [\"gridColumnEnd\", \"gridColumnStart\"],\n        gridColumnGap: [\"columnGap\"],\n        gridGap: [\"columnGap\", \"rowGap\"],\n        gridRow: [\"gridRowEnd\", \"gridRowStart\"],\n        gridRowGap: [\"rowGap\"],\n        gridTemplate: [\"gridTemplateAreas\", \"gridTemplateColumns\", \"gridTemplateRows\"],\n        listStyle: [\"listStyleImage\", \"listStylePosition\", \"listStyleType\"],\n        margin: [\"marginBottom\", \"marginLeft\", \"marginRight\", \"marginTop\"],\n        marker: [\"markerEnd\", \"markerMid\", \"markerStart\"],\n        mask: [\"maskClip\", \"maskComposite\", \"maskImage\", \"maskMode\", \"maskOrigin\", \"maskPositionX\", \"maskPositionY\", \"maskRepeat\", \"maskSize\"],\n        maskPosition: [\"maskPositionX\", \"maskPositionY\"],\n        outline: [\"outlineColor\", \"outlineStyle\", \"outlineWidth\"],\n        overflow: [\"overflowX\", \"overflowY\"],\n        padding: [\"paddingBottom\", \"paddingLeft\", \"paddingRight\", \"paddingTop\"],\n        placeContent: [\"alignContent\", \"justifyContent\"],\n        placeItems: [\"alignItems\", \"justifyItems\"],\n        placeSelf: [\"alignSelf\", \"justifySelf\"],\n        textDecoration: [\"textDecorationColor\", \"textDecorationLine\", \"textDecorationStyle\"],\n        textEmphasis: [\"textEmphasisColor\", \"textEmphasisStyle\"],\n        transition: [\"transitionDelay\", \"transitionDuration\", \"transitionProperty\", \"transitionTimingFunction\"],\n        wordWrap: [\"overflowWrap\"]\n      };\n      var isUnitlessNumber = {\n        animationIterationCount: true,\n        aspectRatio: true,\n        borderImageOutset: true,\n        borderImageSlice: true,\n        borderImageWidth: true,\n        boxFlex: true,\n        boxFlexGroup: true,\n        boxOrdinalGroup: true,\n        columnCount: true,\n        columns: true,\n        flex: true,\n        flexGrow: true,\n        flexPositive: true,\n        flexShrink: true,\n        flexNegative: true,\n        flexOrder: true,\n        gridArea: true,\n        gridRow: true,\n        gridRowEnd: true,\n        gridRowSpan: true,\n        gridRowStart: true,\n        gridColumn: true,\n        gridColumnEnd: true,\n        gridColumnSpan: true,\n        gridColumnStart: true,\n        fontWeight: true,\n        lineClamp: true,\n        lineHeight: true,\n        opacity: true,\n        order: true,\n        orphans: true,\n        tabSize: true,\n        widows: true,\n        zIndex: true,\n        zoom: true,\n        fillOpacity: true,\n        floodOpacity: true,\n        stopOpacity: true,\n        strokeDasharray: true,\n        strokeDashoffset: true,\n        strokeMiterlimit: true,\n        strokeOpacity: true,\n        strokeWidth: true\n      };\n      function prefixKey(prefix2, key) {\n        return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);\n      }\n      var prefixes = [\"Webkit\", \"ms\", \"Moz\", \"O\"];\n      Object.keys(isUnitlessNumber).forEach(function(prop) {\n        prefixes.forEach(function(prefix2) {\n          isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];\n        });\n      });\n      function dangerousStyleValue(name, value, isCustomProperty) {\n        var isEmpty2 = value == null || typeof value === \"boolean\" || value === \"\";\n        if (isEmpty2) {\n          return \"\";\n        }\n        if (!isCustomProperty && typeof value === \"number\" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {\n          return value + \"px\";\n        }\n        {\n          checkCSSPropertyStringCoercion(value, name);\n        }\n        return (\"\" + value).trim();\n      }\n      var uppercasePattern = /([A-Z])/g;\n      var msPattern = /^ms-/;\n      function hyphenateStyleName(name) {\n        return name.replace(uppercasePattern, \"-$1\").toLowerCase().replace(msPattern, \"-ms-\");\n      }\n      var warnValidStyle = function() {};\n      {\n        var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;\n        var msPattern$1 = /^-ms-/;\n        var hyphenPattern = /-(.)/g;\n        var badStyleValueWithSemicolonPattern = /;\\s*$/;\n        var warnedStyleNames = {};\n        var warnedStyleValues = {};\n        var warnedForNaNValue = false;\n        var warnedForInfinityValue = false;\n        var camelize = function(string) {\n          return string.replace(hyphenPattern, function(_, character) {\n            return character.toUpperCase();\n          });\n        };\n        var warnHyphenatedStyleName = function(name) {\n          if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n            return;\n          }\n          warnedStyleNames[name] = true;\n          error(\"Unsupported style property %s. Did you mean %s?\", name, camelize(name.replace(msPattern$1, \"ms-\")));\n        };\n        var warnBadVendoredStyleName = function(name) {\n          if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n            return;\n          }\n          warnedStyleNames[name] = true;\n          error(\"Unsupported vendor-prefixed style property %s. Did you mean %s?\", name, name.charAt(0).toUpperCase() + name.slice(1));\n        };\n        var warnStyleValueWithSemicolon = function(name, value) {\n          if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {\n            return;\n          }\n          warnedStyleValues[value] = true;\n          error(\"Style property values shouldn't contain a semicolon. \" + 'Try \"%s: %s\" instead.', name, value.replace(badStyleValueWithSemicolonPattern, \"\"));\n        };\n        var warnStyleValueIsNaN = function(name, value) {\n          if (warnedForNaNValue) {\n            return;\n          }\n          warnedForNaNValue = true;\n          error(\"`NaN` is an invalid value for the `%s` css style property.\", name);\n        };\n        var warnStyleValueIsInfinity = function(name, value) {\n          if (warnedForInfinityValue) {\n            return;\n          }\n          warnedForInfinityValue = true;\n          error(\"`Infinity` is an invalid value for the `%s` css style property.\", name);\n        };\n        warnValidStyle = function(name, value) {\n          if (name.indexOf(\"-\") > -1) {\n            warnHyphenatedStyleName(name);\n          } else if (badVendoredStyleNamePattern.test(name)) {\n            warnBadVendoredStyleName(name);\n          } else if (badStyleValueWithSemicolonPattern.test(value)) {\n            warnStyleValueWithSemicolon(name, value);\n          }\n          if (typeof value === \"number\") {\n            if (isNaN(value)) {\n              warnStyleValueIsNaN(name, value);\n            } else if (!isFinite(value)) {\n              warnStyleValueIsInfinity(name, value);\n            }\n          }\n        };\n      }\n      var warnValidStyle$1 = warnValidStyle;\n      function createDangerousStringForStyles(styles) {\n        {\n          var serialized = \"\";\n          var delimiter = \"\";\n          for (var styleName in styles) {\n            if (!styles.hasOwnProperty(styleName)) {\n              continue;\n            }\n            var styleValue = styles[styleName];\n            if (styleValue != null) {\n              var isCustomProperty = styleName.indexOf(\"--\") === 0;\n              serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + \":\";\n              serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);\n              delimiter = \";\";\n            }\n          }\n          return serialized || null;\n        }\n      }\n      function setValueForStyles(node, styles) {\n        var style2 = node.style;\n        for (var styleName in styles) {\n          if (!styles.hasOwnProperty(styleName)) {\n            continue;\n          }\n          var isCustomProperty = styleName.indexOf(\"--\") === 0;\n          {\n            if (!isCustomProperty) {\n              warnValidStyle$1(styleName, styles[styleName]);\n            }\n          }\n          var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);\n          if (styleName === \"float\") {\n            styleName = \"cssFloat\";\n          }\n          if (isCustomProperty) {\n            style2.setProperty(styleName, styleValue);\n          } else {\n            style2[styleName] = styleValue;\n          }\n        }\n      }\n      function isValueEmpty(value) {\n        return value == null || typeof value === \"boolean\" || value === \"\";\n      }\n      function expandShorthandMap(styles) {\n        var expanded = {};\n        for (var key in styles) {\n          var longhands = shorthandToLonghand[key] || [key];\n          for (var i = 0;i < longhands.length; i++) {\n            expanded[longhands[i]] = key;\n          }\n        }\n        return expanded;\n      }\n      function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {\n        {\n          if (!nextStyles) {\n            return;\n          }\n          var expandedUpdates = expandShorthandMap(styleUpdates);\n          var expandedStyles = expandShorthandMap(nextStyles);\n          var warnedAbout = {};\n          for (var key in expandedUpdates) {\n            var originalKey = expandedUpdates[key];\n            var correctOriginalKey = expandedStyles[key];\n            if (correctOriginalKey && originalKey !== correctOriginalKey) {\n              var warningKey = originalKey + \",\" + correctOriginalKey;\n              if (warnedAbout[warningKey]) {\n                continue;\n              }\n              warnedAbout[warningKey] = true;\n              error(\"%s a style property during rerender (%s) when a \" + \"conflicting property is set (%s) can lead to styling bugs. To \" + \"avoid this, don't mix shorthand and non-shorthand properties \" + \"for the same value; instead, replace the shorthand with \" + \"separate values.\", isValueEmpty(styleUpdates[originalKey]) ? \"Removing\" : \"Updating\", originalKey, correctOriginalKey);\n            }\n          }\n        }\n      }\n      var omittedCloseTags = {\n        area: true,\n        base: true,\n        br: true,\n        col: true,\n        embed: true,\n        hr: true,\n        img: true,\n        input: true,\n        keygen: true,\n        link: true,\n        meta: true,\n        param: true,\n        source: true,\n        track: true,\n        wbr: true\n      };\n      var voidElementTags = assign({\n        menuitem: true\n      }, omittedCloseTags);\n      var HTML = \"__html\";\n      function assertValidProps(tag, props) {\n        if (!props) {\n          return;\n        }\n        if (voidElementTags[tag]) {\n          if (props.children != null || props.dangerouslySetInnerHTML != null) {\n            throw new Error(tag + \" is a void element tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n          }\n        }\n        if (props.dangerouslySetInnerHTML != null) {\n          if (props.children != null) {\n            throw new Error(\"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\");\n          }\n          if (typeof props.dangerouslySetInnerHTML !== \"object\" || !(HTML in props.dangerouslySetInnerHTML)) {\n            throw new Error(\"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. \" + \"Please visit https://reactjs.org/link/dangerously-set-inner-html \" + \"for more information.\");\n          }\n        }\n        {\n          if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {\n            error(\"A component is `contentEditable` and contains `children` managed by \" + \"React. It is now your responsibility to guarantee that none of \" + \"those nodes are unexpectedly modified or duplicated. This is \" + \"probably not intentional.\");\n          }\n        }\n        if (props.style != null && typeof props.style !== \"object\") {\n          throw new Error(\"The `style` prop expects a mapping from style properties to values, \" + \"not a string. For example, style={{marginRight: spacing + 'em'}} when \" + \"using JSX.\");\n        }\n      }\n      function isCustomComponent(tagName, props) {\n        if (tagName.indexOf(\"-\") === -1) {\n          return typeof props.is === \"string\";\n        }\n        switch (tagName) {\n          case \"annotation-xml\":\n          case \"color-profile\":\n          case \"font-face\":\n          case \"font-face-src\":\n          case \"font-face-uri\":\n          case \"font-face-format\":\n          case \"font-face-name\":\n          case \"missing-glyph\":\n            return false;\n          default:\n            return true;\n        }\n      }\n      var possibleStandardNames = {\n        accept: \"accept\",\n        acceptcharset: \"acceptCharset\",\n        \"accept-charset\": \"acceptCharset\",\n        accesskey: \"accessKey\",\n        action: \"action\",\n        allowfullscreen: \"allowFullScreen\",\n        alt: \"alt\",\n        as: \"as\",\n        async: \"async\",\n        autocapitalize: \"autoCapitalize\",\n        autocomplete: \"autoComplete\",\n        autocorrect: \"autoCorrect\",\n        autofocus: \"autoFocus\",\n        autoplay: \"autoPlay\",\n        autosave: \"autoSave\",\n        capture: \"capture\",\n        cellpadding: \"cellPadding\",\n        cellspacing: \"cellSpacing\",\n        challenge: \"challenge\",\n        charset: \"charSet\",\n        checked: \"checked\",\n        children: \"children\",\n        cite: \"cite\",\n        class: \"className\",\n        classid: \"classID\",\n        classname: \"className\",\n        cols: \"cols\",\n        colspan: \"colSpan\",\n        content: \"content\",\n        contenteditable: \"contentEditable\",\n        contextmenu: \"contextMenu\",\n        controls: \"controls\",\n        controlslist: \"controlsList\",\n        coords: \"coords\",\n        crossorigin: \"crossOrigin\",\n        dangerouslysetinnerhtml: \"dangerouslySetInnerHTML\",\n        data: \"data\",\n        datetime: \"dateTime\",\n        default: \"default\",\n        defaultchecked: \"defaultChecked\",\n        defaultvalue: \"defaultValue\",\n        defer: \"defer\",\n        dir: \"dir\",\n        disabled: \"disabled\",\n        disablepictureinpicture: \"disablePictureInPicture\",\n        disableremoteplayback: \"disableRemotePlayback\",\n        download: \"download\",\n        draggable: \"draggable\",\n        enctype: \"encType\",\n        enterkeyhint: \"enterKeyHint\",\n        for: \"htmlFor\",\n        form: \"form\",\n        formmethod: \"formMethod\",\n        formaction: \"formAction\",\n        formenctype: \"formEncType\",\n        formnovalidate: \"formNoValidate\",\n        formtarget: \"formTarget\",\n        frameborder: \"frameBorder\",\n        headers: \"headers\",\n        height: \"height\",\n        hidden: \"hidden\",\n        high: \"high\",\n        href: \"href\",\n        hreflang: \"hrefLang\",\n        htmlfor: \"htmlFor\",\n        httpequiv: \"httpEquiv\",\n        \"http-equiv\": \"httpEquiv\",\n        icon: \"icon\",\n        id: \"id\",\n        imagesizes: \"imageSizes\",\n        imagesrcset: \"imageSrcSet\",\n        innerhtml: \"innerHTML\",\n        inputmode: \"inputMode\",\n        integrity: \"integrity\",\n        is: \"is\",\n        itemid: \"itemID\",\n        itemprop: \"itemProp\",\n        itemref: \"itemRef\",\n        itemscope: \"itemScope\",\n        itemtype: \"itemType\",\n        keyparams: \"keyParams\",\n        keytype: \"keyType\",\n        kind: \"kind\",\n        label: \"label\",\n        lang: \"lang\",\n        list: \"list\",\n        loop: \"loop\",\n        low: \"low\",\n        manifest: \"manifest\",\n        marginwidth: \"marginWidth\",\n        marginheight: \"marginHeight\",\n        max: \"max\",\n        maxlength: \"maxLength\",\n        media: \"media\",\n        mediagroup: \"mediaGroup\",\n        method: \"method\",\n        min: \"min\",\n        minlength: \"minLength\",\n        multiple: \"multiple\",\n        muted: \"muted\",\n        name: \"name\",\n        nomodule: \"noModule\",\n        nonce: \"nonce\",\n        novalidate: \"noValidate\",\n        open: \"open\",\n        optimum: \"optimum\",\n        pattern: \"pattern\",\n        placeholder: \"placeholder\",\n        playsinline: \"playsInline\",\n        poster: \"poster\",\n        preload: \"preload\",\n        profile: \"profile\",\n        radiogroup: \"radioGroup\",\n        readonly: \"readOnly\",\n        referrerpolicy: \"referrerPolicy\",\n        rel: \"rel\",\n        required: \"required\",\n        reversed: \"reversed\",\n        role: \"role\",\n        rows: \"rows\",\n        rowspan: \"rowSpan\",\n        sandbox: \"sandbox\",\n        scope: \"scope\",\n        scoped: \"scoped\",\n        scrolling: \"scrolling\",\n        seamless: \"seamless\",\n        selected: \"selected\",\n        shape: \"shape\",\n        size: \"size\",\n        sizes: \"sizes\",\n        span: \"span\",\n        spellcheck: \"spellCheck\",\n        src: \"src\",\n        srcdoc: \"srcDoc\",\n        srclang: \"srcLang\",\n        srcset: \"srcSet\",\n        start: \"start\",\n        step: \"step\",\n        style: \"style\",\n        summary: \"summary\",\n        tabindex: \"tabIndex\",\n        target: \"target\",\n        title: \"title\",\n        type: \"type\",\n        usemap: \"useMap\",\n        value: \"value\",\n        width: \"width\",\n        wmode: \"wmode\",\n        wrap: \"wrap\",\n        about: \"about\",\n        accentheight: \"accentHeight\",\n        \"accent-height\": \"accentHeight\",\n        accumulate: \"accumulate\",\n        additive: \"additive\",\n        alignmentbaseline: \"alignmentBaseline\",\n        \"alignment-baseline\": \"alignmentBaseline\",\n        allowreorder: \"allowReorder\",\n        alphabetic: \"alphabetic\",\n        amplitude: \"amplitude\",\n        arabicform: \"arabicForm\",\n        \"arabic-form\": \"arabicForm\",\n        ascent: \"ascent\",\n        attributename: \"attributeName\",\n        attributetype: \"attributeType\",\n        autoreverse: \"autoReverse\",\n        azimuth: \"azimuth\",\n        basefrequency: \"baseFrequency\",\n        baselineshift: \"baselineShift\",\n        \"baseline-shift\": \"baselineShift\",\n        baseprofile: \"baseProfile\",\n        bbox: \"bbox\",\n        begin: \"begin\",\n        bias: \"bias\",\n        by: \"by\",\n        calcmode: \"calcMode\",\n        capheight: \"capHeight\",\n        \"cap-height\": \"capHeight\",\n        clip: \"clip\",\n        clippath: \"clipPath\",\n        \"clip-path\": \"clipPath\",\n        clippathunits: \"clipPathUnits\",\n        cliprule: \"clipRule\",\n        \"clip-rule\": \"clipRule\",\n        color: \"color\",\n        colorinterpolation: \"colorInterpolation\",\n        \"color-interpolation\": \"colorInterpolation\",\n        colorinterpolationfilters: \"colorInterpolationFilters\",\n        \"color-interpolation-filters\": \"colorInterpolationFilters\",\n        colorprofile: \"colorProfile\",\n        \"color-profile\": \"colorProfile\",\n        colorrendering: \"colorRendering\",\n        \"color-rendering\": \"colorRendering\",\n        contentscripttype: \"contentScriptType\",\n        contentstyletype: \"contentStyleType\",\n        cursor: \"cursor\",\n        cx: \"cx\",\n        cy: \"cy\",\n        d: \"d\",\n        datatype: \"datatype\",\n        decelerate: \"decelerate\",\n        descent: \"descent\",\n        diffuseconstant: \"diffuseConstant\",\n        direction: \"direction\",\n        display: \"display\",\n        divisor: \"divisor\",\n        dominantbaseline: \"dominantBaseline\",\n        \"dominant-baseline\": \"dominantBaseline\",\n        dur: \"dur\",\n        dx: \"dx\",\n        dy: \"dy\",\n        edgemode: \"edgeMode\",\n        elevation: \"elevation\",\n        enablebackground: \"enableBackground\",\n        \"enable-background\": \"enableBackground\",\n        end: \"end\",\n        exponent: \"exponent\",\n        externalresourcesrequired: \"externalResourcesRequired\",\n        fill: \"fill\",\n        fillopacity: \"fillOpacity\",\n        \"fill-opacity\": \"fillOpacity\",\n        fillrule: \"fillRule\",\n        \"fill-rule\": \"fillRule\",\n        filter: \"filter\",\n        filterres: \"filterRes\",\n        filterunits: \"filterUnits\",\n        floodopacity: \"floodOpacity\",\n        \"flood-opacity\": \"floodOpacity\",\n        floodcolor: \"floodColor\",\n        \"flood-color\": \"floodColor\",\n        focusable: \"focusable\",\n        fontfamily: \"fontFamily\",\n        \"font-family\": \"fontFamily\",\n        fontsize: \"fontSize\",\n        \"font-size\": \"fontSize\",\n        fontsizeadjust: \"fontSizeAdjust\",\n        \"font-size-adjust\": \"fontSizeAdjust\",\n        fontstretch: \"fontStretch\",\n        \"font-stretch\": \"fontStretch\",\n        fontstyle: \"fontStyle\",\n        \"font-style\": \"fontStyle\",\n        fontvariant: \"fontVariant\",\n        \"font-variant\": \"fontVariant\",\n        fontweight: \"fontWeight\",\n        \"font-weight\": \"fontWeight\",\n        format: \"format\",\n        from: \"from\",\n        fx: \"fx\",\n        fy: \"fy\",\n        g1: \"g1\",\n        g2: \"g2\",\n        glyphname: \"glyphName\",\n        \"glyph-name\": \"glyphName\",\n        glyphorientationhorizontal: \"glyphOrientationHorizontal\",\n        \"glyph-orientation-horizontal\": \"glyphOrientationHorizontal\",\n        glyphorientationvertical: \"glyphOrientationVertical\",\n        \"glyph-orientation-vertical\": \"glyphOrientationVertical\",\n        glyphref: \"glyphRef\",\n        gradienttransform: \"gradientTransform\",\n        gradientunits: \"gradientUnits\",\n        hanging: \"hanging\",\n        horizadvx: \"horizAdvX\",\n        \"horiz-adv-x\": \"horizAdvX\",\n        horizoriginx: \"horizOriginX\",\n        \"horiz-origin-x\": \"horizOriginX\",\n        ideographic: \"ideographic\",\n        imagerendering: \"imageRendering\",\n        \"image-rendering\": \"imageRendering\",\n        in2: \"in2\",\n        in: \"in\",\n        inlist: \"inlist\",\n        intercept: \"intercept\",\n        k1: \"k1\",\n        k2: \"k2\",\n        k3: \"k3\",\n        k4: \"k4\",\n        k: \"k\",\n        kernelmatrix: \"kernelMatrix\",\n        kernelunitlength: \"kernelUnitLength\",\n        kerning: \"kerning\",\n        keypoints: \"keyPoints\",\n        keysplines: \"keySplines\",\n        keytimes: \"keyTimes\",\n        lengthadjust: \"lengthAdjust\",\n        letterspacing: \"letterSpacing\",\n        \"letter-spacing\": \"letterSpacing\",\n        lightingcolor: \"lightingColor\",\n        \"lighting-color\": \"lightingColor\",\n        limitingconeangle: \"limitingConeAngle\",\n        local: \"local\",\n        markerend: \"markerEnd\",\n        \"marker-end\": \"markerEnd\",\n        markerheight: \"markerHeight\",\n        markermid: \"markerMid\",\n        \"marker-mid\": \"markerMid\",\n        markerstart: \"markerStart\",\n        \"marker-start\": \"markerStart\",\n        markerunits: \"markerUnits\",\n        markerwidth: \"markerWidth\",\n        mask: \"mask\",\n        maskcontentunits: \"maskContentUnits\",\n        maskunits: \"maskUnits\",\n        mathematical: \"mathematical\",\n        mode: \"mode\",\n        numoctaves: \"numOctaves\",\n        offset: \"offset\",\n        opacity: \"opacity\",\n        operator: \"operator\",\n        order: \"order\",\n        orient: \"orient\",\n        orientation: \"orientation\",\n        origin: \"origin\",\n        overflow: \"overflow\",\n        overlineposition: \"overlinePosition\",\n        \"overline-position\": \"overlinePosition\",\n        overlinethickness: \"overlineThickness\",\n        \"overline-thickness\": \"overlineThickness\",\n        paintorder: \"paintOrder\",\n        \"paint-order\": \"paintOrder\",\n        panose1: \"panose1\",\n        \"panose-1\": \"panose1\",\n        pathlength: \"pathLength\",\n        patterncontentunits: \"patternContentUnits\",\n        patterntransform: \"patternTransform\",\n        patternunits: \"patternUnits\",\n        pointerevents: \"pointerEvents\",\n        \"pointer-events\": \"pointerEvents\",\n        points: \"points\",\n        pointsatx: \"pointsAtX\",\n        pointsaty: \"pointsAtY\",\n        pointsatz: \"pointsAtZ\",\n        prefix: \"prefix\",\n        preservealpha: \"preserveAlpha\",\n        preserveaspectratio: \"preserveAspectRatio\",\n        primitiveunits: \"primitiveUnits\",\n        property: \"property\",\n        r: \"r\",\n        radius: \"radius\",\n        refx: \"refX\",\n        refy: \"refY\",\n        renderingintent: \"renderingIntent\",\n        \"rendering-intent\": \"renderingIntent\",\n        repeatcount: \"repeatCount\",\n        repeatdur: \"repeatDur\",\n        requiredextensions: \"requiredExtensions\",\n        requiredfeatures: \"requiredFeatures\",\n        resource: \"resource\",\n        restart: \"restart\",\n        result: \"result\",\n        results: \"results\",\n        rotate: \"rotate\",\n        rx: \"rx\",\n        ry: \"ry\",\n        scale: \"scale\",\n        security: \"security\",\n        seed: \"seed\",\n        shaperendering: \"shapeRendering\",\n        \"shape-rendering\": \"shapeRendering\",\n        slope: \"slope\",\n        spacing: \"spacing\",\n        specularconstant: \"specularConstant\",\n        specularexponent: \"specularExponent\",\n        speed: \"speed\",\n        spreadmethod: \"spreadMethod\",\n        startoffset: \"startOffset\",\n        stddeviation: \"stdDeviation\",\n        stemh: \"stemh\",\n        stemv: \"stemv\",\n        stitchtiles: \"stitchTiles\",\n        stopcolor: \"stopColor\",\n        \"stop-color\": \"stopColor\",\n        stopopacity: \"stopOpacity\",\n        \"stop-opacity\": \"stopOpacity\",\n        strikethroughposition: \"strikethroughPosition\",\n        \"strikethrough-position\": \"strikethroughPosition\",\n        strikethroughthickness: \"strikethroughThickness\",\n        \"strikethrough-thickness\": \"strikethroughThickness\",\n        string: \"string\",\n        stroke: \"stroke\",\n        strokedasharray: \"strokeDasharray\",\n        \"stroke-dasharray\": \"strokeDasharray\",\n        strokedashoffset: \"strokeDashoffset\",\n        \"stroke-dashoffset\": \"strokeDashoffset\",\n        strokelinecap: \"strokeLinecap\",\n        \"stroke-linecap\": \"strokeLinecap\",\n        strokelinejoin: \"strokeLinejoin\",\n        \"stroke-linejoin\": \"strokeLinejoin\",\n        strokemiterlimit: \"strokeMiterlimit\",\n        \"stroke-miterlimit\": \"strokeMiterlimit\",\n        strokewidth: \"strokeWidth\",\n        \"stroke-width\": \"strokeWidth\",\n        strokeopacity: \"strokeOpacity\",\n        \"stroke-opacity\": \"strokeOpacity\",\n        suppresscontenteditablewarning: \"suppressContentEditableWarning\",\n        suppresshydrationwarning: \"suppressHydrationWarning\",\n        surfacescale: \"surfaceScale\",\n        systemlanguage: \"systemLanguage\",\n        tablevalues: \"tableValues\",\n        targetx: \"targetX\",\n        targety: \"targetY\",\n        textanchor: \"textAnchor\",\n        \"text-anchor\": \"textAnchor\",\n        textdecoration: \"textDecoration\",\n        \"text-decoration\": \"textDecoration\",\n        textlength: \"textLength\",\n        textrendering: \"textRendering\",\n        \"text-rendering\": \"textRendering\",\n        to: \"to\",\n        transform: \"transform\",\n        typeof: \"typeof\",\n        u1: \"u1\",\n        u2: \"u2\",\n        underlineposition: \"underlinePosition\",\n        \"underline-position\": \"underlinePosition\",\n        underlinethickness: \"underlineThickness\",\n        \"underline-thickness\": \"underlineThickness\",\n        unicode: \"unicode\",\n        unicodebidi: \"unicodeBidi\",\n        \"unicode-bidi\": \"unicodeBidi\",\n        unicoderange: \"unicodeRange\",\n        \"unicode-range\": \"unicodeRange\",\n        unitsperem: \"unitsPerEm\",\n        \"units-per-em\": \"unitsPerEm\",\n        unselectable: \"unselectable\",\n        valphabetic: \"vAlphabetic\",\n        \"v-alphabetic\": \"vAlphabetic\",\n        values: \"values\",\n        vectoreffect: \"vectorEffect\",\n        \"vector-effect\": \"vectorEffect\",\n        version: \"version\",\n        vertadvy: \"vertAdvY\",\n        \"vert-adv-y\": \"vertAdvY\",\n        vertoriginx: \"vertOriginX\",\n        \"vert-origin-x\": \"vertOriginX\",\n        vertoriginy: \"vertOriginY\",\n        \"vert-origin-y\": \"vertOriginY\",\n        vhanging: \"vHanging\",\n        \"v-hanging\": \"vHanging\",\n        videographic: \"vIdeographic\",\n        \"v-ideographic\": \"vIdeographic\",\n        viewbox: \"viewBox\",\n        viewtarget: \"viewTarget\",\n        visibility: \"visibility\",\n        vmathematical: \"vMathematical\",\n        \"v-mathematical\": \"vMathematical\",\n        vocab: \"vocab\",\n        widths: \"widths\",\n        wordspacing: \"wordSpacing\",\n        \"word-spacing\": \"wordSpacing\",\n        writingmode: \"writingMode\",\n        \"writing-mode\": \"writingMode\",\n        x1: \"x1\",\n        x2: \"x2\",\n        x: \"x\",\n        xchannelselector: \"xChannelSelector\",\n        xheight: \"xHeight\",\n        \"x-height\": \"xHeight\",\n        xlinkactuate: \"xlinkActuate\",\n        \"xlink:actuate\": \"xlinkActuate\",\n        xlinkarcrole: \"xlinkArcrole\",\n        \"xlink:arcrole\": \"xlinkArcrole\",\n        xlinkhref: \"xlinkHref\",\n        \"xlink:href\": \"xlinkHref\",\n        xlinkrole: \"xlinkRole\",\n        \"xlink:role\": \"xlinkRole\",\n        xlinkshow: \"xlinkShow\",\n        \"xlink:show\": \"xlinkShow\",\n        xlinktitle: \"xlinkTitle\",\n        \"xlink:title\": \"xlinkTitle\",\n        xlinktype: \"xlinkType\",\n        \"xlink:type\": \"xlinkType\",\n        xmlbase: \"xmlBase\",\n        \"xml:base\": \"xmlBase\",\n        xmllang: \"xmlLang\",\n        \"xml:lang\": \"xmlLang\",\n        xmlns: \"xmlns\",\n        \"xml:space\": \"xmlSpace\",\n        xmlnsxlink: \"xmlnsXlink\",\n        \"xmlns:xlink\": \"xmlnsXlink\",\n        xmlspace: \"xmlSpace\",\n        y1: \"y1\",\n        y2: \"y2\",\n        y: \"y\",\n        ychannelselector: \"yChannelSelector\",\n        z: \"z\",\n        zoomandpan: \"zoomAndPan\"\n      };\n      var ariaProperties = {\n        \"aria-current\": 0,\n        \"aria-description\": 0,\n        \"aria-details\": 0,\n        \"aria-disabled\": 0,\n        \"aria-hidden\": 0,\n        \"aria-invalid\": 0,\n        \"aria-keyshortcuts\": 0,\n        \"aria-label\": 0,\n        \"aria-roledescription\": 0,\n        \"aria-autocomplete\": 0,\n        \"aria-checked\": 0,\n        \"aria-expanded\": 0,\n        \"aria-haspopup\": 0,\n        \"aria-level\": 0,\n        \"aria-modal\": 0,\n        \"aria-multiline\": 0,\n        \"aria-multiselectable\": 0,\n        \"aria-orientation\": 0,\n        \"aria-placeholder\": 0,\n        \"aria-pressed\": 0,\n        \"aria-readonly\": 0,\n        \"aria-required\": 0,\n        \"aria-selected\": 0,\n        \"aria-sort\": 0,\n        \"aria-valuemax\": 0,\n        \"aria-valuemin\": 0,\n        \"aria-valuenow\": 0,\n        \"aria-valuetext\": 0,\n        \"aria-atomic\": 0,\n        \"aria-busy\": 0,\n        \"aria-live\": 0,\n        \"aria-relevant\": 0,\n        \"aria-dropeffect\": 0,\n        \"aria-grabbed\": 0,\n        \"aria-activedescendant\": 0,\n        \"aria-colcount\": 0,\n        \"aria-colindex\": 0,\n        \"aria-colspan\": 0,\n        \"aria-controls\": 0,\n        \"aria-describedby\": 0,\n        \"aria-errormessage\": 0,\n        \"aria-flowto\": 0,\n        \"aria-labelledby\": 0,\n        \"aria-owns\": 0,\n        \"aria-posinset\": 0,\n        \"aria-rowcount\": 0,\n        \"aria-rowindex\": 0,\n        \"aria-rowspan\": 0,\n        \"aria-setsize\": 0\n      };\n      var warnedProperties = {};\n      var rARIA = new RegExp(\"^(aria)-[\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n      var rARIACamel = new RegExp(\"^(aria)[A-Z][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n      function validateProperty(tagName, name) {\n        {\n          if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {\n            return true;\n          }\n          if (rARIACamel.test(name)) {\n            var ariaName = \"aria-\" + name.slice(4).toLowerCase();\n            var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;\n            if (correctName == null) {\n              error(\"Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.\", name);\n              warnedProperties[name] = true;\n              return true;\n            }\n            if (name !== correctName) {\n              error(\"Invalid ARIA attribute `%s`. Did you mean `%s`?\", name, correctName);\n              warnedProperties[name] = true;\n              return true;\n            }\n          }\n          if (rARIA.test(name)) {\n            var lowerCasedName = name.toLowerCase();\n            var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;\n            if (standardName == null) {\n              warnedProperties[name] = true;\n              return false;\n            }\n            if (name !== standardName) {\n              error(\"Unknown ARIA attribute `%s`. Did you mean `%s`?\", name, standardName);\n              warnedProperties[name] = true;\n              return true;\n            }\n          }\n        }\n        return true;\n      }\n      function warnInvalidARIAProps(type, props) {\n        {\n          var invalidProps = [];\n          for (var key in props) {\n            var isValid = validateProperty(type, key);\n            if (!isValid) {\n              invalidProps.push(key);\n            }\n          }\n          var unknownPropString = invalidProps.map(function(prop) {\n            return \"`\" + prop + \"`\";\n          }).join(\", \");\n          if (invalidProps.length === 1) {\n            error(\"Invalid aria prop %s on <%s> tag. \" + \"For details, see https://reactjs.org/link/invalid-aria-props\", unknownPropString, type);\n          } else if (invalidProps.length > 1) {\n            error(\"Invalid aria props %s on <%s> tag. \" + \"For details, see https://reactjs.org/link/invalid-aria-props\", unknownPropString, type);\n          }\n        }\n      }\n      function validateProperties(type, props) {\n        if (isCustomComponent(type, props)) {\n          return;\n        }\n        warnInvalidARIAProps(type, props);\n      }\n      var didWarnValueNull = false;\n      function validateProperties$1(type, props) {\n        {\n          if (type !== \"input\" && type !== \"textarea\" && type !== \"select\") {\n            return;\n          }\n          if (props != null && props.value === null && !didWarnValueNull) {\n            didWarnValueNull = true;\n            if (type === \"select\" && props.multiple) {\n              error(\"`value` prop on `%s` should not be null. \" + \"Consider using an empty array when `multiple` is set to `true` \" + \"to clear the component or `undefined` for uncontrolled components.\", type);\n            } else {\n              error(\"`value` prop on `%s` should not be null. \" + \"Consider using an empty string to clear the component or `undefined` \" + \"for uncontrolled components.\", type);\n            }\n          }\n        }\n      }\n      var validateProperty$1 = function() {};\n      {\n        var warnedProperties$1 = {};\n        var EVENT_NAME_REGEX = /^on./;\n        var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;\n        var rARIA$1 = new RegExp(\"^(aria)-[\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        var rARIACamel$1 = new RegExp(\"^(aria)[A-Z][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        validateProperty$1 = function(tagName, name, value, eventRegistry) {\n          if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {\n            return true;\n          }\n          var lowerCasedName = name.toLowerCase();\n          if (lowerCasedName === \"onfocusin\" || lowerCasedName === \"onfocusout\") {\n            error(\"React uses onFocus and onBlur instead of onFocusIn and onFocusOut. \" + \"All React events are normalized to bubble, so onFocusIn and onFocusOut \" + \"are not needed/supported by React.\");\n            warnedProperties$1[name] = true;\n            return true;\n          }\n          if (eventRegistry != null) {\n            var { registrationNameDependencies: registrationNameDependencies2, possibleRegistrationNames: possibleRegistrationNames2 } = eventRegistry;\n            if (registrationNameDependencies2.hasOwnProperty(name)) {\n              return true;\n            }\n            var registrationName = possibleRegistrationNames2.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames2[lowerCasedName] : null;\n            if (registrationName != null) {\n              error(\"Invalid event handler property `%s`. Did you mean `%s`?\", name, registrationName);\n              warnedProperties$1[name] = true;\n              return true;\n            }\n            if (EVENT_NAME_REGEX.test(name)) {\n              error(\"Unknown event handler property `%s`. It will be ignored.\", name);\n              warnedProperties$1[name] = true;\n              return true;\n            }\n          } else if (EVENT_NAME_REGEX.test(name)) {\n            if (INVALID_EVENT_NAME_REGEX.test(name)) {\n              error(\"Invalid event handler property `%s`. \" + \"React events use the camelCase naming convention, for example `onClick`.\", name);\n            }\n            warnedProperties$1[name] = true;\n            return true;\n          }\n          if (rARIA$1.test(name) || rARIACamel$1.test(name)) {\n            return true;\n          }\n          if (lowerCasedName === \"innerhtml\") {\n            error(\"Directly setting property `innerHTML` is not permitted. \" + \"For more information, lookup documentation on `dangerouslySetInnerHTML`.\");\n            warnedProperties$1[name] = true;\n            return true;\n          }\n          if (lowerCasedName === \"aria\") {\n            error(\"The `aria` attribute is reserved for future use in React. \" + \"Pass individual `aria-` attributes instead.\");\n            warnedProperties$1[name] = true;\n            return true;\n          }\n          if (lowerCasedName === \"is\" && value !== null && value !== undefined && typeof value !== \"string\") {\n            error(\"Received a `%s` for a string attribute `is`. If this is expected, cast \" + \"the value to a string.\", typeof value);\n            warnedProperties$1[name] = true;\n            return true;\n          }\n          if (typeof value === \"number\" && isNaN(value)) {\n            error(\"Received NaN for the `%s` attribute. If this is expected, cast \" + \"the value to a string.\", name);\n            warnedProperties$1[name] = true;\n            return true;\n          }\n          var propertyInfo = getPropertyInfo(name);\n          var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;\n          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n            var standardName = possibleStandardNames[lowerCasedName];\n            if (standardName !== name) {\n              error(\"Invalid DOM property `%s`. Did you mean `%s`?\", name, standardName);\n              warnedProperties$1[name] = true;\n              return true;\n            }\n          } else if (!isReserved && name !== lowerCasedName) {\n            error(\"React does not recognize the `%s` prop on a DOM element. If you \" + \"intentionally want it to appear in the DOM as a custom \" + \"attribute, spell it as lowercase `%s` instead. \" + \"If you accidentally passed it from a parent component, remove \" + \"it from the DOM element.\", name, lowerCasedName);\n            warnedProperties$1[name] = true;\n            return true;\n          }\n          if (typeof value === \"boolean\" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {\n            if (value) {\n              error(\"Received `%s` for a non-boolean attribute `%s`.\\n\\n\" + \"If you want to write it to the DOM, pass a string instead: \" + '%s=\"%s\" or %s={value.toString()}.', value, name, name, value, name);\n            } else {\n              error(\"Received `%s` for a non-boolean attribute `%s`.\\n\\n\" + \"If you want to write it to the DOM, pass a string instead: \" + `%s=\"%s\" or %s={value.toString()}.\n\n` + \"If you used to conditionally omit it with %s={condition && value}, \" + \"pass %s={condition ? value : undefined} instead.\", value, name, name, value, name, name, name);\n            }\n            warnedProperties$1[name] = true;\n            return true;\n          }\n          if (isReserved) {\n            return true;\n          }\n          if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {\n            warnedProperties$1[name] = true;\n            return false;\n          }\n          if ((value === \"false\" || value === \"true\") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {\n            error(\"Received the string `%s` for the boolean attribute `%s`. \" + \"%s \" + \"Did you mean %s={%s}?\", value, name, value === \"false\" ? \"The browser will interpret it as a truthy value.\" : 'Although this works, it will not work as expected if you pass the string \"false\".', name, value);\n            warnedProperties$1[name] = true;\n            return true;\n          }\n          return true;\n        };\n      }\n      var warnUnknownProperties = function(type, props, eventRegistry) {\n        {\n          var unknownProps = [];\n          for (var key in props) {\n            var isValid = validateProperty$1(type, key, props[key], eventRegistry);\n            if (!isValid) {\n              unknownProps.push(key);\n            }\n          }\n          var unknownPropString = unknownProps.map(function(prop) {\n            return \"`\" + prop + \"`\";\n          }).join(\", \");\n          if (unknownProps.length === 1) {\n            error(\"Invalid value for prop %s on <%s> tag. Either remove it from the element, \" + \"or pass a string or number value to keep it in the DOM. \" + \"For details, see https://reactjs.org/link/attribute-behavior \", unknownPropString, type);\n          } else if (unknownProps.length > 1) {\n            error(\"Invalid values for props %s on <%s> tag. Either remove them from the element, \" + \"or pass a string or number value to keep them in the DOM. \" + \"For details, see https://reactjs.org/link/attribute-behavior \", unknownPropString, type);\n          }\n        }\n      };\n      function validateProperties$2(type, props, eventRegistry) {\n        if (isCustomComponent(type, props)) {\n          return;\n        }\n        warnUnknownProperties(type, props, eventRegistry);\n      }\n      var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;\n      var IS_NON_DELEGATED = 1 << 1;\n      var IS_CAPTURE_PHASE = 1 << 2;\n      var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;\n      var currentReplayingEvent = null;\n      function setReplayingEvent(event) {\n        {\n          if (currentReplayingEvent !== null) {\n            error(\"Expected currently replaying event to be null. This error \" + \"is likely caused by a bug in React. Please file an issue.\");\n          }\n        }\n        currentReplayingEvent = event;\n      }\n      function resetReplayingEvent() {\n        {\n          if (currentReplayingEvent === null) {\n            error(\"Expected currently replaying event to not be null. This error \" + \"is likely caused by a bug in React. Please file an issue.\");\n          }\n        }\n        currentReplayingEvent = null;\n      }\n      function isReplayingEvent(event) {\n        return event === currentReplayingEvent;\n      }\n      function getEventTarget(nativeEvent) {\n        var target = nativeEvent.target || nativeEvent.srcElement || window;\n        if (target.correspondingUseElement) {\n          target = target.correspondingUseElement;\n        }\n        return target.nodeType === TEXT_NODE ? target.parentNode : target;\n      }\n      var restoreImpl = null;\n      var restoreTarget = null;\n      var restoreQueue = null;\n      function restoreStateOfTarget(target) {\n        var internalInstance = getInstanceFromNode(target);\n        if (!internalInstance) {\n          return;\n        }\n        if (typeof restoreImpl !== \"function\") {\n          throw new Error(\"setRestoreImplementation() needs to be called to handle a target for controlled \" + \"events. This error is likely caused by a bug in React. Please file an issue.\");\n        }\n        var stateNode = internalInstance.stateNode;\n        if (stateNode) {\n          var _props = getFiberCurrentPropsFromNode(stateNode);\n          restoreImpl(internalInstance.stateNode, internalInstance.type, _props);\n        }\n      }\n      function setRestoreImplementation(impl) {\n        restoreImpl = impl;\n      }\n      function enqueueStateRestore(target) {\n        if (restoreTarget) {\n          if (restoreQueue) {\n            restoreQueue.push(target);\n          } else {\n            restoreQueue = [target];\n          }\n        } else {\n          restoreTarget = target;\n        }\n      }\n      function needsStateRestore() {\n        return restoreTarget !== null || restoreQueue !== null;\n      }\n      function restoreStateIfNeeded() {\n        if (!restoreTarget) {\n          return;\n        }\n        var target = restoreTarget;\n        var queuedTargets = restoreQueue;\n        restoreTarget = null;\n        restoreQueue = null;\n        restoreStateOfTarget(target);\n        if (queuedTargets) {\n          for (var i = 0;i < queuedTargets.length; i++) {\n            restoreStateOfTarget(queuedTargets[i]);\n          }\n        }\n      }\n      var batchedUpdatesImpl = function(fn, bookkeeping) {\n        return fn(bookkeeping);\n      };\n      var flushSyncImpl = function() {};\n      var isInsideEventHandler = false;\n      function finishEventHandler() {\n        var controlledComponentsHavePendingUpdates = needsStateRestore();\n        if (controlledComponentsHavePendingUpdates) {\n          flushSyncImpl();\n          restoreStateIfNeeded();\n        }\n      }\n      function batchedUpdates(fn, a, b) {\n        if (isInsideEventHandler) {\n          return fn(a, b);\n        }\n        isInsideEventHandler = true;\n        try {\n          return batchedUpdatesImpl(fn, a, b);\n        } finally {\n          isInsideEventHandler = false;\n          finishEventHandler();\n        }\n      }\n      function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushSyncImpl) {\n        batchedUpdatesImpl = _batchedUpdatesImpl;\n        flushSyncImpl = _flushSyncImpl;\n      }\n      function isInteractive(tag) {\n        return tag === \"button\" || tag === \"input\" || tag === \"select\" || tag === \"textarea\";\n      }\n      function shouldPreventMouseEvent(name, type, props) {\n        switch (name) {\n          case \"onClick\":\n          case \"onClickCapture\":\n          case \"onDoubleClick\":\n          case \"onDoubleClickCapture\":\n          case \"onMouseDown\":\n          case \"onMouseDownCapture\":\n          case \"onMouseMove\":\n          case \"onMouseMoveCapture\":\n          case \"onMouseUp\":\n          case \"onMouseUpCapture\":\n          case \"onMouseEnter\":\n            return !!(props.disabled && isInteractive(type));\n          default:\n            return false;\n        }\n      }\n      function getListener(inst, registrationName) {\n        var stateNode = inst.stateNode;\n        if (stateNode === null) {\n          return null;\n        }\n        var props = getFiberCurrentPropsFromNode(stateNode);\n        if (props === null) {\n          return null;\n        }\n        var listener = props[registrationName];\n        if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n          return null;\n        }\n        if (listener && typeof listener !== \"function\") {\n          throw new Error(\"Expected `\" + registrationName + \"` listener to be a function, instead got a value of `\" + typeof listener + \"` type.\");\n        }\n        return listener;\n      }\n      var passiveBrowserEventsSupported = false;\n      if (canUseDOM) {\n        try {\n          var options = {};\n          Object.defineProperty(options, \"passive\", {\n            get: function() {\n              passiveBrowserEventsSupported = true;\n            }\n          });\n          window.addEventListener(\"test\", options, options);\n          window.removeEventListener(\"test\", options, options);\n        } catch (e) {\n          passiveBrowserEventsSupported = false;\n        }\n      }\n      function invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {\n        var funcArgs = Array.prototype.slice.call(arguments, 3);\n        try {\n          func.apply(context, funcArgs);\n        } catch (error2) {\n          this.onError(error2);\n        }\n      }\n      var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;\n      {\n        if (typeof window !== \"undefined\" && typeof window.dispatchEvent === \"function\" && typeof document !== \"undefined\" && typeof document.createEvent === \"function\") {\n          var fakeNode = document.createElement(\"react\");\n          invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {\n            if (typeof document === \"undefined\" || document === null) {\n              throw new Error(\"The `document` global was defined when React was initialized, but is not \" + \"defined anymore. This can happen in a test environment if a component \" + \"schedules an update from an asynchronous callback, but the test has already \" + \"finished running. To solve this, you can either unmount the component at \" + \"the end of your test (and ensure that any asynchronous operations get \" + \"canceled in `componentWillUnmount`), or you can change the test itself \" + \"to be asynchronous.\");\n            }\n            var evt = document.createEvent(\"Event\");\n            var didCall = false;\n            var didError = true;\n            var windowEvent = window.event;\n            var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, \"event\");\n            function restoreAfterDispatch() {\n              fakeNode.removeEventListener(evtType, callCallback2, false);\n              if (typeof window.event !== \"undefined\" && window.hasOwnProperty(\"event\")) {\n                window.event = windowEvent;\n              }\n            }\n            var funcArgs = Array.prototype.slice.call(arguments, 3);\n            function callCallback2() {\n              didCall = true;\n              restoreAfterDispatch();\n              func.apply(context, funcArgs);\n              didError = false;\n            }\n            var error2;\n            var didSetError = false;\n            var isCrossOriginError = false;\n            function handleWindowError(event) {\n              error2 = event.error;\n              didSetError = true;\n              if (error2 === null && event.colno === 0 && event.lineno === 0) {\n                isCrossOriginError = true;\n              }\n              if (event.defaultPrevented) {\n                if (error2 != null && typeof error2 === \"object\") {\n                  try {\n                    error2._suppressLogging = true;\n                  } catch (inner) {}\n                }\n              }\n            }\n            var evtType = \"react-\" + (name ? name : \"invokeguardedcallback\");\n            window.addEventListener(\"error\", handleWindowError);\n            fakeNode.addEventListener(evtType, callCallback2, false);\n            evt.initEvent(evtType, false, false);\n            fakeNode.dispatchEvent(evt);\n            if (windowEventDescriptor) {\n              Object.defineProperty(window, \"event\", windowEventDescriptor);\n            }\n            if (didCall && didError) {\n              if (!didSetError) {\n                error2 = new Error(\"An error was thrown inside one of your components, but React \" + \"doesn't know what it was. This is likely due to browser \" + 'flakiness. React does its best to preserve the \"Pause on ' + 'exceptions\" behavior of the DevTools, which requires some ' + \"DEV-mode only tricks. It's possible that these don't work in \" + \"your browser. Try triggering the error in production mode, \" + \"or switching to a modern browser. If you suspect that this is \" + \"actually an issue with React, please file an issue.\");\n              } else if (isCrossOriginError) {\n                error2 = new Error(\"A cross-origin error was thrown. React doesn't have access to \" + \"the actual error object in development. \" + \"See https://reactjs.org/link/crossorigin-error for more information.\");\n              }\n              this.onError(error2);\n            }\n            window.removeEventListener(\"error\", handleWindowError);\n            if (!didCall) {\n              restoreAfterDispatch();\n              return invokeGuardedCallbackProd.apply(this, arguments);\n            }\n          };\n        }\n      }\n      var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;\n      var hasError = false;\n      var caughtError = null;\n      var hasRethrowError = false;\n      var rethrowError = null;\n      var reporter = {\n        onError: function(error2) {\n          hasError = true;\n          caughtError = error2;\n        }\n      };\n      function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {\n        hasError = false;\n        caughtError = null;\n        invokeGuardedCallbackImpl$1.apply(reporter, arguments);\n      }\n      function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {\n        invokeGuardedCallback.apply(this, arguments);\n        if (hasError) {\n          var error2 = clearCaughtError();\n          if (!hasRethrowError) {\n            hasRethrowError = true;\n            rethrowError = error2;\n          }\n        }\n      }\n      function rethrowCaughtError() {\n        if (hasRethrowError) {\n          var error2 = rethrowError;\n          hasRethrowError = false;\n          rethrowError = null;\n          throw error2;\n        }\n      }\n      function hasCaughtError() {\n        return hasError;\n      }\n      function clearCaughtError() {\n        if (hasError) {\n          var error2 = caughtError;\n          hasError = false;\n          caughtError = null;\n          return error2;\n        } else {\n          throw new Error(\"clearCaughtError was called but no error was captured. This error \" + \"is likely caused by a bug in React. Please file an issue.\");\n        }\n      }\n      function get(key) {\n        return key._reactInternals;\n      }\n      function has(key) {\n        return key._reactInternals !== undefined;\n      }\n      function set(key, value) {\n        key._reactInternals = value;\n      }\n      var NoFlags = 0;\n      var PerformedWork = 1;\n      var Placement = 2;\n      var Update = 4;\n      var ChildDeletion = 16;\n      var ContentReset = 32;\n      var Callback = 64;\n      var DidCapture = 128;\n      var ForceClientRender = 256;\n      var Ref = 512;\n      var Snapshot = 1024;\n      var Passive = 2048;\n      var Hydrating = 4096;\n      var Visibility = 8192;\n      var StoreConsistency = 16384;\n      var LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot | StoreConsistency;\n      var HostEffectMask = 32767;\n      var Incomplete = 32768;\n      var ShouldCapture = 65536;\n      var ForceUpdateForLegacySuspense = 131072;\n      var Forked = 1048576;\n      var RefStatic = 2097152;\n      var LayoutStatic = 4194304;\n      var PassiveStatic = 8388608;\n      var MountLayoutDev = 16777216;\n      var MountPassiveDev = 33554432;\n      var BeforeMutationMask = Update | Snapshot | 0;\n      var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;\n      var LayoutMask = Update | Callback | Ref | Visibility;\n      var PassiveMask = Passive | ChildDeletion;\n      var StaticMask = LayoutStatic | PassiveStatic | RefStatic;\n      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n      function getNearestMountedFiber(fiber) {\n        var node = fiber;\n        var nearestMounted = fiber;\n        if (!fiber.alternate) {\n          var nextNode = node;\n          do {\n            node = nextNode;\n            if ((node.flags & (Placement | Hydrating)) !== NoFlags) {\n              nearestMounted = node.return;\n            }\n            nextNode = node.return;\n          } while (nextNode);\n        } else {\n          while (node.return) {\n            node = node.return;\n          }\n        }\n        if (node.tag === HostRoot) {\n          return nearestMounted;\n        }\n        return null;\n      }\n      function getSuspenseInstanceFromFiber(fiber) {\n        if (fiber.tag === SuspenseComponent) {\n          var suspenseState = fiber.memoizedState;\n          if (suspenseState === null) {\n            var current2 = fiber.alternate;\n            if (current2 !== null) {\n              suspenseState = current2.memoizedState;\n            }\n          }\n          if (suspenseState !== null) {\n            return suspenseState.dehydrated;\n          }\n        }\n        return null;\n      }\n      function getContainerFromFiber(fiber) {\n        return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;\n      }\n      function isFiberMounted(fiber) {\n        return getNearestMountedFiber(fiber) === fiber;\n      }\n      function isMounted(component) {\n        {\n          var owner = ReactCurrentOwner.current;\n          if (owner !== null && owner.tag === ClassComponent) {\n            var ownerFiber = owner;\n            var instance = ownerFiber.stateNode;\n            if (!instance._warnedAboutRefsInRender) {\n              error(\"%s is accessing isMounted inside its render() function. \" + \"render() should be a pure function of props and state. It should \" + \"never access something that requires stale data from the previous \" + \"render, such as refs. Move this logic to componentDidMount and \" + \"componentDidUpdate instead.\", getComponentNameFromFiber(ownerFiber) || \"A component\");\n            }\n            instance._warnedAboutRefsInRender = true;\n          }\n        }\n        var fiber = get(component);\n        if (!fiber) {\n          return false;\n        }\n        return getNearestMountedFiber(fiber) === fiber;\n      }\n      function assertIsMounted(fiber) {\n        if (getNearestMountedFiber(fiber) !== fiber) {\n          throw new Error(\"Unable to find node on an unmounted component.\");\n        }\n      }\n      function findCurrentFiberUsingSlowPath(fiber) {\n        var alternate = fiber.alternate;\n        if (!alternate) {\n          var nearestMounted = getNearestMountedFiber(fiber);\n          if (nearestMounted === null) {\n            throw new Error(\"Unable to find node on an unmounted component.\");\n          }\n          if (nearestMounted !== fiber) {\n            return null;\n          }\n          return fiber;\n        }\n        var a = fiber;\n        var b = alternate;\n        while (true) {\n          var parentA = a.return;\n          if (parentA === null) {\n            break;\n          }\n          var parentB = parentA.alternate;\n          if (parentB === null) {\n            var nextParent = parentA.return;\n            if (nextParent !== null) {\n              a = b = nextParent;\n              continue;\n            }\n            break;\n          }\n          if (parentA.child === parentB.child) {\n            var child = parentA.child;\n            while (child) {\n              if (child === a) {\n                assertIsMounted(parentA);\n                return fiber;\n              }\n              if (child === b) {\n                assertIsMounted(parentA);\n                return alternate;\n              }\n              child = child.sibling;\n            }\n            throw new Error(\"Unable to find node on an unmounted component.\");\n          }\n          if (a.return !== b.return) {\n            a = parentA;\n            b = parentB;\n          } else {\n            var didFindChild = false;\n            var _child = parentA.child;\n            while (_child) {\n              if (_child === a) {\n                didFindChild = true;\n                a = parentA;\n                b = parentB;\n                break;\n              }\n              if (_child === b) {\n                didFindChild = true;\n                b = parentA;\n                a = parentB;\n                break;\n              }\n              _child = _child.sibling;\n            }\n            if (!didFindChild) {\n              _child = parentB.child;\n              while (_child) {\n                if (_child === a) {\n                  didFindChild = true;\n                  a = parentB;\n                  b = parentA;\n                  break;\n                }\n                if (_child === b) {\n                  didFindChild = true;\n                  b = parentB;\n                  a = parentA;\n                  break;\n                }\n                _child = _child.sibling;\n              }\n              if (!didFindChild) {\n                throw new Error(\"Child was not found in either parent set. This indicates a bug \" + \"in React related to the return pointer. Please file an issue.\");\n              }\n            }\n          }\n          if (a.alternate !== b) {\n            throw new Error(\"Return fibers should always be each others' alternates. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n          }\n        }\n        if (a.tag !== HostRoot) {\n          throw new Error(\"Unable to find node on an unmounted component.\");\n        }\n        if (a.stateNode.current === a) {\n          return fiber;\n        }\n        return alternate;\n      }\n      function findCurrentHostFiber(parent) {\n        var currentParent = findCurrentFiberUsingSlowPath(parent);\n        return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;\n      }\n      function findCurrentHostFiberImpl(node) {\n        if (node.tag === HostComponent || node.tag === HostText) {\n          return node;\n        }\n        var child = node.child;\n        while (child !== null) {\n          var match = findCurrentHostFiberImpl(child);\n          if (match !== null) {\n            return match;\n          }\n          child = child.sibling;\n        }\n        return null;\n      }\n      function findCurrentHostFiberWithNoPortals(parent) {\n        var currentParent = findCurrentFiberUsingSlowPath(parent);\n        return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;\n      }\n      function findCurrentHostFiberWithNoPortalsImpl(node) {\n        if (node.tag === HostComponent || node.tag === HostText) {\n          return node;\n        }\n        var child = node.child;\n        while (child !== null) {\n          if (child.tag !== HostPortal) {\n            var match = findCurrentHostFiberWithNoPortalsImpl(child);\n            if (match !== null) {\n              return match;\n            }\n          }\n          child = child.sibling;\n        }\n        return null;\n      }\n      var scheduleCallback = Scheduler.unstable_scheduleCallback;\n      var cancelCallback = Scheduler.unstable_cancelCallback;\n      var shouldYield = Scheduler.unstable_shouldYield;\n      var requestPaint = Scheduler.unstable_requestPaint;\n      var now = Scheduler.unstable_now;\n      var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;\n      var ImmediatePriority = Scheduler.unstable_ImmediatePriority;\n      var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;\n      var NormalPriority = Scheduler.unstable_NormalPriority;\n      var LowPriority = Scheduler.unstable_LowPriority;\n      var IdlePriority = Scheduler.unstable_IdlePriority;\n      var unstable_yieldValue2 = Scheduler.unstable_yieldValue;\n      var unstable_setDisableYieldValue2 = Scheduler.unstable_setDisableYieldValue;\n      var rendererID = null;\n      var injectedHook = null;\n      var injectedProfilingHooks = null;\n      var hasLoggedError = false;\n      var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\";\n      function injectInternals(internals) {\n        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\") {\n          return false;\n        }\n        var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n        if (hook.isDisabled) {\n          return true;\n        }\n        if (!hook.supportsFiber) {\n          {\n            error(\"The installed version of React DevTools is too old and will not work \" + \"with the current version of React. Please update React DevTools. \" + \"https://reactjs.org/link/react-devtools\");\n          }\n          return true;\n        }\n        try {\n          if (enableSchedulingProfiler) {\n            internals = assign({}, internals, {\n              getLaneLabelMap,\n              injectProfilingHooks\n            });\n          }\n          rendererID = hook.inject(internals);\n          injectedHook = hook;\n        } catch (err) {\n          {\n            error(\"React instrumentation encountered an error: %s.\", err);\n          }\n        }\n        if (hook.checkDCE) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n      function onScheduleRoot(root2, children) {\n        {\n          if (injectedHook && typeof injectedHook.onScheduleFiberRoot === \"function\") {\n            try {\n              injectedHook.onScheduleFiberRoot(rendererID, root2, children);\n            } catch (err) {\n              if (!hasLoggedError) {\n                hasLoggedError = true;\n                error(\"React instrumentation encountered an error: %s\", err);\n              }\n            }\n          }\n        }\n      }\n      function onCommitRoot(root2, eventPriority) {\n        if (injectedHook && typeof injectedHook.onCommitFiberRoot === \"function\") {\n          try {\n            var didError = (root2.current.flags & DidCapture) === DidCapture;\n            if (enableProfilerTimer) {\n              var schedulerPriority;\n              switch (eventPriority) {\n                case DiscreteEventPriority:\n                  schedulerPriority = ImmediatePriority;\n                  break;\n                case ContinuousEventPriority:\n                  schedulerPriority = UserBlockingPriority;\n                  break;\n                case DefaultEventPriority:\n                  schedulerPriority = NormalPriority;\n                  break;\n                case IdleEventPriority:\n                  schedulerPriority = IdlePriority;\n                  break;\n                default:\n                  schedulerPriority = NormalPriority;\n                  break;\n              }\n              injectedHook.onCommitFiberRoot(rendererID, root2, schedulerPriority, didError);\n            } else {\n              injectedHook.onCommitFiberRoot(rendererID, root2, undefined, didError);\n            }\n          } catch (err) {\n            {\n              if (!hasLoggedError) {\n                hasLoggedError = true;\n                error(\"React instrumentation encountered an error: %s\", err);\n              }\n            }\n          }\n        }\n      }\n      function onPostCommitRoot(root2) {\n        if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === \"function\") {\n          try {\n            injectedHook.onPostCommitFiberRoot(rendererID, root2);\n          } catch (err) {\n            {\n              if (!hasLoggedError) {\n                hasLoggedError = true;\n                error(\"React instrumentation encountered an error: %s\", err);\n              }\n            }\n          }\n        }\n      }\n      function onCommitUnmount(fiber) {\n        if (injectedHook && typeof injectedHook.onCommitFiberUnmount === \"function\") {\n          try {\n            injectedHook.onCommitFiberUnmount(rendererID, fiber);\n          } catch (err) {\n            {\n              if (!hasLoggedError) {\n                hasLoggedError = true;\n                error(\"React instrumentation encountered an error: %s\", err);\n              }\n            }\n          }\n        }\n      }\n      function setIsStrictModeForDevtools(newIsStrictMode) {\n        {\n          if (typeof unstable_yieldValue2 === \"function\") {\n            unstable_setDisableYieldValue2(newIsStrictMode);\n            setSuppressWarning(newIsStrictMode);\n          }\n          if (injectedHook && typeof injectedHook.setStrictMode === \"function\") {\n            try {\n              injectedHook.setStrictMode(rendererID, newIsStrictMode);\n            } catch (err) {\n              {\n                if (!hasLoggedError) {\n                  hasLoggedError = true;\n                  error(\"React instrumentation encountered an error: %s\", err);\n                }\n              }\n            }\n          }\n        }\n      }\n      function injectProfilingHooks(profilingHooks) {\n        injectedProfilingHooks = profilingHooks;\n      }\n      function getLaneLabelMap() {\n        {\n          var map = new Map;\n          var lane = 1;\n          for (var index2 = 0;index2 < TotalLanes; index2++) {\n            var label = getLabelForLane(lane);\n            map.set(lane, label);\n            lane *= 2;\n          }\n          return map;\n        }\n      }\n      function markCommitStarted(lanes) {\n        {\n          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === \"function\") {\n            injectedProfilingHooks.markCommitStarted(lanes);\n          }\n        }\n      }\n      function markCommitStopped() {\n        {\n          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === \"function\") {\n            injectedProfilingHooks.markCommitStopped();\n          }\n        }\n      }\n      function markComponentRenderStarted(fiber) {\n        {\n          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === \"function\") {\n            injectedProfilingHooks.markComponentRenderStarted(fiber);\n          }\n        }\n      }\n      function markComponentRenderStopped() {\n        {\n          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === \"function\") {\n            injectedProfilingHooks.markComponentRenderStopped();\n          }\n        }\n      }\n      function markComponentPassiveEffectMountStarted(fiber) {\n        {\n          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === \"function\") {\n            injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);\n          }\n        }\n      }\n      function markComponentPassiveEffectMountStopped() {\n        {\n          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === \"function\") {\n            injectedProfilingHooks.markComponentPassiveEffectMountStopped();\n          }\n        }\n      }\n      function markComponentPassiveEffectUnmountStarted(fiber) {\n        {\n          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === \"function\") {\n            injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);\n          }\n        }\n      }\n      function markComponentPassiveEffectUnmountStopped() {\n        {\n          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === \"function\") {\n            injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();\n          }\n        }\n      }\n      function markComponentLayoutEffectMountStarted(fiber) {\n        {\n          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === \"function\") {\n            injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);\n          }\n        }\n      }\n      function markComponentLayoutEffectMountStopped() {\n        {\n          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === \"function\") {\n            injectedProfilingHooks.markComponentLayoutEffectMountStopped();\n          }\n        }\n      }\n      function markComponentLayoutEffectUnmountStarted(fiber) {\n        {\n          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === \"function\") {\n            injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);\n          }\n        }\n      }\n      function markComponentLayoutEffectUnmountStopped() {\n        {\n          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === \"function\") {\n            injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();\n          }\n        }\n      }\n      function markComponentErrored(fiber, thrownValue, lanes) {\n        {\n          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === \"function\") {\n            injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);\n          }\n        }\n      }\n      function markComponentSuspended(fiber, wakeable, lanes) {\n        {\n          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === \"function\") {\n            injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);\n          }\n        }\n      }\n      function markLayoutEffectsStarted(lanes) {\n        {\n          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === \"function\") {\n            injectedProfilingHooks.markLayoutEffectsStarted(lanes);\n          }\n        }\n      }\n      function markLayoutEffectsStopped() {\n        {\n          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === \"function\") {\n            injectedProfilingHooks.markLayoutEffectsStopped();\n          }\n        }\n      }\n      function markPassiveEffectsStarted(lanes) {\n        {\n          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === \"function\") {\n            injectedProfilingHooks.markPassiveEffectsStarted(lanes);\n          }\n        }\n      }\n      function markPassiveEffectsStopped() {\n        {\n          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === \"function\") {\n            injectedProfilingHooks.markPassiveEffectsStopped();\n          }\n        }\n      }\n      function markRenderStarted(lanes) {\n        {\n          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === \"function\") {\n            injectedProfilingHooks.markRenderStarted(lanes);\n          }\n        }\n      }\n      function markRenderYielded() {\n        {\n          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === \"function\") {\n            injectedProfilingHooks.markRenderYielded();\n          }\n        }\n      }\n      function markRenderStopped() {\n        {\n          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === \"function\") {\n            injectedProfilingHooks.markRenderStopped();\n          }\n        }\n      }\n      function markRenderScheduled(lane) {\n        {\n          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === \"function\") {\n            injectedProfilingHooks.markRenderScheduled(lane);\n          }\n        }\n      }\n      function markForceUpdateScheduled(fiber, lane) {\n        {\n          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === \"function\") {\n            injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);\n          }\n        }\n      }\n      function markStateUpdateScheduled(fiber, lane) {\n        {\n          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === \"function\") {\n            injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);\n          }\n        }\n      }\n      var NoMode = 0;\n      var ConcurrentMode = 1;\n      var ProfileMode = 2;\n      var StrictLegacyMode = 8;\n      var StrictEffectsMode = 16;\n      var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;\n      var log = Math.log;\n      var LN2 = Math.LN2;\n      function clz32Fallback(x) {\n        var asUint = x >>> 0;\n        if (asUint === 0) {\n          return 32;\n        }\n        return 31 - (log(asUint) / LN2 | 0) | 0;\n      }\n      var TotalLanes = 31;\n      var NoLanes = 0;\n      var NoLane = 0;\n      var SyncLane = 1;\n      var InputContinuousHydrationLane = 2;\n      var InputContinuousLane = 4;\n      var DefaultHydrationLane = 8;\n      var DefaultLane = 16;\n      var TransitionHydrationLane = 32;\n      var TransitionLanes = 4194240;\n      var TransitionLane1 = 64;\n      var TransitionLane2 = 128;\n      var TransitionLane3 = 256;\n      var TransitionLane4 = 512;\n      var TransitionLane5 = 1024;\n      var TransitionLane6 = 2048;\n      var TransitionLane7 = 4096;\n      var TransitionLane8 = 8192;\n      var TransitionLane9 = 16384;\n      var TransitionLane10 = 32768;\n      var TransitionLane11 = 65536;\n      var TransitionLane12 = 131072;\n      var TransitionLane13 = 262144;\n      var TransitionLane14 = 524288;\n      var TransitionLane15 = 1048576;\n      var TransitionLane16 = 2097152;\n      var RetryLanes = 130023424;\n      var RetryLane1 = 4194304;\n      var RetryLane2 = 8388608;\n      var RetryLane3 = 16777216;\n      var RetryLane4 = 33554432;\n      var RetryLane5 = 67108864;\n      var SomeRetryLane = RetryLane1;\n      var SelectiveHydrationLane = 134217728;\n      var NonIdleLanes = 268435455;\n      var IdleHydrationLane = 268435456;\n      var IdleLane = 536870912;\n      var OffscreenLane = 1073741824;\n      function getLabelForLane(lane) {\n        {\n          if (lane & SyncLane) {\n            return \"Sync\";\n          }\n          if (lane & InputContinuousHydrationLane) {\n            return \"InputContinuousHydration\";\n          }\n          if (lane & InputContinuousLane) {\n            return \"InputContinuous\";\n          }\n          if (lane & DefaultHydrationLane) {\n            return \"DefaultHydration\";\n          }\n          if (lane & DefaultLane) {\n            return \"Default\";\n          }\n          if (lane & TransitionHydrationLane) {\n            return \"TransitionHydration\";\n          }\n          if (lane & TransitionLanes) {\n            return \"Transition\";\n          }\n          if (lane & RetryLanes) {\n            return \"Retry\";\n          }\n          if (lane & SelectiveHydrationLane) {\n            return \"SelectiveHydration\";\n          }\n          if (lane & IdleHydrationLane) {\n            return \"IdleHydration\";\n          }\n          if (lane & IdleLane) {\n            return \"Idle\";\n          }\n          if (lane & OffscreenLane) {\n            return \"Offscreen\";\n          }\n        }\n      }\n      var NoTimestamp = -1;\n      var nextTransitionLane = TransitionLane1;\n      var nextRetryLane = RetryLane1;\n      function getHighestPriorityLanes(lanes) {\n        switch (getHighestPriorityLane(lanes)) {\n          case SyncLane:\n            return SyncLane;\n          case InputContinuousHydrationLane:\n            return InputContinuousHydrationLane;\n          case InputContinuousLane:\n            return InputContinuousLane;\n          case DefaultHydrationLane:\n            return DefaultHydrationLane;\n          case DefaultLane:\n            return DefaultLane;\n          case TransitionHydrationLane:\n            return TransitionHydrationLane;\n          case TransitionLane1:\n          case TransitionLane2:\n          case TransitionLane3:\n          case TransitionLane4:\n          case TransitionLane5:\n          case TransitionLane6:\n          case TransitionLane7:\n          case TransitionLane8:\n          case TransitionLane9:\n          case TransitionLane10:\n          case TransitionLane11:\n          case TransitionLane12:\n          case TransitionLane13:\n          case TransitionLane14:\n          case TransitionLane15:\n          case TransitionLane16:\n            return lanes & TransitionLanes;\n          case RetryLane1:\n          case RetryLane2:\n          case RetryLane3:\n          case RetryLane4:\n          case RetryLane5:\n            return lanes & RetryLanes;\n          case SelectiveHydrationLane:\n            return SelectiveHydrationLane;\n          case IdleHydrationLane:\n            return IdleHydrationLane;\n          case IdleLane:\n            return IdleLane;\n          case OffscreenLane:\n            return OffscreenLane;\n          default:\n            {\n              error(\"Should have found matching lanes. This is a bug in React.\");\n            }\n            return lanes;\n        }\n      }\n      function getNextLanes(root2, wipLanes) {\n        var pendingLanes = root2.pendingLanes;\n        if (pendingLanes === NoLanes) {\n          return NoLanes;\n        }\n        var nextLanes = NoLanes;\n        var suspendedLanes = root2.suspendedLanes;\n        var pingedLanes = root2.pingedLanes;\n        var nonIdlePendingLanes = pendingLanes & NonIdleLanes;\n        if (nonIdlePendingLanes !== NoLanes) {\n          var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;\n          if (nonIdleUnblockedLanes !== NoLanes) {\n            nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);\n          } else {\n            var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;\n            if (nonIdlePingedLanes !== NoLanes) {\n              nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);\n            }\n          }\n        } else {\n          var unblockedLanes = pendingLanes & ~suspendedLanes;\n          if (unblockedLanes !== NoLanes) {\n            nextLanes = getHighestPriorityLanes(unblockedLanes);\n          } else {\n            if (pingedLanes !== NoLanes) {\n              nextLanes = getHighestPriorityLanes(pingedLanes);\n            }\n          }\n        }\n        if (nextLanes === NoLanes) {\n          return NoLanes;\n        }\n        if (wipLanes !== NoLanes && wipLanes !== nextLanes && (wipLanes & suspendedLanes) === NoLanes) {\n          var nextLane = getHighestPriorityLane(nextLanes);\n          var wipLane = getHighestPriorityLane(wipLanes);\n          if (nextLane >= wipLane || nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes) {\n            return wipLanes;\n          }\n        }\n        if ((nextLanes & InputContinuousLane) !== NoLanes) {\n          nextLanes |= pendingLanes & DefaultLane;\n        }\n        var entangledLanes = root2.entangledLanes;\n        if (entangledLanes !== NoLanes) {\n          var entanglements = root2.entanglements;\n          var lanes = nextLanes & entangledLanes;\n          while (lanes > 0) {\n            var index2 = pickArbitraryLaneIndex(lanes);\n            var lane = 1 << index2;\n            nextLanes |= entanglements[index2];\n            lanes &= ~lane;\n          }\n        }\n        return nextLanes;\n      }\n      function getMostRecentEventTime(root2, lanes) {\n        var eventTimes = root2.eventTimes;\n        var mostRecentEventTime = NoTimestamp;\n        while (lanes > 0) {\n          var index2 = pickArbitraryLaneIndex(lanes);\n          var lane = 1 << index2;\n          var eventTime = eventTimes[index2];\n          if (eventTime > mostRecentEventTime) {\n            mostRecentEventTime = eventTime;\n          }\n          lanes &= ~lane;\n        }\n        return mostRecentEventTime;\n      }\n      function computeExpirationTime(lane, currentTime) {\n        switch (lane) {\n          case SyncLane:\n          case InputContinuousHydrationLane:\n          case InputContinuousLane:\n            return currentTime + 250;\n          case DefaultHydrationLane:\n          case DefaultLane:\n          case TransitionHydrationLane:\n          case TransitionLane1:\n          case TransitionLane2:\n          case TransitionLane3:\n          case TransitionLane4:\n          case TransitionLane5:\n          case TransitionLane6:\n          case TransitionLane7:\n          case TransitionLane8:\n          case TransitionLane9:\n          case TransitionLane10:\n          case TransitionLane11:\n          case TransitionLane12:\n          case TransitionLane13:\n          case TransitionLane14:\n          case TransitionLane15:\n          case TransitionLane16:\n            return currentTime + 5000;\n          case RetryLane1:\n          case RetryLane2:\n          case RetryLane3:\n          case RetryLane4:\n          case RetryLane5:\n            return NoTimestamp;\n          case SelectiveHydrationLane:\n          case IdleHydrationLane:\n          case IdleLane:\n          case OffscreenLane:\n            return NoTimestamp;\n          default:\n            {\n              error(\"Should have found matching lanes. This is a bug in React.\");\n            }\n            return NoTimestamp;\n        }\n      }\n      function markStarvedLanesAsExpired(root2, currentTime) {\n        var pendingLanes = root2.pendingLanes;\n        var suspendedLanes = root2.suspendedLanes;\n        var pingedLanes = root2.pingedLanes;\n        var expirationTimes = root2.expirationTimes;\n        var lanes = pendingLanes;\n        while (lanes > 0) {\n          var index2 = pickArbitraryLaneIndex(lanes);\n          var lane = 1 << index2;\n          var expirationTime = expirationTimes[index2];\n          if (expirationTime === NoTimestamp) {\n            if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {\n              expirationTimes[index2] = computeExpirationTime(lane, currentTime);\n            }\n          } else if (expirationTime <= currentTime) {\n            root2.expiredLanes |= lane;\n          }\n          lanes &= ~lane;\n        }\n      }\n      function getHighestPriorityPendingLanes(root2) {\n        return getHighestPriorityLanes(root2.pendingLanes);\n      }\n      function getLanesToRetrySynchronouslyOnError(root2) {\n        var everythingButOffscreen = root2.pendingLanes & ~OffscreenLane;\n        if (everythingButOffscreen !== NoLanes) {\n          return everythingButOffscreen;\n        }\n        if (everythingButOffscreen & OffscreenLane) {\n          return OffscreenLane;\n        }\n        return NoLanes;\n      }\n      function includesSyncLane(lanes) {\n        return (lanes & SyncLane) !== NoLanes;\n      }\n      function includesNonIdleWork(lanes) {\n        return (lanes & NonIdleLanes) !== NoLanes;\n      }\n      function includesOnlyRetries(lanes) {\n        return (lanes & RetryLanes) === lanes;\n      }\n      function includesOnlyNonUrgentLanes(lanes) {\n        var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;\n        return (lanes & UrgentLanes) === NoLanes;\n      }\n      function includesOnlyTransitions(lanes) {\n        return (lanes & TransitionLanes) === lanes;\n      }\n      function includesBlockingLane(root2, lanes) {\n        var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;\n        return (lanes & SyncDefaultLanes) !== NoLanes;\n      }\n      function includesExpiredLane(root2, lanes) {\n        return (lanes & root2.expiredLanes) !== NoLanes;\n      }\n      function isTransitionLane(lane) {\n        return (lane & TransitionLanes) !== NoLanes;\n      }\n      function claimNextTransitionLane() {\n        var lane = nextTransitionLane;\n        nextTransitionLane <<= 1;\n        if ((nextTransitionLane & TransitionLanes) === NoLanes) {\n          nextTransitionLane = TransitionLane1;\n        }\n        return lane;\n      }\n      function claimNextRetryLane() {\n        var lane = nextRetryLane;\n        nextRetryLane <<= 1;\n        if ((nextRetryLane & RetryLanes) === NoLanes) {\n          nextRetryLane = RetryLane1;\n        }\n        return lane;\n      }\n      function getHighestPriorityLane(lanes) {\n        return lanes & -lanes;\n      }\n      function pickArbitraryLane(lanes) {\n        return getHighestPriorityLane(lanes);\n      }\n      function pickArbitraryLaneIndex(lanes) {\n        return 31 - clz32(lanes);\n      }\n      function laneToIndex(lane) {\n        return pickArbitraryLaneIndex(lane);\n      }\n      function includesSomeLane(a, b) {\n        return (a & b) !== NoLanes;\n      }\n      function isSubsetOfLanes(set2, subset) {\n        return (set2 & subset) === subset;\n      }\n      function mergeLanes(a, b) {\n        return a | b;\n      }\n      function removeLanes(set2, subset) {\n        return set2 & ~subset;\n      }\n      function intersectLanes(a, b) {\n        return a & b;\n      }\n      function laneToLanes(lane) {\n        return lane;\n      }\n      function higherPriorityLane(a, b) {\n        return a !== NoLane && a < b ? a : b;\n      }\n      function createLaneMap(initial) {\n        var laneMap = [];\n        for (var i = 0;i < TotalLanes; i++) {\n          laneMap.push(initial);\n        }\n        return laneMap;\n      }\n      function markRootUpdated(root2, updateLane, eventTime) {\n        root2.pendingLanes |= updateLane;\n        if (updateLane !== IdleLane) {\n          root2.suspendedLanes = NoLanes;\n          root2.pingedLanes = NoLanes;\n        }\n        var eventTimes = root2.eventTimes;\n        var index2 = laneToIndex(updateLane);\n        eventTimes[index2] = eventTime;\n      }\n      function markRootSuspended(root2, suspendedLanes) {\n        root2.suspendedLanes |= suspendedLanes;\n        root2.pingedLanes &= ~suspendedLanes;\n        var expirationTimes = root2.expirationTimes;\n        var lanes = suspendedLanes;\n        while (lanes > 0) {\n          var index2 = pickArbitraryLaneIndex(lanes);\n          var lane = 1 << index2;\n          expirationTimes[index2] = NoTimestamp;\n          lanes &= ~lane;\n        }\n      }\n      function markRootPinged(root2, pingedLanes, eventTime) {\n        root2.pingedLanes |= root2.suspendedLanes & pingedLanes;\n      }\n      function markRootFinished(root2, remainingLanes) {\n        var noLongerPendingLanes = root2.pendingLanes & ~remainingLanes;\n        root2.pendingLanes = remainingLanes;\n        root2.suspendedLanes = NoLanes;\n        root2.pingedLanes = NoLanes;\n        root2.expiredLanes &= remainingLanes;\n        root2.mutableReadLanes &= remainingLanes;\n        root2.entangledLanes &= remainingLanes;\n        var entanglements = root2.entanglements;\n        var eventTimes = root2.eventTimes;\n        var expirationTimes = root2.expirationTimes;\n        var lanes = noLongerPendingLanes;\n        while (lanes > 0) {\n          var index2 = pickArbitraryLaneIndex(lanes);\n          var lane = 1 << index2;\n          entanglements[index2] = NoLanes;\n          eventTimes[index2] = NoTimestamp;\n          expirationTimes[index2] = NoTimestamp;\n          lanes &= ~lane;\n        }\n      }\n      function markRootEntangled(root2, entangledLanes) {\n        var rootEntangledLanes = root2.entangledLanes |= entangledLanes;\n        var entanglements = root2.entanglements;\n        var lanes = rootEntangledLanes;\n        while (lanes) {\n          var index2 = pickArbitraryLaneIndex(lanes);\n          var lane = 1 << index2;\n          if (lane & entangledLanes | entanglements[index2] & entangledLanes) {\n            entanglements[index2] |= entangledLanes;\n          }\n          lanes &= ~lane;\n        }\n      }\n      function getBumpedLaneForHydration(root2, renderLanes2) {\n        var renderLane = getHighestPriorityLane(renderLanes2);\n        var lane;\n        switch (renderLane) {\n          case InputContinuousLane:\n            lane = InputContinuousHydrationLane;\n            break;\n          case DefaultLane:\n            lane = DefaultHydrationLane;\n            break;\n          case TransitionLane1:\n          case TransitionLane2:\n          case TransitionLane3:\n          case TransitionLane4:\n          case TransitionLane5:\n          case TransitionLane6:\n          case TransitionLane7:\n          case TransitionLane8:\n          case TransitionLane9:\n          case TransitionLane10:\n          case TransitionLane11:\n          case TransitionLane12:\n          case TransitionLane13:\n          case TransitionLane14:\n          case TransitionLane15:\n          case TransitionLane16:\n          case RetryLane1:\n          case RetryLane2:\n          case RetryLane3:\n          case RetryLane4:\n          case RetryLane5:\n            lane = TransitionHydrationLane;\n            break;\n          case IdleLane:\n            lane = IdleHydrationLane;\n            break;\n          default:\n            lane = NoLane;\n            break;\n        }\n        if ((lane & (root2.suspendedLanes | renderLanes2)) !== NoLane) {\n          return NoLane;\n        }\n        return lane;\n      }\n      function addFiberToLanesMap(root2, fiber, lanes) {\n        if (!isDevToolsPresent) {\n          return;\n        }\n        var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap;\n        while (lanes > 0) {\n          var index2 = laneToIndex(lanes);\n          var lane = 1 << index2;\n          var updaters = pendingUpdatersLaneMap[index2];\n          updaters.add(fiber);\n          lanes &= ~lane;\n        }\n      }\n      function movePendingFibersToMemoized(root2, lanes) {\n        if (!isDevToolsPresent) {\n          return;\n        }\n        var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap;\n        var memoizedUpdaters = root2.memoizedUpdaters;\n        while (lanes > 0) {\n          var index2 = laneToIndex(lanes);\n          var lane = 1 << index2;\n          var updaters = pendingUpdatersLaneMap[index2];\n          if (updaters.size > 0) {\n            updaters.forEach(function(fiber) {\n              var alternate = fiber.alternate;\n              if (alternate === null || !memoizedUpdaters.has(alternate)) {\n                memoizedUpdaters.add(fiber);\n              }\n            });\n            updaters.clear();\n          }\n          lanes &= ~lane;\n        }\n      }\n      function getTransitionsForLanes(root2, lanes) {\n        {\n          return null;\n        }\n      }\n      var DiscreteEventPriority = SyncLane;\n      var ContinuousEventPriority = InputContinuousLane;\n      var DefaultEventPriority = DefaultLane;\n      var IdleEventPriority = IdleLane;\n      var currentUpdatePriority = NoLane;\n      function getCurrentUpdatePriority() {\n        return currentUpdatePriority;\n      }\n      function setCurrentUpdatePriority(newPriority) {\n        currentUpdatePriority = newPriority;\n      }\n      function runWithPriority(priority, fn) {\n        var previousPriority = currentUpdatePriority;\n        try {\n          currentUpdatePriority = priority;\n          return fn();\n        } finally {\n          currentUpdatePriority = previousPriority;\n        }\n      }\n      function higherEventPriority(a, b) {\n        return a !== 0 && a < b ? a : b;\n      }\n      function lowerEventPriority(a, b) {\n        return a === 0 || a > b ? a : b;\n      }\n      function isHigherEventPriority(a, b) {\n        return a !== 0 && a < b;\n      }\n      function lanesToEventPriority(lanes) {\n        var lane = getHighestPriorityLane(lanes);\n        if (!isHigherEventPriority(DiscreteEventPriority, lane)) {\n          return DiscreteEventPriority;\n        }\n        if (!isHigherEventPriority(ContinuousEventPriority, lane)) {\n          return ContinuousEventPriority;\n        }\n        if (includesNonIdleWork(lane)) {\n          return DefaultEventPriority;\n        }\n        return IdleEventPriority;\n      }\n      function isRootDehydrated(root2) {\n        var currentState = root2.current.memoizedState;\n        return currentState.isDehydrated;\n      }\n      var _attemptSynchronousHydration;\n      function setAttemptSynchronousHydration(fn) {\n        _attemptSynchronousHydration = fn;\n      }\n      function attemptSynchronousHydration(fiber) {\n        _attemptSynchronousHydration(fiber);\n      }\n      var attemptContinuousHydration;\n      function setAttemptContinuousHydration(fn) {\n        attemptContinuousHydration = fn;\n      }\n      var attemptHydrationAtCurrentPriority;\n      function setAttemptHydrationAtCurrentPriority(fn) {\n        attemptHydrationAtCurrentPriority = fn;\n      }\n      var getCurrentUpdatePriority$1;\n      function setGetCurrentUpdatePriority(fn) {\n        getCurrentUpdatePriority$1 = fn;\n      }\n      var attemptHydrationAtPriority;\n      function setAttemptHydrationAtPriority(fn) {\n        attemptHydrationAtPriority = fn;\n      }\n      var hasScheduledReplayAttempt = false;\n      var queuedDiscreteEvents = [];\n      var queuedFocus = null;\n      var queuedDrag = null;\n      var queuedMouse = null;\n      var queuedPointers = new Map;\n      var queuedPointerCaptures = new Map;\n      var queuedExplicitHydrationTargets = [];\n      var discreteReplayableEvents = [\n        \"mousedown\",\n        \"mouseup\",\n        \"touchcancel\",\n        \"touchend\",\n        \"touchstart\",\n        \"auxclick\",\n        \"dblclick\",\n        \"pointercancel\",\n        \"pointerdown\",\n        \"pointerup\",\n        \"dragend\",\n        \"dragstart\",\n        \"drop\",\n        \"compositionend\",\n        \"compositionstart\",\n        \"keydown\",\n        \"keypress\",\n        \"keyup\",\n        \"input\",\n        \"textInput\",\n        \"copy\",\n        \"cut\",\n        \"paste\",\n        \"click\",\n        \"change\",\n        \"contextmenu\",\n        \"reset\",\n        \"submit\"\n      ];\n      function isDiscreteEventThatRequiresHydration(eventType) {\n        return discreteReplayableEvents.indexOf(eventType) > -1;\n      }\n      function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n        return {\n          blockedOn,\n          domEventName,\n          eventSystemFlags,\n          nativeEvent,\n          targetContainers: [targetContainer]\n        };\n      }\n      function clearIfContinuousEvent(domEventName, nativeEvent) {\n        switch (domEventName) {\n          case \"focusin\":\n          case \"focusout\":\n            queuedFocus = null;\n            break;\n          case \"dragenter\":\n          case \"dragleave\":\n            queuedDrag = null;\n            break;\n          case \"mouseover\":\n          case \"mouseout\":\n            queuedMouse = null;\n            break;\n          case \"pointerover\":\n          case \"pointerout\": {\n            var pointerId = nativeEvent.pointerId;\n            queuedPointers.delete(pointerId);\n            break;\n          }\n          case \"gotpointercapture\":\n          case \"lostpointercapture\": {\n            var _pointerId = nativeEvent.pointerId;\n            queuedPointerCaptures.delete(_pointerId);\n            break;\n          }\n        }\n      }\n      function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n        if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {\n          var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);\n          if (blockedOn !== null) {\n            var _fiber2 = getInstanceFromNode(blockedOn);\n            if (_fiber2 !== null) {\n              attemptContinuousHydration(_fiber2);\n            }\n          }\n          return queuedEvent;\n        }\n        existingQueuedEvent.eventSystemFlags |= eventSystemFlags;\n        var targetContainers = existingQueuedEvent.targetContainers;\n        if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {\n          targetContainers.push(targetContainer);\n        }\n        return existingQueuedEvent;\n      }\n      function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n        switch (domEventName) {\n          case \"focusin\": {\n            var focusEvent = nativeEvent;\n            queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);\n            return true;\n          }\n          case \"dragenter\": {\n            var dragEvent = nativeEvent;\n            queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);\n            return true;\n          }\n          case \"mouseover\": {\n            var mouseEvent = nativeEvent;\n            queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);\n            return true;\n          }\n          case \"pointerover\": {\n            var pointerEvent = nativeEvent;\n            var pointerId = pointerEvent.pointerId;\n            queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));\n            return true;\n          }\n          case \"gotpointercapture\": {\n            var _pointerEvent = nativeEvent;\n            var _pointerId2 = _pointerEvent.pointerId;\n            queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));\n            return true;\n          }\n        }\n        return false;\n      }\n      function attemptExplicitHydrationTarget(queuedTarget) {\n        var targetInst = getClosestInstanceFromNode(queuedTarget.target);\n        if (targetInst !== null) {\n          var nearestMounted = getNearestMountedFiber(targetInst);\n          if (nearestMounted !== null) {\n            var tag = nearestMounted.tag;\n            if (tag === SuspenseComponent) {\n              var instance = getSuspenseInstanceFromFiber(nearestMounted);\n              if (instance !== null) {\n                queuedTarget.blockedOn = instance;\n                attemptHydrationAtPriority(queuedTarget.priority, function() {\n                  attemptHydrationAtCurrentPriority(nearestMounted);\n                });\n                return;\n              }\n            } else if (tag === HostRoot) {\n              var root2 = nearestMounted.stateNode;\n              if (isRootDehydrated(root2)) {\n                queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);\n                return;\n              }\n            }\n          }\n        }\n        queuedTarget.blockedOn = null;\n      }\n      function queueExplicitHydrationTarget(target) {\n        var updatePriority = getCurrentUpdatePriority$1();\n        var queuedTarget = {\n          blockedOn: null,\n          target,\n          priority: updatePriority\n        };\n        var i = 0;\n        for (;i < queuedExplicitHydrationTargets.length; i++) {\n          if (!isHigherEventPriority(updatePriority, queuedExplicitHydrationTargets[i].priority)) {\n            break;\n          }\n        }\n        queuedExplicitHydrationTargets.splice(i, 0, queuedTarget);\n        if (i === 0) {\n          attemptExplicitHydrationTarget(queuedTarget);\n        }\n      }\n      function attemptReplayContinuousQueuedEvent(queuedEvent) {\n        if (queuedEvent.blockedOn !== null) {\n          return false;\n        }\n        var targetContainers = queuedEvent.targetContainers;\n        while (targetContainers.length > 0) {\n          var targetContainer = targetContainers[0];\n          var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);\n          if (nextBlockedOn === null) {\n            {\n              var nativeEvent = queuedEvent.nativeEvent;\n              var nativeEventClone = new nativeEvent.constructor(nativeEvent.type, nativeEvent);\n              setReplayingEvent(nativeEventClone);\n              nativeEvent.target.dispatchEvent(nativeEventClone);\n              resetReplayingEvent();\n            }\n          } else {\n            var _fiber3 = getInstanceFromNode(nextBlockedOn);\n            if (_fiber3 !== null) {\n              attemptContinuousHydration(_fiber3);\n            }\n            queuedEvent.blockedOn = nextBlockedOn;\n            return false;\n          }\n          targetContainers.shift();\n        }\n        return true;\n      }\n      function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {\n        if (attemptReplayContinuousQueuedEvent(queuedEvent)) {\n          map.delete(key);\n        }\n      }\n      function replayUnblockedEvents() {\n        hasScheduledReplayAttempt = false;\n        if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {\n          queuedFocus = null;\n        }\n        if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {\n          queuedDrag = null;\n        }\n        if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {\n          queuedMouse = null;\n        }\n        queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);\n        queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);\n      }\n      function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {\n        if (queuedEvent.blockedOn === unblocked) {\n          queuedEvent.blockedOn = null;\n          if (!hasScheduledReplayAttempt) {\n            hasScheduledReplayAttempt = true;\n            Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);\n          }\n        }\n      }\n      function retryIfBlockedOn(unblocked) {\n        if (queuedDiscreteEvents.length > 0) {\n          scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);\n          for (var i = 1;i < queuedDiscreteEvents.length; i++) {\n            var queuedEvent = queuedDiscreteEvents[i];\n            if (queuedEvent.blockedOn === unblocked) {\n              queuedEvent.blockedOn = null;\n            }\n          }\n        }\n        if (queuedFocus !== null) {\n          scheduleCallbackIfUnblocked(queuedFocus, unblocked);\n        }\n        if (queuedDrag !== null) {\n          scheduleCallbackIfUnblocked(queuedDrag, unblocked);\n        }\n        if (queuedMouse !== null) {\n          scheduleCallbackIfUnblocked(queuedMouse, unblocked);\n        }\n        var unblock = function(queuedEvent2) {\n          return scheduleCallbackIfUnblocked(queuedEvent2, unblocked);\n        };\n        queuedPointers.forEach(unblock);\n        queuedPointerCaptures.forEach(unblock);\n        for (var _i = 0;_i < queuedExplicitHydrationTargets.length; _i++) {\n          var queuedTarget = queuedExplicitHydrationTargets[_i];\n          if (queuedTarget.blockedOn === unblocked) {\n            queuedTarget.blockedOn = null;\n          }\n        }\n        while (queuedExplicitHydrationTargets.length > 0) {\n          var nextExplicitTarget = queuedExplicitHydrationTargets[0];\n          if (nextExplicitTarget.blockedOn !== null) {\n            break;\n          } else {\n            attemptExplicitHydrationTarget(nextExplicitTarget);\n            if (nextExplicitTarget.blockedOn === null) {\n              queuedExplicitHydrationTargets.shift();\n            }\n          }\n        }\n      }\n      var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;\n      var _enabled = true;\n      function setEnabled(enabled) {\n        _enabled = !!enabled;\n      }\n      function isEnabled() {\n        return _enabled;\n      }\n      function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {\n        var eventPriority = getEventPriority(domEventName);\n        var listenerWrapper;\n        switch (eventPriority) {\n          case DiscreteEventPriority:\n            listenerWrapper = dispatchDiscreteEvent;\n            break;\n          case ContinuousEventPriority:\n            listenerWrapper = dispatchContinuousEvent;\n            break;\n          case DefaultEventPriority:\n          default:\n            listenerWrapper = dispatchEvent;\n            break;\n        }\n        return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);\n      }\n      function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {\n        var previousPriority = getCurrentUpdatePriority();\n        var prevTransition = ReactCurrentBatchConfig.transition;\n        ReactCurrentBatchConfig.transition = null;\n        try {\n          setCurrentUpdatePriority(DiscreteEventPriority);\n          dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);\n        } finally {\n          setCurrentUpdatePriority(previousPriority);\n          ReactCurrentBatchConfig.transition = prevTransition;\n        }\n      }\n      function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {\n        var previousPriority = getCurrentUpdatePriority();\n        var prevTransition = ReactCurrentBatchConfig.transition;\n        ReactCurrentBatchConfig.transition = null;\n        try {\n          setCurrentUpdatePriority(ContinuousEventPriority);\n          dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);\n        } finally {\n          setCurrentUpdatePriority(previousPriority);\n          ReactCurrentBatchConfig.transition = prevTransition;\n        }\n      }\n      function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n        if (!_enabled) {\n          return;\n        }\n        {\n          dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent);\n        }\n      }\n      function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n        var blockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);\n        if (blockedOn === null) {\n          dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);\n          clearIfContinuousEvent(domEventName, nativeEvent);\n          return;\n        }\n        if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {\n          nativeEvent.stopPropagation();\n          return;\n        }\n        clearIfContinuousEvent(domEventName, nativeEvent);\n        if (eventSystemFlags & IS_CAPTURE_PHASE && isDiscreteEventThatRequiresHydration(domEventName)) {\n          while (blockedOn !== null) {\n            var fiber = getInstanceFromNode(blockedOn);\n            if (fiber !== null) {\n              attemptSynchronousHydration(fiber);\n            }\n            var nextBlockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);\n            if (nextBlockedOn === null) {\n              dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);\n            }\n            if (nextBlockedOn === blockedOn) {\n              break;\n            }\n            blockedOn = nextBlockedOn;\n          }\n          if (blockedOn !== null) {\n            nativeEvent.stopPropagation();\n          }\n          return;\n        }\n        dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);\n      }\n      var return_targetInst = null;\n      function findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n        return_targetInst = null;\n        var nativeEventTarget = getEventTarget(nativeEvent);\n        var targetInst = getClosestInstanceFromNode(nativeEventTarget);\n        if (targetInst !== null) {\n          var nearestMounted = getNearestMountedFiber(targetInst);\n          if (nearestMounted === null) {\n            targetInst = null;\n          } else {\n            var tag = nearestMounted.tag;\n            if (tag === SuspenseComponent) {\n              var instance = getSuspenseInstanceFromFiber(nearestMounted);\n              if (instance !== null) {\n                return instance;\n              }\n              targetInst = null;\n            } else if (tag === HostRoot) {\n              var root2 = nearestMounted.stateNode;\n              if (isRootDehydrated(root2)) {\n                return getContainerFromFiber(nearestMounted);\n              }\n              targetInst = null;\n            } else if (nearestMounted !== targetInst) {\n              targetInst = null;\n            }\n          }\n        }\n        return_targetInst = targetInst;\n        return null;\n      }\n      function getEventPriority(domEventName) {\n        switch (domEventName) {\n          case \"cancel\":\n          case \"click\":\n          case \"close\":\n          case \"contextmenu\":\n          case \"copy\":\n          case \"cut\":\n          case \"auxclick\":\n          case \"dblclick\":\n          case \"dragend\":\n          case \"dragstart\":\n          case \"drop\":\n          case \"focusin\":\n          case \"focusout\":\n          case \"input\":\n          case \"invalid\":\n          case \"keydown\":\n          case \"keypress\":\n          case \"keyup\":\n          case \"mousedown\":\n          case \"mouseup\":\n          case \"paste\":\n          case \"pause\":\n          case \"play\":\n          case \"pointercancel\":\n          case \"pointerdown\":\n          case \"pointerup\":\n          case \"ratechange\":\n          case \"reset\":\n          case \"resize\":\n          case \"seeked\":\n          case \"submit\":\n          case \"touchcancel\":\n          case \"touchend\":\n          case \"touchstart\":\n          case \"volumechange\":\n          case \"change\":\n          case \"selectionchange\":\n          case \"textInput\":\n          case \"compositionstart\":\n          case \"compositionend\":\n          case \"compositionupdate\":\n          case \"beforeblur\":\n          case \"afterblur\":\n          case \"beforeinput\":\n          case \"blur\":\n          case \"fullscreenchange\":\n          case \"focus\":\n          case \"hashchange\":\n          case \"popstate\":\n          case \"select\":\n          case \"selectstart\":\n            return DiscreteEventPriority;\n          case \"drag\":\n          case \"dragenter\":\n          case \"dragexit\":\n          case \"dragleave\":\n          case \"dragover\":\n          case \"mousemove\":\n          case \"mouseout\":\n          case \"mouseover\":\n          case \"pointermove\":\n          case \"pointerout\":\n          case \"pointerover\":\n          case \"scroll\":\n          case \"toggle\":\n          case \"touchmove\":\n          case \"wheel\":\n          case \"mouseenter\":\n          case \"mouseleave\":\n          case \"pointerenter\":\n          case \"pointerleave\":\n            return ContinuousEventPriority;\n          case \"message\": {\n            var schedulerPriority = getCurrentPriorityLevel();\n            switch (schedulerPriority) {\n              case ImmediatePriority:\n                return DiscreteEventPriority;\n              case UserBlockingPriority:\n                return ContinuousEventPriority;\n              case NormalPriority:\n              case LowPriority:\n                return DefaultEventPriority;\n              case IdlePriority:\n                return IdleEventPriority;\n              default:\n                return DefaultEventPriority;\n            }\n          }\n          default:\n            return DefaultEventPriority;\n        }\n      }\n      function addEventBubbleListener(target, eventType, listener) {\n        target.addEventListener(eventType, listener, false);\n        return listener;\n      }\n      function addEventCaptureListener(target, eventType, listener) {\n        target.addEventListener(eventType, listener, true);\n        return listener;\n      }\n      function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive) {\n        target.addEventListener(eventType, listener, {\n          capture: true,\n          passive\n        });\n        return listener;\n      }\n      function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive) {\n        target.addEventListener(eventType, listener, {\n          passive\n        });\n        return listener;\n      }\n      var root = null;\n      var startText = null;\n      var fallbackText = null;\n      function initialize(nativeEventTarget) {\n        root = nativeEventTarget;\n        startText = getText();\n        return true;\n      }\n      function reset() {\n        root = null;\n        startText = null;\n        fallbackText = null;\n      }\n      function getData() {\n        if (fallbackText) {\n          return fallbackText;\n        }\n        var start;\n        var startValue = startText;\n        var startLength = startValue.length;\n        var end;\n        var endValue = getText();\n        var endLength = endValue.length;\n        for (start = 0;start < startLength; start++) {\n          if (startValue[start] !== endValue[start]) {\n            break;\n          }\n        }\n        var minEnd = startLength - start;\n        for (end = 1;end <= minEnd; end++) {\n          if (startValue[startLength - end] !== endValue[endLength - end]) {\n            break;\n          }\n        }\n        var sliceTail = end > 1 ? 1 - end : undefined;\n        fallbackText = endValue.slice(start, sliceTail);\n        return fallbackText;\n      }\n      function getText() {\n        if (\"value\" in root) {\n          return root.value;\n        }\n        return root.textContent;\n      }\n      function getEventCharCode(nativeEvent) {\n        var charCode;\n        var keyCode = nativeEvent.keyCode;\n        if (\"charCode\" in nativeEvent) {\n          charCode = nativeEvent.charCode;\n          if (charCode === 0 && keyCode === 13) {\n            charCode = 13;\n          }\n        } else {\n          charCode = keyCode;\n        }\n        if (charCode === 10) {\n          charCode = 13;\n        }\n        if (charCode >= 32 || charCode === 13) {\n          return charCode;\n        }\n        return 0;\n      }\n      function functionThatReturnsTrue() {\n        return true;\n      }\n      function functionThatReturnsFalse() {\n        return false;\n      }\n      function createSyntheticEvent(Interface) {\n        function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {\n          this._reactName = reactName;\n          this._targetInst = targetInst;\n          this.type = reactEventType;\n          this.nativeEvent = nativeEvent;\n          this.target = nativeEventTarget;\n          this.currentTarget = null;\n          for (var _propName in Interface) {\n            if (!Interface.hasOwnProperty(_propName)) {\n              continue;\n            }\n            var normalize = Interface[_propName];\n            if (normalize) {\n              this[_propName] = normalize(nativeEvent);\n            } else {\n              this[_propName] = nativeEvent[_propName];\n            }\n          }\n          var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;\n          if (defaultPrevented) {\n            this.isDefaultPrevented = functionThatReturnsTrue;\n          } else {\n            this.isDefaultPrevented = functionThatReturnsFalse;\n          }\n          this.isPropagationStopped = functionThatReturnsFalse;\n          return this;\n        }\n        assign(SyntheticBaseEvent.prototype, {\n          preventDefault: function() {\n            this.defaultPrevented = true;\n            var event = this.nativeEvent;\n            if (!event) {\n              return;\n            }\n            if (event.preventDefault) {\n              event.preventDefault();\n            } else if (typeof event.returnValue !== \"unknown\") {\n              event.returnValue = false;\n            }\n            this.isDefaultPrevented = functionThatReturnsTrue;\n          },\n          stopPropagation: function() {\n            var event = this.nativeEvent;\n            if (!event) {\n              return;\n            }\n            if (event.stopPropagation) {\n              event.stopPropagation();\n            } else if (typeof event.cancelBubble !== \"unknown\") {\n              event.cancelBubble = true;\n            }\n            this.isPropagationStopped = functionThatReturnsTrue;\n          },\n          persist: function() {},\n          isPersistent: functionThatReturnsTrue\n        });\n        return SyntheticBaseEvent;\n      }\n      var EventInterface = {\n        eventPhase: 0,\n        bubbles: 0,\n        cancelable: 0,\n        timeStamp: function(event) {\n          return event.timeStamp || Date.now();\n        },\n        defaultPrevented: 0,\n        isTrusted: 0\n      };\n      var SyntheticEvent = createSyntheticEvent(EventInterface);\n      var UIEventInterface = assign({}, EventInterface, {\n        view: 0,\n        detail: 0\n      });\n      var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);\n      var lastMovementX;\n      var lastMovementY;\n      var lastMouseEvent;\n      function updateMouseMovementPolyfillState(event) {\n        if (event !== lastMouseEvent) {\n          if (lastMouseEvent && event.type === \"mousemove\") {\n            lastMovementX = event.screenX - lastMouseEvent.screenX;\n            lastMovementY = event.screenY - lastMouseEvent.screenY;\n          } else {\n            lastMovementX = 0;\n            lastMovementY = 0;\n          }\n          lastMouseEvent = event;\n        }\n      }\n      var MouseEventInterface = assign({}, UIEventInterface, {\n        screenX: 0,\n        screenY: 0,\n        clientX: 0,\n        clientY: 0,\n        pageX: 0,\n        pageY: 0,\n        ctrlKey: 0,\n        shiftKey: 0,\n        altKey: 0,\n        metaKey: 0,\n        getModifierState: getEventModifierState,\n        button: 0,\n        buttons: 0,\n        relatedTarget: function(event) {\n          if (event.relatedTarget === undefined)\n            return event.fromElement === event.srcElement ? event.toElement : event.fromElement;\n          return event.relatedTarget;\n        },\n        movementX: function(event) {\n          if (\"movementX\" in event) {\n            return event.movementX;\n          }\n          updateMouseMovementPolyfillState(event);\n          return lastMovementX;\n        },\n        movementY: function(event) {\n          if (\"movementY\" in event) {\n            return event.movementY;\n          }\n          return lastMovementY;\n        }\n      });\n      var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);\n      var DragEventInterface = assign({}, MouseEventInterface, {\n        dataTransfer: 0\n      });\n      var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);\n      var FocusEventInterface = assign({}, UIEventInterface, {\n        relatedTarget: 0\n      });\n      var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);\n      var AnimationEventInterface = assign({}, EventInterface, {\n        animationName: 0,\n        elapsedTime: 0,\n        pseudoElement: 0\n      });\n      var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);\n      var ClipboardEventInterface = assign({}, EventInterface, {\n        clipboardData: function(event) {\n          return \"clipboardData\" in event ? event.clipboardData : window.clipboardData;\n        }\n      });\n      var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);\n      var CompositionEventInterface = assign({}, EventInterface, {\n        data: 0\n      });\n      var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);\n      var SyntheticInputEvent = SyntheticCompositionEvent;\n      var normalizeKey = {\n        Esc: \"Escape\",\n        Spacebar: \" \",\n        Left: \"ArrowLeft\",\n        Up: \"ArrowUp\",\n        Right: \"ArrowRight\",\n        Down: \"ArrowDown\",\n        Del: \"Delete\",\n        Win: \"OS\",\n        Menu: \"ContextMenu\",\n        Apps: \"ContextMenu\",\n        Scroll: \"ScrollLock\",\n        MozPrintableKey: \"Unidentified\"\n      };\n      var translateToKey = {\n        \"8\": \"Backspace\",\n        \"9\": \"Tab\",\n        \"12\": \"Clear\",\n        \"13\": \"Enter\",\n        \"16\": \"Shift\",\n        \"17\": \"Control\",\n        \"18\": \"Alt\",\n        \"19\": \"Pause\",\n        \"20\": \"CapsLock\",\n        \"27\": \"Escape\",\n        \"32\": \" \",\n        \"33\": \"PageUp\",\n        \"34\": \"PageDown\",\n        \"35\": \"End\",\n        \"36\": \"Home\",\n        \"37\": \"ArrowLeft\",\n        \"38\": \"ArrowUp\",\n        \"39\": \"ArrowRight\",\n        \"40\": \"ArrowDown\",\n        \"45\": \"Insert\",\n        \"46\": \"Delete\",\n        \"112\": \"F1\",\n        \"113\": \"F2\",\n        \"114\": \"F3\",\n        \"115\": \"F4\",\n        \"116\": \"F5\",\n        \"117\": \"F6\",\n        \"118\": \"F7\",\n        \"119\": \"F8\",\n        \"120\": \"F9\",\n        \"121\": \"F10\",\n        \"122\": \"F11\",\n        \"123\": \"F12\",\n        \"144\": \"NumLock\",\n        \"145\": \"ScrollLock\",\n        \"224\": \"Meta\"\n      };\n      function getEventKey(nativeEvent) {\n        if (nativeEvent.key) {\n          var key = normalizeKey[nativeEvent.key] || nativeEvent.key;\n          if (key !== \"Unidentified\") {\n            return key;\n          }\n        }\n        if (nativeEvent.type === \"keypress\") {\n          var charCode = getEventCharCode(nativeEvent);\n          return charCode === 13 ? \"Enter\" : String.fromCharCode(charCode);\n        }\n        if (nativeEvent.type === \"keydown\" || nativeEvent.type === \"keyup\") {\n          return translateToKey[nativeEvent.keyCode] || \"Unidentified\";\n        }\n        return \"\";\n      }\n      var modifierKeyToProp = {\n        Alt: \"altKey\",\n        Control: \"ctrlKey\",\n        Meta: \"metaKey\",\n        Shift: \"shiftKey\"\n      };\n      function modifierStateGetter(keyArg) {\n        var syntheticEvent = this;\n        var nativeEvent = syntheticEvent.nativeEvent;\n        if (nativeEvent.getModifierState) {\n          return nativeEvent.getModifierState(keyArg);\n        }\n        var keyProp = modifierKeyToProp[keyArg];\n        return keyProp ? !!nativeEvent[keyProp] : false;\n      }\n      function getEventModifierState(nativeEvent) {\n        return modifierStateGetter;\n      }\n      var KeyboardEventInterface = assign({}, UIEventInterface, {\n        key: getEventKey,\n        code: 0,\n        location: 0,\n        ctrlKey: 0,\n        shiftKey: 0,\n        altKey: 0,\n        metaKey: 0,\n        repeat: 0,\n        locale: 0,\n        getModifierState: getEventModifierState,\n        charCode: function(event) {\n          if (event.type === \"keypress\") {\n            return getEventCharCode(event);\n          }\n          return 0;\n        },\n        keyCode: function(event) {\n          if (event.type === \"keydown\" || event.type === \"keyup\") {\n            return event.keyCode;\n          }\n          return 0;\n        },\n        which: function(event) {\n          if (event.type === \"keypress\") {\n            return getEventCharCode(event);\n          }\n          if (event.type === \"keydown\" || event.type === \"keyup\") {\n            return event.keyCode;\n          }\n          return 0;\n        }\n      });\n      var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);\n      var PointerEventInterface = assign({}, MouseEventInterface, {\n        pointerId: 0,\n        width: 0,\n        height: 0,\n        pressure: 0,\n        tangentialPressure: 0,\n        tiltX: 0,\n        tiltY: 0,\n        twist: 0,\n        pointerType: 0,\n        isPrimary: 0\n      });\n      var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);\n      var TouchEventInterface = assign({}, UIEventInterface, {\n        touches: 0,\n        targetTouches: 0,\n        changedTouches: 0,\n        altKey: 0,\n        metaKey: 0,\n        ctrlKey: 0,\n        shiftKey: 0,\n        getModifierState: getEventModifierState\n      });\n      var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);\n      var TransitionEventInterface = assign({}, EventInterface, {\n        propertyName: 0,\n        elapsedTime: 0,\n        pseudoElement: 0\n      });\n      var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);\n      var WheelEventInterface = assign({}, MouseEventInterface, {\n        deltaX: function(event) {\n          return \"deltaX\" in event ? event.deltaX : (\"wheelDeltaX\" in event) ? -event.wheelDeltaX : 0;\n        },\n        deltaY: function(event) {\n          return \"deltaY\" in event ? event.deltaY : (\"wheelDeltaY\" in event) ? -event.wheelDeltaY : (\"wheelDelta\" in event) ? -event.wheelDelta : 0;\n        },\n        deltaZ: 0,\n        deltaMode: 0\n      });\n      var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);\n      var END_KEYCODES = [9, 13, 27, 32];\n      var START_KEYCODE = 229;\n      var canUseCompositionEvent = canUseDOM && \"CompositionEvent\" in window;\n      var documentMode = null;\n      if (canUseDOM && \"documentMode\" in document) {\n        documentMode = document.documentMode;\n      }\n      var canUseTextInputEvent = canUseDOM && \"TextEvent\" in window && !documentMode;\n      var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);\n      var SPACEBAR_CODE = 32;\n      var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);\n      function registerEvents() {\n        registerTwoPhaseEvent(\"onBeforeInput\", [\"compositionend\", \"keypress\", \"textInput\", \"paste\"]);\n        registerTwoPhaseEvent(\"onCompositionEnd\", [\"compositionend\", \"focusout\", \"keydown\", \"keypress\", \"keyup\", \"mousedown\"]);\n        registerTwoPhaseEvent(\"onCompositionStart\", [\"compositionstart\", \"focusout\", \"keydown\", \"keypress\", \"keyup\", \"mousedown\"]);\n        registerTwoPhaseEvent(\"onCompositionUpdate\", [\"compositionupdate\", \"focusout\", \"keydown\", \"keypress\", \"keyup\", \"mousedown\"]);\n      }\n      var hasSpaceKeypress = false;\n      function isKeypressCommand(nativeEvent) {\n        return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && !(nativeEvent.ctrlKey && nativeEvent.altKey);\n      }\n      function getCompositionEventType(domEventName) {\n        switch (domEventName) {\n          case \"compositionstart\":\n            return \"onCompositionStart\";\n          case \"compositionend\":\n            return \"onCompositionEnd\";\n          case \"compositionupdate\":\n            return \"onCompositionUpdate\";\n        }\n      }\n      function isFallbackCompositionStart(domEventName, nativeEvent) {\n        return domEventName === \"keydown\" && nativeEvent.keyCode === START_KEYCODE;\n      }\n      function isFallbackCompositionEnd(domEventName, nativeEvent) {\n        switch (domEventName) {\n          case \"keyup\":\n            return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;\n          case \"keydown\":\n            return nativeEvent.keyCode !== START_KEYCODE;\n          case \"keypress\":\n          case \"mousedown\":\n          case \"focusout\":\n            return true;\n          default:\n            return false;\n        }\n      }\n      function getDataFromCustomEvent(nativeEvent) {\n        var detail = nativeEvent.detail;\n        if (typeof detail === \"object\" && \"data\" in detail) {\n          return detail.data;\n        }\n        return null;\n      }\n      function isUsingKoreanIME(nativeEvent) {\n        return nativeEvent.locale === \"ko\";\n      }\n      var isComposing = false;\n      function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {\n        var eventType;\n        var fallbackData;\n        if (canUseCompositionEvent) {\n          eventType = getCompositionEventType(domEventName);\n        } else if (!isComposing) {\n          if (isFallbackCompositionStart(domEventName, nativeEvent)) {\n            eventType = \"onCompositionStart\";\n          }\n        } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {\n          eventType = \"onCompositionEnd\";\n        }\n        if (!eventType) {\n          return null;\n        }\n        if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {\n          if (!isComposing && eventType === \"onCompositionStart\") {\n            isComposing = initialize(nativeEventTarget);\n          } else if (eventType === \"onCompositionEnd\") {\n            if (isComposing) {\n              fallbackData = getData();\n            }\n          }\n        }\n        var listeners = accumulateTwoPhaseListeners(targetInst, eventType);\n        if (listeners.length > 0) {\n          var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);\n          dispatchQueue.push({\n            event,\n            listeners\n          });\n          if (fallbackData) {\n            event.data = fallbackData;\n          } else {\n            var customData = getDataFromCustomEvent(nativeEvent);\n            if (customData !== null) {\n              event.data = customData;\n            }\n          }\n        }\n      }\n      function getNativeBeforeInputChars(domEventName, nativeEvent) {\n        switch (domEventName) {\n          case \"compositionend\":\n            return getDataFromCustomEvent(nativeEvent);\n          case \"keypress\":\n            var which = nativeEvent.which;\n            if (which !== SPACEBAR_CODE) {\n              return null;\n            }\n            hasSpaceKeypress = true;\n            return SPACEBAR_CHAR;\n          case \"textInput\":\n            var chars = nativeEvent.data;\n            if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {\n              return null;\n            }\n            return chars;\n          default:\n            return null;\n        }\n      }\n      function getFallbackBeforeInputChars(domEventName, nativeEvent) {\n        if (isComposing) {\n          if (domEventName === \"compositionend\" || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {\n            var chars = getData();\n            reset();\n            isComposing = false;\n            return chars;\n          }\n          return null;\n        }\n        switch (domEventName) {\n          case \"paste\":\n            return null;\n          case \"keypress\":\n            if (!isKeypressCommand(nativeEvent)) {\n              if (nativeEvent.char && nativeEvent.char.length > 1) {\n                return nativeEvent.char;\n              } else if (nativeEvent.which) {\n                return String.fromCharCode(nativeEvent.which);\n              }\n            }\n            return null;\n          case \"compositionend\":\n            return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;\n          default:\n            return null;\n        }\n      }\n      function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {\n        var chars;\n        if (canUseTextInputEvent) {\n          chars = getNativeBeforeInputChars(domEventName, nativeEvent);\n        } else {\n          chars = getFallbackBeforeInputChars(domEventName, nativeEvent);\n        }\n        if (!chars) {\n          return null;\n        }\n        var listeners = accumulateTwoPhaseListeners(targetInst, \"onBeforeInput\");\n        if (listeners.length > 0) {\n          var event = new SyntheticInputEvent(\"onBeforeInput\", \"beforeinput\", null, nativeEvent, nativeEventTarget);\n          dispatchQueue.push({\n            event,\n            listeners\n          });\n          event.data = chars;\n        }\n      }\n      function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\n        extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\n        extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\n      }\n      var supportedInputTypes = {\n        color: true,\n        date: true,\n        datetime: true,\n        \"datetime-local\": true,\n        email: true,\n        month: true,\n        number: true,\n        password: true,\n        range: true,\n        search: true,\n        tel: true,\n        text: true,\n        time: true,\n        url: true,\n        week: true\n      };\n      function isTextInputElement(elem) {\n        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n        if (nodeName === \"input\") {\n          return !!supportedInputTypes[elem.type];\n        }\n        if (nodeName === \"textarea\") {\n          return true;\n        }\n        return false;\n      }\n      function isEventSupported(eventNameSuffix) {\n        if (!canUseDOM) {\n          return false;\n        }\n        var eventName = \"on\" + eventNameSuffix;\n        var isSupported = eventName in document;\n        if (!isSupported) {\n          var element = document.createElement(\"div\");\n          element.setAttribute(eventName, \"return;\");\n          isSupported = typeof element[eventName] === \"function\";\n        }\n        return isSupported;\n      }\n      function registerEvents$1() {\n        registerTwoPhaseEvent(\"onChange\", [\"change\", \"click\", \"focusin\", \"focusout\", \"input\", \"keydown\", \"keyup\", \"selectionchange\"]);\n      }\n      function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {\n        enqueueStateRestore(target);\n        var listeners = accumulateTwoPhaseListeners(inst, \"onChange\");\n        if (listeners.length > 0) {\n          var event = new SyntheticEvent(\"onChange\", \"change\", null, nativeEvent, target);\n          dispatchQueue.push({\n            event,\n            listeners\n          });\n        }\n      }\n      var activeElement = null;\n      var activeElementInst = null;\n      function shouldUseChangeEvent(elem) {\n        var nodeName = elem.nodeName && elem.nodeName.toLowerCase();\n        return nodeName === \"select\" || nodeName === \"input\" && elem.type === \"file\";\n      }\n      function manualDispatchChangeEvent(nativeEvent) {\n        var dispatchQueue = [];\n        createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent));\n        batchedUpdates(runEventInBatch, dispatchQueue);\n      }\n      function runEventInBatch(dispatchQueue) {\n        processDispatchQueue(dispatchQueue, 0);\n      }\n      function getInstIfValueChanged(targetInst) {\n        var targetNode = getNodeFromInstance(targetInst);\n        if (updateValueIfChanged(targetNode)) {\n          return targetInst;\n        }\n      }\n      function getTargetInstForChangeEvent(domEventName, targetInst) {\n        if (domEventName === \"change\") {\n          return targetInst;\n        }\n      }\n      var isInputEventSupported = false;\n      if (canUseDOM) {\n        isInputEventSupported = isEventSupported(\"input\") && (!document.documentMode || document.documentMode > 9);\n      }\n      function startWatchingForValueChange(target, targetInst) {\n        activeElement = target;\n        activeElementInst = targetInst;\n        activeElement.attachEvent(\"onpropertychange\", handlePropertyChange);\n      }\n      function stopWatchingForValueChange() {\n        if (!activeElement) {\n          return;\n        }\n        activeElement.detachEvent(\"onpropertychange\", handlePropertyChange);\n        activeElement = null;\n        activeElementInst = null;\n      }\n      function handlePropertyChange(nativeEvent) {\n        if (nativeEvent.propertyName !== \"value\") {\n          return;\n        }\n        if (getInstIfValueChanged(activeElementInst)) {\n          manualDispatchChangeEvent(nativeEvent);\n        }\n      }\n      function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {\n        if (domEventName === \"focusin\") {\n          stopWatchingForValueChange();\n          startWatchingForValueChange(target, targetInst);\n        } else if (domEventName === \"focusout\") {\n          stopWatchingForValueChange();\n        }\n      }\n      function getTargetInstForInputEventPolyfill(domEventName, targetInst) {\n        if (domEventName === \"selectionchange\" || domEventName === \"keyup\" || domEventName === \"keydown\") {\n          return getInstIfValueChanged(activeElementInst);\n        }\n      }\n      function shouldUseClickEvent(elem) {\n        var nodeName = elem.nodeName;\n        return nodeName && nodeName.toLowerCase() === \"input\" && (elem.type === \"checkbox\" || elem.type === \"radio\");\n      }\n      function getTargetInstForClickEvent(domEventName, targetInst) {\n        if (domEventName === \"click\") {\n          return getInstIfValueChanged(targetInst);\n        }\n      }\n      function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {\n        if (domEventName === \"input\" || domEventName === \"change\") {\n          return getInstIfValueChanged(targetInst);\n        }\n      }\n      function handleControlledInputBlur(node) {\n        var state = node._wrapperState;\n        if (!state || !state.controlled || node.type !== \"number\") {\n          return;\n        }\n        {\n          setDefaultValue(node, \"number\", node.value);\n        }\n      }\n      function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\n        var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;\n        var getTargetInstFunc, handleEventFunc;\n        if (shouldUseChangeEvent(targetNode)) {\n          getTargetInstFunc = getTargetInstForChangeEvent;\n        } else if (isTextInputElement(targetNode)) {\n          if (isInputEventSupported) {\n            getTargetInstFunc = getTargetInstForInputOrChangeEvent;\n          } else {\n            getTargetInstFunc = getTargetInstForInputEventPolyfill;\n            handleEventFunc = handleEventsForInputEventPolyfill;\n          }\n        } else if (shouldUseClickEvent(targetNode)) {\n          getTargetInstFunc = getTargetInstForClickEvent;\n        }\n        if (getTargetInstFunc) {\n          var inst = getTargetInstFunc(domEventName, targetInst);\n          if (inst) {\n            createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);\n            return;\n          }\n        }\n        if (handleEventFunc) {\n          handleEventFunc(domEventName, targetNode, targetInst);\n        }\n        if (domEventName === \"focusout\") {\n          handleControlledInputBlur(targetNode);\n        }\n      }\n      function registerEvents$2() {\n        registerDirectEvent(\"onMouseEnter\", [\"mouseout\", \"mouseover\"]);\n        registerDirectEvent(\"onMouseLeave\", [\"mouseout\", \"mouseover\"]);\n        registerDirectEvent(\"onPointerEnter\", [\"pointerout\", \"pointerover\"]);\n        registerDirectEvent(\"onPointerLeave\", [\"pointerout\", \"pointerover\"]);\n      }\n      function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\n        var isOverEvent = domEventName === \"mouseover\" || domEventName === \"pointerover\";\n        var isOutEvent = domEventName === \"mouseout\" || domEventName === \"pointerout\";\n        if (isOverEvent && !isReplayingEvent(nativeEvent)) {\n          var related = nativeEvent.relatedTarget || nativeEvent.fromElement;\n          if (related) {\n            if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {\n              return;\n            }\n          }\n        }\n        if (!isOutEvent && !isOverEvent) {\n          return;\n        }\n        var win;\n        if (nativeEventTarget.window === nativeEventTarget) {\n          win = nativeEventTarget;\n        } else {\n          var doc = nativeEventTarget.ownerDocument;\n          if (doc) {\n            win = doc.defaultView || doc.parentWindow;\n          } else {\n            win = window;\n          }\n        }\n        var from;\n        var to;\n        if (isOutEvent) {\n          var _related = nativeEvent.relatedTarget || nativeEvent.toElement;\n          from = targetInst;\n          to = _related ? getClosestInstanceFromNode(_related) : null;\n          if (to !== null) {\n            var nearestMounted = getNearestMountedFiber(to);\n            if (to !== nearestMounted || to.tag !== HostComponent && to.tag !== HostText) {\n              to = null;\n            }\n          }\n        } else {\n          from = null;\n          to = targetInst;\n        }\n        if (from === to) {\n          return;\n        }\n        var SyntheticEventCtor = SyntheticMouseEvent;\n        var leaveEventType = \"onMouseLeave\";\n        var enterEventType = \"onMouseEnter\";\n        var eventTypePrefix = \"mouse\";\n        if (domEventName === \"pointerout\" || domEventName === \"pointerover\") {\n          SyntheticEventCtor = SyntheticPointerEvent;\n          leaveEventType = \"onPointerLeave\";\n          enterEventType = \"onPointerEnter\";\n          eventTypePrefix = \"pointer\";\n        }\n        var fromNode = from == null ? win : getNodeFromInstance(from);\n        var toNode = to == null ? win : getNodeFromInstance(to);\n        var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + \"leave\", from, nativeEvent, nativeEventTarget);\n        leave.target = fromNode;\n        leave.relatedTarget = toNode;\n        var enter = null;\n        var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);\n        if (nativeTargetInst === targetInst) {\n          var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + \"enter\", to, nativeEvent, nativeEventTarget);\n          enterEvent.target = toNode;\n          enterEvent.relatedTarget = fromNode;\n          enter = enterEvent;\n        }\n        accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from, to);\n      }\n      function is(x, y) {\n        return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;\n      }\n      var objectIs = typeof Object.is === \"function\" ? Object.is : is;\n      function shallowEqual(objA, objB) {\n        if (objectIs(objA, objB)) {\n          return true;\n        }\n        if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n          return false;\n        }\n        var keysA = Object.keys(objA);\n        var keysB = Object.keys(objB);\n        if (keysA.length !== keysB.length) {\n          return false;\n        }\n        for (var i = 0;i < keysA.length; i++) {\n          var currentKey = keysA[i];\n          if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {\n            return false;\n          }\n        }\n        return true;\n      }\n      function getLeafNode(node) {\n        while (node && node.firstChild) {\n          node = node.firstChild;\n        }\n        return node;\n      }\n      function getSiblingNode(node) {\n        while (node) {\n          if (node.nextSibling) {\n            return node.nextSibling;\n          }\n          node = node.parentNode;\n        }\n      }\n      function getNodeForCharacterOffset(root2, offset) {\n        var node = getLeafNode(root2);\n        var nodeStart = 0;\n        var nodeEnd = 0;\n        while (node) {\n          if (node.nodeType === TEXT_NODE) {\n            nodeEnd = nodeStart + node.textContent.length;\n            if (nodeStart <= offset && nodeEnd >= offset) {\n              return {\n                node,\n                offset: offset - nodeStart\n              };\n            }\n            nodeStart = nodeEnd;\n          }\n          node = getLeafNode(getSiblingNode(node));\n        }\n      }\n      function getOffsets(outerNode) {\n        var ownerDocument = outerNode.ownerDocument;\n        var win = ownerDocument && ownerDocument.defaultView || window;\n        var selection = win.getSelection && win.getSelection();\n        if (!selection || selection.rangeCount === 0) {\n          return null;\n        }\n        var { anchorNode, anchorOffset, focusNode, focusOffset } = selection;\n        try {\n          anchorNode.nodeType;\n          focusNode.nodeType;\n        } catch (e) {\n          return null;\n        }\n        return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);\n      }\n      function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {\n        var length = 0;\n        var start = -1;\n        var end = -1;\n        var indexWithinAnchor = 0;\n        var indexWithinFocus = 0;\n        var node = outerNode;\n        var parentNode = null;\n        outer:\n          while (true) {\n            var next = null;\n            while (true) {\n              if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {\n                start = length + anchorOffset;\n              }\n              if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {\n                end = length + focusOffset;\n              }\n              if (node.nodeType === TEXT_NODE) {\n                length += node.nodeValue.length;\n              }\n              if ((next = node.firstChild) === null) {\n                break;\n              }\n              parentNode = node;\n              node = next;\n            }\n            while (true) {\n              if (node === outerNode) {\n                break outer;\n              }\n              if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {\n                start = length;\n              }\n              if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {\n                end = length;\n              }\n              if ((next = node.nextSibling) !== null) {\n                break;\n              }\n              node = parentNode;\n              parentNode = node.parentNode;\n            }\n            node = next;\n          }\n        if (start === -1 || end === -1) {\n          return null;\n        }\n        return {\n          start,\n          end\n        };\n      }\n      function setOffsets(node, offsets) {\n        var doc = node.ownerDocument || document;\n        var win = doc && doc.defaultView || window;\n        if (!win.getSelection) {\n          return;\n        }\n        var selection = win.getSelection();\n        var length = node.textContent.length;\n        var start = Math.min(offsets.start, length);\n        var end = offsets.end === undefined ? start : Math.min(offsets.end, length);\n        if (!selection.extend && start > end) {\n          var temp = end;\n          end = start;\n          start = temp;\n        }\n        var startMarker = getNodeForCharacterOffset(node, start);\n        var endMarker = getNodeForCharacterOffset(node, end);\n        if (startMarker && endMarker) {\n          if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {\n            return;\n          }\n          var range = doc.createRange();\n          range.setStart(startMarker.node, startMarker.offset);\n          selection.removeAllRanges();\n          if (start > end) {\n            selection.addRange(range);\n            selection.extend(endMarker.node, endMarker.offset);\n          } else {\n            range.setEnd(endMarker.node, endMarker.offset);\n            selection.addRange(range);\n          }\n        }\n      }\n      function isTextNode(node) {\n        return node && node.nodeType === TEXT_NODE;\n      }\n      function containsNode(outerNode, innerNode) {\n        if (!outerNode || !innerNode) {\n          return false;\n        } else if (outerNode === innerNode) {\n          return true;\n        } else if (isTextNode(outerNode)) {\n          return false;\n        } else if (isTextNode(innerNode)) {\n          return containsNode(outerNode, innerNode.parentNode);\n        } else if (\"contains\" in outerNode) {\n          return outerNode.contains(innerNode);\n        } else if (outerNode.compareDocumentPosition) {\n          return !!(outerNode.compareDocumentPosition(innerNode) & 16);\n        } else {\n          return false;\n        }\n      }\n      function isInDocument(node) {\n        return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);\n      }\n      function isSameOriginFrame(iframe) {\n        try {\n          return typeof iframe.contentWindow.location.href === \"string\";\n        } catch (err) {\n          return false;\n        }\n      }\n      function getActiveElementDeep() {\n        var win = window;\n        var element = getActiveElement();\n        while (element instanceof win.HTMLIFrameElement) {\n          if (isSameOriginFrame(element)) {\n            win = element.contentWindow;\n          } else {\n            return element;\n          }\n          element = getActiveElement(win.document);\n        }\n        return element;\n      }\n      function hasSelectionCapabilities(elem) {\n        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n        return nodeName && (nodeName === \"input\" && (elem.type === \"text\" || elem.type === \"search\" || elem.type === \"tel\" || elem.type === \"url\" || elem.type === \"password\") || nodeName === \"textarea\" || elem.contentEditable === \"true\");\n      }\n      function getSelectionInformation() {\n        var focusedElem = getActiveElementDeep();\n        return {\n          focusedElem,\n          selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null\n        };\n      }\n      function restoreSelection(priorSelectionInformation) {\n        var curFocusedElem = getActiveElementDeep();\n        var priorFocusedElem = priorSelectionInformation.focusedElem;\n        var priorSelectionRange = priorSelectionInformation.selectionRange;\n        if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {\n          if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {\n            setSelection(priorFocusedElem, priorSelectionRange);\n          }\n          var ancestors = [];\n          var ancestor = priorFocusedElem;\n          while (ancestor = ancestor.parentNode) {\n            if (ancestor.nodeType === ELEMENT_NODE) {\n              ancestors.push({\n                element: ancestor,\n                left: ancestor.scrollLeft,\n                top: ancestor.scrollTop\n              });\n            }\n          }\n          if (typeof priorFocusedElem.focus === \"function\") {\n            priorFocusedElem.focus();\n          }\n          for (var i = 0;i < ancestors.length; i++) {\n            var info = ancestors[i];\n            info.element.scrollLeft = info.left;\n            info.element.scrollTop = info.top;\n          }\n        }\n      }\n      function getSelection(input) {\n        var selection;\n        if (\"selectionStart\" in input) {\n          selection = {\n            start: input.selectionStart,\n            end: input.selectionEnd\n          };\n        } else {\n          selection = getOffsets(input);\n        }\n        return selection || {\n          start: 0,\n          end: 0\n        };\n      }\n      function setSelection(input, offsets) {\n        var start = offsets.start;\n        var end = offsets.end;\n        if (end === undefined) {\n          end = start;\n        }\n        if (\"selectionStart\" in input) {\n          input.selectionStart = start;\n          input.selectionEnd = Math.min(end, input.value.length);\n        } else {\n          setOffsets(input, offsets);\n        }\n      }\n      var skipSelectionChangeEvent = canUseDOM && \"documentMode\" in document && document.documentMode <= 11;\n      function registerEvents$3() {\n        registerTwoPhaseEvent(\"onSelect\", [\"focusout\", \"contextmenu\", \"dragend\", \"focusin\", \"keydown\", \"keyup\", \"mousedown\", \"mouseup\", \"selectionchange\"]);\n      }\n      var activeElement$1 = null;\n      var activeElementInst$1 = null;\n      var lastSelection = null;\n      var mouseDown = false;\n      function getSelection$1(node) {\n        if (\"selectionStart\" in node && hasSelectionCapabilities(node)) {\n          return {\n            start: node.selectionStart,\n            end: node.selectionEnd\n          };\n        } else {\n          var win = node.ownerDocument && node.ownerDocument.defaultView || window;\n          var selection = win.getSelection();\n          return {\n            anchorNode: selection.anchorNode,\n            anchorOffset: selection.anchorOffset,\n            focusNode: selection.focusNode,\n            focusOffset: selection.focusOffset\n          };\n        }\n      }\n      function getEventTargetDocument(eventTarget) {\n        return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;\n      }\n      function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {\n        var doc = getEventTargetDocument(nativeEventTarget);\n        if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {\n          return;\n        }\n        var currentSelection = getSelection$1(activeElement$1);\n        if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {\n          lastSelection = currentSelection;\n          var listeners = accumulateTwoPhaseListeners(activeElementInst$1, \"onSelect\");\n          if (listeners.length > 0) {\n            var event = new SyntheticEvent(\"onSelect\", \"select\", null, nativeEvent, nativeEventTarget);\n            dispatchQueue.push({\n              event,\n              listeners\n            });\n            event.target = activeElement$1;\n          }\n        }\n      }\n      function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\n        var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;\n        switch (domEventName) {\n          case \"focusin\":\n            if (isTextInputElement(targetNode) || targetNode.contentEditable === \"true\") {\n              activeElement$1 = targetNode;\n              activeElementInst$1 = targetInst;\n              lastSelection = null;\n            }\n            break;\n          case \"focusout\":\n            activeElement$1 = null;\n            activeElementInst$1 = null;\n            lastSelection = null;\n            break;\n          case \"mousedown\":\n            mouseDown = true;\n            break;\n          case \"contextmenu\":\n          case \"mouseup\":\n          case \"dragend\":\n            mouseDown = false;\n            constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);\n            break;\n          case \"selectionchange\":\n            if (skipSelectionChangeEvent) {\n              break;\n            }\n          case \"keydown\":\n          case \"keyup\":\n            constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);\n        }\n      }\n      function makePrefixMap(styleProp, eventName) {\n        var prefixes2 = {};\n        prefixes2[styleProp.toLowerCase()] = eventName.toLowerCase();\n        prefixes2[\"Webkit\" + styleProp] = \"webkit\" + eventName;\n        prefixes2[\"Moz\" + styleProp] = \"moz\" + eventName;\n        return prefixes2;\n      }\n      var vendorPrefixes = {\n        animationend: makePrefixMap(\"Animation\", \"AnimationEnd\"),\n        animationiteration: makePrefixMap(\"Animation\", \"AnimationIteration\"),\n        animationstart: makePrefixMap(\"Animation\", \"AnimationStart\"),\n        transitionend: makePrefixMap(\"Transition\", \"TransitionEnd\")\n      };\n      var prefixedEventNames = {};\n      var style = {};\n      if (canUseDOM) {\n        style = document.createElement(\"div\").style;\n        if (!(\"AnimationEvent\" in window)) {\n          delete vendorPrefixes.animationend.animation;\n          delete vendorPrefixes.animationiteration.animation;\n          delete vendorPrefixes.animationstart.animation;\n        }\n        if (!(\"TransitionEvent\" in window)) {\n          delete vendorPrefixes.transitionend.transition;\n        }\n      }\n      function getVendorPrefixedEventName(eventName) {\n        if (prefixedEventNames[eventName]) {\n          return prefixedEventNames[eventName];\n        } else if (!vendorPrefixes[eventName]) {\n          return eventName;\n        }\n        var prefixMap = vendorPrefixes[eventName];\n        for (var styleProp in prefixMap) {\n          if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {\n            return prefixedEventNames[eventName] = prefixMap[styleProp];\n          }\n        }\n        return eventName;\n      }\n      var ANIMATION_END = getVendorPrefixedEventName(\"animationend\");\n      var ANIMATION_ITERATION = getVendorPrefixedEventName(\"animationiteration\");\n      var ANIMATION_START = getVendorPrefixedEventName(\"animationstart\");\n      var TRANSITION_END = getVendorPrefixedEventName(\"transitionend\");\n      var topLevelEventsToReactNames = new Map;\n      var simpleEventPluginEvents = [\"abort\", \"auxClick\", \"cancel\", \"canPlay\", \"canPlayThrough\", \"click\", \"close\", \"contextMenu\", \"copy\", \"cut\", \"drag\", \"dragEnd\", \"dragEnter\", \"dragExit\", \"dragLeave\", \"dragOver\", \"dragStart\", \"drop\", \"durationChange\", \"emptied\", \"encrypted\", \"ended\", \"error\", \"gotPointerCapture\", \"input\", \"invalid\", \"keyDown\", \"keyPress\", \"keyUp\", \"load\", \"loadedData\", \"loadedMetadata\", \"loadStart\", \"lostPointerCapture\", \"mouseDown\", \"mouseMove\", \"mouseOut\", \"mouseOver\", \"mouseUp\", \"paste\", \"pause\", \"play\", \"playing\", \"pointerCancel\", \"pointerDown\", \"pointerMove\", \"pointerOut\", \"pointerOver\", \"pointerUp\", \"progress\", \"rateChange\", \"reset\", \"resize\", \"seeked\", \"seeking\", \"stalled\", \"submit\", \"suspend\", \"timeUpdate\", \"touchCancel\", \"touchEnd\", \"touchStart\", \"volumeChange\", \"scroll\", \"toggle\", \"touchMove\", \"waiting\", \"wheel\"];\n      function registerSimpleEvent(domEventName, reactName) {\n        topLevelEventsToReactNames.set(domEventName, reactName);\n        registerTwoPhaseEvent(reactName, [domEventName]);\n      }\n      function registerSimpleEvents() {\n        for (var i = 0;i < simpleEventPluginEvents.length; i++) {\n          var eventName = simpleEventPluginEvents[i];\n          var domEventName = eventName.toLowerCase();\n          var capitalizedEvent = eventName[0].toUpperCase() + eventName.slice(1);\n          registerSimpleEvent(domEventName, \"on\" + capitalizedEvent);\n        }\n        registerSimpleEvent(ANIMATION_END, \"onAnimationEnd\");\n        registerSimpleEvent(ANIMATION_ITERATION, \"onAnimationIteration\");\n        registerSimpleEvent(ANIMATION_START, \"onAnimationStart\");\n        registerSimpleEvent(\"dblclick\", \"onDoubleClick\");\n        registerSimpleEvent(\"focusin\", \"onFocus\");\n        registerSimpleEvent(\"focusout\", \"onBlur\");\n        registerSimpleEvent(TRANSITION_END, \"onTransitionEnd\");\n      }\n      function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\n        var reactName = topLevelEventsToReactNames.get(domEventName);\n        if (reactName === undefined) {\n          return;\n        }\n        var SyntheticEventCtor = SyntheticEvent;\n        var reactEventType = domEventName;\n        switch (domEventName) {\n          case \"keypress\":\n            if (getEventCharCode(nativeEvent) === 0) {\n              return;\n            }\n          case \"keydown\":\n          case \"keyup\":\n            SyntheticEventCtor = SyntheticKeyboardEvent;\n            break;\n          case \"focusin\":\n            reactEventType = \"focus\";\n            SyntheticEventCtor = SyntheticFocusEvent;\n            break;\n          case \"focusout\":\n            reactEventType = \"blur\";\n            SyntheticEventCtor = SyntheticFocusEvent;\n            break;\n          case \"beforeblur\":\n          case \"afterblur\":\n            SyntheticEventCtor = SyntheticFocusEvent;\n            break;\n          case \"click\":\n            if (nativeEvent.button === 2) {\n              return;\n            }\n          case \"auxclick\":\n          case \"dblclick\":\n          case \"mousedown\":\n          case \"mousemove\":\n          case \"mouseup\":\n          case \"mouseout\":\n          case \"mouseover\":\n          case \"contextmenu\":\n            SyntheticEventCtor = SyntheticMouseEvent;\n            break;\n          case \"drag\":\n          case \"dragend\":\n          case \"dragenter\":\n          case \"dragexit\":\n          case \"dragleave\":\n          case \"dragover\":\n          case \"dragstart\":\n          case \"drop\":\n            SyntheticEventCtor = SyntheticDragEvent;\n            break;\n          case \"touchcancel\":\n          case \"touchend\":\n          case \"touchmove\":\n          case \"touchstart\":\n            SyntheticEventCtor = SyntheticTouchEvent;\n            break;\n          case ANIMATION_END:\n          case ANIMATION_ITERATION:\n          case ANIMATION_START:\n            SyntheticEventCtor = SyntheticAnimationEvent;\n            break;\n          case TRANSITION_END:\n            SyntheticEventCtor = SyntheticTransitionEvent;\n            break;\n          case \"scroll\":\n            SyntheticEventCtor = SyntheticUIEvent;\n            break;\n          case \"wheel\":\n            SyntheticEventCtor = SyntheticWheelEvent;\n            break;\n          case \"copy\":\n          case \"cut\":\n          case \"paste\":\n            SyntheticEventCtor = SyntheticClipboardEvent;\n            break;\n          case \"gotpointercapture\":\n          case \"lostpointercapture\":\n          case \"pointercancel\":\n          case \"pointerdown\":\n          case \"pointermove\":\n          case \"pointerout\":\n          case \"pointerover\":\n          case \"pointerup\":\n            SyntheticEventCtor = SyntheticPointerEvent;\n            break;\n        }\n        var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;\n        {\n          var accumulateTargetOnly = !inCapturePhase && domEventName === \"scroll\";\n          var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);\n          if (_listeners.length > 0) {\n            var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);\n            dispatchQueue.push({\n              event: _event,\n              listeners: _listeners\n            });\n          }\n        }\n      }\n      registerSimpleEvents();\n      registerEvents$2();\n      registerEvents$1();\n      registerEvents$3();\n      registerEvents();\n      function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\n        extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);\n        var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;\n        if (shouldProcessPolyfillPlugins) {\n          extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\n          extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\n          extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\n          extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\n        }\n      }\n      var mediaEventTypes = [\"abort\", \"canplay\", \"canplaythrough\", \"durationchange\", \"emptied\", \"encrypted\", \"ended\", \"error\", \"loadeddata\", \"loadedmetadata\", \"loadstart\", \"pause\", \"play\", \"playing\", \"progress\", \"ratechange\", \"resize\", \"seeked\", \"seeking\", \"stalled\", \"suspend\", \"timeupdate\", \"volumechange\", \"waiting\"];\n      var nonDelegatedEvents = new Set([\"cancel\", \"close\", \"invalid\", \"load\", \"scroll\", \"toggle\"].concat(mediaEventTypes));\n      function executeDispatch(event, listener, currentTarget) {\n        var type = event.type || \"unknown-event\";\n        event.currentTarget = currentTarget;\n        invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);\n        event.currentTarget = null;\n      }\n      function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {\n        var previousInstance;\n        if (inCapturePhase) {\n          for (var i = dispatchListeners.length - 1;i >= 0; i--) {\n            var _dispatchListeners$i = dispatchListeners[i], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget, listener = _dispatchListeners$i.listener;\n            if (instance !== previousInstance && event.isPropagationStopped()) {\n              return;\n            }\n            executeDispatch(event, listener, currentTarget);\n            previousInstance = instance;\n          }\n        } else {\n          for (var _i = 0;_i < dispatchListeners.length; _i++) {\n            var _dispatchListeners$_i = dispatchListeners[_i], _instance = _dispatchListeners$_i.instance, _currentTarget = _dispatchListeners$_i.currentTarget, _listener = _dispatchListeners$_i.listener;\n            if (_instance !== previousInstance && event.isPropagationStopped()) {\n              return;\n            }\n            executeDispatch(event, _listener, _currentTarget);\n            previousInstance = _instance;\n          }\n        }\n      }\n      function processDispatchQueue(dispatchQueue, eventSystemFlags) {\n        var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;\n        for (var i = 0;i < dispatchQueue.length; i++) {\n          var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event, listeners = _dispatchQueue$i.listeners;\n          processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);\n        }\n        rethrowCaughtError();\n      }\n      function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {\n        var nativeEventTarget = getEventTarget(nativeEvent);\n        var dispatchQueue = [];\n        extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);\n        processDispatchQueue(dispatchQueue, eventSystemFlags);\n      }\n      function listenToNonDelegatedEvent(domEventName, targetElement) {\n        {\n          if (!nonDelegatedEvents.has(domEventName)) {\n            error('Did not expect a listenToNonDelegatedEvent() call for \"%s\". ' + \"This is a bug in React. Please file an issue.\", domEventName);\n          }\n        }\n        var isCapturePhaseListener = false;\n        var listenerSet = getEventListenerSet(targetElement);\n        var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);\n        if (!listenerSet.has(listenerSetKey)) {\n          addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);\n          listenerSet.add(listenerSetKey);\n        }\n      }\n      function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {\n        {\n          if (nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener) {\n            error('Did not expect a listenToNativeEvent() call for \"%s\" in the bubble phase. ' + \"This is a bug in React. Please file an issue.\", domEventName);\n          }\n        }\n        var eventSystemFlags = 0;\n        if (isCapturePhaseListener) {\n          eventSystemFlags |= IS_CAPTURE_PHASE;\n        }\n        addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);\n      }\n      var listeningMarker = \"_reactListening\" + Math.random().toString(36).slice(2);\n      function listenToAllSupportedEvents(rootContainerElement) {\n        if (!rootContainerElement[listeningMarker]) {\n          rootContainerElement[listeningMarker] = true;\n          allNativeEvents.forEach(function(domEventName) {\n            if (domEventName !== \"selectionchange\") {\n              if (!nonDelegatedEvents.has(domEventName)) {\n                listenToNativeEvent(domEventName, false, rootContainerElement);\n              }\n              listenToNativeEvent(domEventName, true, rootContainerElement);\n            }\n          });\n          var ownerDocument = rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;\n          if (ownerDocument !== null) {\n            if (!ownerDocument[listeningMarker]) {\n              ownerDocument[listeningMarker] = true;\n              listenToNativeEvent(\"selectionchange\", false, ownerDocument);\n            }\n          }\n        }\n      }\n      function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {\n        var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);\n        var isPassiveListener = undefined;\n        if (passiveBrowserEventsSupported) {\n          if (domEventName === \"touchstart\" || domEventName === \"touchmove\" || domEventName === \"wheel\") {\n            isPassiveListener = true;\n          }\n        }\n        targetContainer = targetContainer;\n        var unsubscribeListener;\n        if (isCapturePhaseListener) {\n          if (isPassiveListener !== undefined) {\n            unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);\n          } else {\n            unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener);\n          }\n        } else {\n          if (isPassiveListener !== undefined) {\n            unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);\n          } else {\n            unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);\n          }\n        }\n      }\n      function isMatchingRootContainer(grandContainer, targetContainer) {\n        return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;\n      }\n      function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {\n        var ancestorInst = targetInst;\n        if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {\n          var targetContainerNode = targetContainer;\n          if (targetInst !== null) {\n            var node = targetInst;\n            mainLoop:\n              while (true) {\n                if (node === null) {\n                  return;\n                }\n                var nodeTag = node.tag;\n                if (nodeTag === HostRoot || nodeTag === HostPortal) {\n                  var container = node.stateNode.containerInfo;\n                  if (isMatchingRootContainer(container, targetContainerNode)) {\n                    break;\n                  }\n                  if (nodeTag === HostPortal) {\n                    var grandNode = node.return;\n                    while (grandNode !== null) {\n                      var grandTag = grandNode.tag;\n                      if (grandTag === HostRoot || grandTag === HostPortal) {\n                        var grandContainer = grandNode.stateNode.containerInfo;\n                        if (isMatchingRootContainer(grandContainer, targetContainerNode)) {\n                          return;\n                        }\n                      }\n                      grandNode = grandNode.return;\n                    }\n                  }\n                  while (container !== null) {\n                    var parentNode = getClosestInstanceFromNode(container);\n                    if (parentNode === null) {\n                      return;\n                    }\n                    var parentTag = parentNode.tag;\n                    if (parentTag === HostComponent || parentTag === HostText) {\n                      node = ancestorInst = parentNode;\n                      continue mainLoop;\n                    }\n                    container = container.parentNode;\n                  }\n                }\n                node = node.return;\n              }\n          }\n        }\n        batchedUpdates(function() {\n          return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);\n        });\n      }\n      function createDispatchListener(instance, listener, currentTarget) {\n        return {\n          instance,\n          listener,\n          currentTarget\n        };\n      }\n      function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly, nativeEvent) {\n        var captureName = reactName !== null ? reactName + \"Capture\" : null;\n        var reactEventName = inCapturePhase ? captureName : reactName;\n        var listeners = [];\n        var instance = targetFiber;\n        var lastHostComponent = null;\n        while (instance !== null) {\n          var _instance2 = instance, stateNode = _instance2.stateNode, tag = _instance2.tag;\n          if (tag === HostComponent && stateNode !== null) {\n            lastHostComponent = stateNode;\n            if (reactEventName !== null) {\n              var listener = getListener(instance, reactEventName);\n              if (listener != null) {\n                listeners.push(createDispatchListener(instance, listener, lastHostComponent));\n              }\n            }\n          }\n          if (accumulateTargetOnly) {\n            break;\n          }\n          instance = instance.return;\n        }\n        return listeners;\n      }\n      function accumulateTwoPhaseListeners(targetFiber, reactName) {\n        var captureName = reactName + \"Capture\";\n        var listeners = [];\n        var instance = targetFiber;\n        while (instance !== null) {\n          var _instance3 = instance, stateNode = _instance3.stateNode, tag = _instance3.tag;\n          if (tag === HostComponent && stateNode !== null) {\n            var currentTarget = stateNode;\n            var captureListener = getListener(instance, captureName);\n            if (captureListener != null) {\n              listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));\n            }\n            var bubbleListener = getListener(instance, reactName);\n            if (bubbleListener != null) {\n              listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));\n            }\n          }\n          instance = instance.return;\n        }\n        return listeners;\n      }\n      function getParent(inst) {\n        if (inst === null) {\n          return null;\n        }\n        do {\n          inst = inst.return;\n        } while (inst && inst.tag !== HostComponent);\n        if (inst) {\n          return inst;\n        }\n        return null;\n      }\n      function getLowestCommonAncestor(instA, instB) {\n        var nodeA = instA;\n        var nodeB = instB;\n        var depthA = 0;\n        for (var tempA = nodeA;tempA; tempA = getParent(tempA)) {\n          depthA++;\n        }\n        var depthB = 0;\n        for (var tempB = nodeB;tempB; tempB = getParent(tempB)) {\n          depthB++;\n        }\n        while (depthA - depthB > 0) {\n          nodeA = getParent(nodeA);\n          depthA--;\n        }\n        while (depthB - depthA > 0) {\n          nodeB = getParent(nodeB);\n          depthB--;\n        }\n        var depth = depthA;\n        while (depth--) {\n          if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {\n            return nodeA;\n          }\n          nodeA = getParent(nodeA);\n          nodeB = getParent(nodeB);\n        }\n        return null;\n      }\n      function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {\n        var registrationName = event._reactName;\n        var listeners = [];\n        var instance = target;\n        while (instance !== null) {\n          if (instance === common) {\n            break;\n          }\n          var _instance4 = instance, alternate = _instance4.alternate, stateNode = _instance4.stateNode, tag = _instance4.tag;\n          if (alternate !== null && alternate === common) {\n            break;\n          }\n          if (tag === HostComponent && stateNode !== null) {\n            var currentTarget = stateNode;\n            if (inCapturePhase) {\n              var captureListener = getListener(instance, registrationName);\n              if (captureListener != null) {\n                listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));\n              }\n            } else if (!inCapturePhase) {\n              var bubbleListener = getListener(instance, registrationName);\n              if (bubbleListener != null) {\n                listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));\n              }\n            }\n          }\n          instance = instance.return;\n        }\n        if (listeners.length !== 0) {\n          dispatchQueue.push({\n            event,\n            listeners\n          });\n        }\n      }\n      function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from, to) {\n        var common = from && to ? getLowestCommonAncestor(from, to) : null;\n        if (from !== null) {\n          accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from, common, false);\n        }\n        if (to !== null && enterEvent !== null) {\n          accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to, common, true);\n        }\n      }\n      function getListenerSetKey(domEventName, capture) {\n        return domEventName + \"__\" + (capture ? \"capture\" : \"bubble\");\n      }\n      var didWarnInvalidHydration = false;\n      var DANGEROUSLY_SET_INNER_HTML = \"dangerouslySetInnerHTML\";\n      var SUPPRESS_CONTENT_EDITABLE_WARNING = \"suppressContentEditableWarning\";\n      var SUPPRESS_HYDRATION_WARNING = \"suppressHydrationWarning\";\n      var AUTOFOCUS = \"autoFocus\";\n      var CHILDREN = \"children\";\n      var STYLE = \"style\";\n      var HTML$1 = \"__html\";\n      var warnedUnknownTags;\n      var validatePropertiesInDevelopment;\n      var warnForPropDifference;\n      var warnForExtraAttributes;\n      var warnForInvalidEventListener;\n      var canDiffStyleForHydrationWarning;\n      var normalizeHTML;\n      {\n        warnedUnknownTags = {\n          dialog: true,\n          webview: true\n        };\n        validatePropertiesInDevelopment = function(type, props) {\n          validateProperties(type, props);\n          validateProperties$1(type, props);\n          validateProperties$2(type, props, {\n            registrationNameDependencies,\n            possibleRegistrationNames\n          });\n        };\n        canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode;\n        warnForPropDifference = function(propName, serverValue, clientValue) {\n          if (didWarnInvalidHydration) {\n            return;\n          }\n          var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);\n          var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);\n          if (normalizedServerValue === normalizedClientValue) {\n            return;\n          }\n          didWarnInvalidHydration = true;\n          error(\"Prop `%s` did not match. Server: %s Client: %s\", propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));\n        };\n        warnForExtraAttributes = function(attributeNames) {\n          if (didWarnInvalidHydration) {\n            return;\n          }\n          didWarnInvalidHydration = true;\n          var names = [];\n          attributeNames.forEach(function(name) {\n            names.push(name);\n          });\n          error(\"Extra attributes from the server: %s\", names);\n        };\n        warnForInvalidEventListener = function(registrationName, listener) {\n          if (listener === false) {\n            error(\"Expected `%s` listener to be a function, instead got `false`.\\n\\n\" + \"If you used to conditionally omit it with %s={condition && value}, \" + \"pass %s={condition ? value : undefined} instead.\", registrationName, registrationName, registrationName);\n          } else {\n            error(\"Expected `%s` listener to be a function, instead got a value of `%s` type.\", registrationName, typeof listener);\n          }\n        };\n        normalizeHTML = function(parent, html) {\n          var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);\n          testElement.innerHTML = html;\n          return testElement.innerHTML;\n        };\n      }\n      var NORMALIZE_NEWLINES_REGEX = /\\r\\n?/g;\n      var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\\u0000|\\uFFFD/g;\n      function normalizeMarkupForTextOrAttribute(markup) {\n        {\n          checkHtmlStringCoercion(markup);\n        }\n        var markupString = typeof markup === \"string\" ? markup : \"\" + markup;\n        return markupString.replace(NORMALIZE_NEWLINES_REGEX, `\n`).replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, \"\");\n      }\n      function checkForUnmatchedText(serverText, clientText, isConcurrentMode, shouldWarnDev) {\n        var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);\n        var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);\n        if (normalizedServerText === normalizedClientText) {\n          return;\n        }\n        if (shouldWarnDev) {\n          {\n            if (!didWarnInvalidHydration) {\n              didWarnInvalidHydration = true;\n              error('Text content did not match. Server: \"%s\" Client: \"%s\"', normalizedServerText, normalizedClientText);\n            }\n          }\n        }\n        if (isConcurrentMode && enableClientRenderFallbackOnTextMismatch) {\n          throw new Error(\"Text content does not match server-rendered HTML.\");\n        }\n      }\n      function getOwnerDocumentFromRootContainer(rootContainerElement) {\n        return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;\n      }\n      function noop() {}\n      function trapClickOnNonInteractiveElement(node) {\n        node.onclick = noop;\n      }\n      function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {\n        for (var propKey in nextProps) {\n          if (!nextProps.hasOwnProperty(propKey)) {\n            continue;\n          }\n          var nextProp = nextProps[propKey];\n          if (propKey === STYLE) {\n            {\n              if (nextProp) {\n                Object.freeze(nextProp);\n              }\n            }\n            setValueForStyles(domElement, nextProp);\n          } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n            var nextHtml = nextProp ? nextProp[HTML$1] : undefined;\n            if (nextHtml != null) {\n              setInnerHTML(domElement, nextHtml);\n            }\n          } else if (propKey === CHILDREN) {\n            if (typeof nextProp === \"string\") {\n              var canSetTextContent = tag !== \"textarea\" || nextProp !== \"\";\n              if (canSetTextContent) {\n                setTextContent(domElement, nextProp);\n              }\n            } else if (typeof nextProp === \"number\") {\n              setTextContent(domElement, \"\" + nextProp);\n            }\n          } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)\n            ;\n          else if (propKey === AUTOFOCUS)\n            ;\n          else if (registrationNameDependencies.hasOwnProperty(propKey)) {\n            if (nextProp != null) {\n              if (typeof nextProp !== \"function\") {\n                warnForInvalidEventListener(propKey, nextProp);\n              }\n              if (propKey === \"onScroll\") {\n                listenToNonDelegatedEvent(\"scroll\", domElement);\n              }\n            }\n          } else if (nextProp != null) {\n            setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);\n          }\n        }\n      }\n      function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {\n        for (var i = 0;i < updatePayload.length; i += 2) {\n          var propKey = updatePayload[i];\n          var propValue = updatePayload[i + 1];\n          if (propKey === STYLE) {\n            setValueForStyles(domElement, propValue);\n          } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n            setInnerHTML(domElement, propValue);\n          } else if (propKey === CHILDREN) {\n            setTextContent(domElement, propValue);\n          } else {\n            setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);\n          }\n        }\n      }\n      function createElement(type, props, rootContainerElement, parentNamespace) {\n        var isCustomComponentTag;\n        var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);\n        var domElement;\n        var namespaceURI = parentNamespace;\n        if (namespaceURI === HTML_NAMESPACE) {\n          namespaceURI = getIntrinsicNamespace(type);\n        }\n        if (namespaceURI === HTML_NAMESPACE) {\n          {\n            isCustomComponentTag = isCustomComponent(type, props);\n            if (!isCustomComponentTag && type !== type.toLowerCase()) {\n              error(\"<%s /> is using incorrect casing. \" + \"Use PascalCase for React components, \" + \"or lowercase for HTML elements.\", type);\n            }\n          }\n          if (type === \"script\") {\n            var div = ownerDocument.createElement(\"div\");\n            div.innerHTML = \"<script><\" + \"/script>\";\n            var firstChild = div.firstChild;\n            domElement = div.removeChild(firstChild);\n          } else if (typeof props.is === \"string\") {\n            domElement = ownerDocument.createElement(type, {\n              is: props.is\n            });\n          } else {\n            domElement = ownerDocument.createElement(type);\n            if (type === \"select\") {\n              var node = domElement;\n              if (props.multiple) {\n                node.multiple = true;\n              } else if (props.size) {\n                node.size = props.size;\n              }\n            }\n          }\n        } else {\n          domElement = ownerDocument.createElementNS(namespaceURI, type);\n        }\n        {\n          if (namespaceURI === HTML_NAMESPACE) {\n            if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === \"[object HTMLUnknownElement]\" && !hasOwnProperty.call(warnedUnknownTags, type)) {\n              warnedUnknownTags[type] = true;\n              error(\"The tag <%s> is unrecognized in this browser. \" + \"If you meant to render a React component, start its name with \" + \"an uppercase letter.\", type);\n            }\n          }\n        }\n        return domElement;\n      }\n      function createTextNode(text, rootContainerElement) {\n        return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);\n      }\n      function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {\n        var isCustomComponentTag = isCustomComponent(tag, rawProps);\n        {\n          validatePropertiesInDevelopment(tag, rawProps);\n        }\n        var props;\n        switch (tag) {\n          case \"dialog\":\n            listenToNonDelegatedEvent(\"cancel\", domElement);\n            listenToNonDelegatedEvent(\"close\", domElement);\n            props = rawProps;\n            break;\n          case \"iframe\":\n          case \"object\":\n          case \"embed\":\n            listenToNonDelegatedEvent(\"load\", domElement);\n            props = rawProps;\n            break;\n          case \"video\":\n          case \"audio\":\n            for (var i = 0;i < mediaEventTypes.length; i++) {\n              listenToNonDelegatedEvent(mediaEventTypes[i], domElement);\n            }\n            props = rawProps;\n            break;\n          case \"source\":\n            listenToNonDelegatedEvent(\"error\", domElement);\n            props = rawProps;\n            break;\n          case \"img\":\n          case \"image\":\n          case \"link\":\n            listenToNonDelegatedEvent(\"error\", domElement);\n            listenToNonDelegatedEvent(\"load\", domElement);\n            props = rawProps;\n            break;\n          case \"details\":\n            listenToNonDelegatedEvent(\"toggle\", domElement);\n            props = rawProps;\n            break;\n          case \"input\":\n            initWrapperState(domElement, rawProps);\n            props = getHostProps(domElement, rawProps);\n            listenToNonDelegatedEvent(\"invalid\", domElement);\n            break;\n          case \"option\":\n            validateProps(domElement, rawProps);\n            props = rawProps;\n            break;\n          case \"select\":\n            initWrapperState$1(domElement, rawProps);\n            props = getHostProps$1(domElement, rawProps);\n            listenToNonDelegatedEvent(\"invalid\", domElement);\n            break;\n          case \"textarea\":\n            initWrapperState$2(domElement, rawProps);\n            props = getHostProps$2(domElement, rawProps);\n            listenToNonDelegatedEvent(\"invalid\", domElement);\n            break;\n          default:\n            props = rawProps;\n        }\n        assertValidProps(tag, props);\n        setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);\n        switch (tag) {\n          case \"input\":\n            track(domElement);\n            postMountWrapper(domElement, rawProps, false);\n            break;\n          case \"textarea\":\n            track(domElement);\n            postMountWrapper$3(domElement);\n            break;\n          case \"option\":\n            postMountWrapper$1(domElement, rawProps);\n            break;\n          case \"select\":\n            postMountWrapper$2(domElement, rawProps);\n            break;\n          default:\n            if (typeof props.onClick === \"function\") {\n              trapClickOnNonInteractiveElement(domElement);\n            }\n            break;\n        }\n      }\n      function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {\n        {\n          validatePropertiesInDevelopment(tag, nextRawProps);\n        }\n        var updatePayload = null;\n        var lastProps;\n        var nextProps;\n        switch (tag) {\n          case \"input\":\n            lastProps = getHostProps(domElement, lastRawProps);\n            nextProps = getHostProps(domElement, nextRawProps);\n            updatePayload = [];\n            break;\n          case \"select\":\n            lastProps = getHostProps$1(domElement, lastRawProps);\n            nextProps = getHostProps$1(domElement, nextRawProps);\n            updatePayload = [];\n            break;\n          case \"textarea\":\n            lastProps = getHostProps$2(domElement, lastRawProps);\n            nextProps = getHostProps$2(domElement, nextRawProps);\n            updatePayload = [];\n            break;\n          default:\n            lastProps = lastRawProps;\n            nextProps = nextRawProps;\n            if (typeof lastProps.onClick !== \"function\" && typeof nextProps.onClick === \"function\") {\n              trapClickOnNonInteractiveElement(domElement);\n            }\n            break;\n        }\n        assertValidProps(tag, nextProps);\n        var propKey;\n        var styleName;\n        var styleUpdates = null;\n        for (propKey in lastProps) {\n          if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {\n            continue;\n          }\n          if (propKey === STYLE) {\n            var lastStyle = lastProps[propKey];\n            for (styleName in lastStyle) {\n              if (lastStyle.hasOwnProperty(styleName)) {\n                if (!styleUpdates) {\n                  styleUpdates = {};\n                }\n                styleUpdates[styleName] = \"\";\n              }\n            }\n          } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN)\n            ;\n          else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)\n            ;\n          else if (propKey === AUTOFOCUS)\n            ;\n          else if (registrationNameDependencies.hasOwnProperty(propKey)) {\n            if (!updatePayload) {\n              updatePayload = [];\n            }\n          } else {\n            (updatePayload = updatePayload || []).push(propKey, null);\n          }\n        }\n        for (propKey in nextProps) {\n          var nextProp = nextProps[propKey];\n          var lastProp = lastProps != null ? lastProps[propKey] : undefined;\n          if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {\n            continue;\n          }\n          if (propKey === STYLE) {\n            {\n              if (nextProp) {\n                Object.freeze(nextProp);\n              }\n            }\n            if (lastProp) {\n              for (styleName in lastProp) {\n                if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {\n                  if (!styleUpdates) {\n                    styleUpdates = {};\n                  }\n                  styleUpdates[styleName] = \"\";\n                }\n              }\n              for (styleName in nextProp) {\n                if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {\n                  if (!styleUpdates) {\n                    styleUpdates = {};\n                  }\n                  styleUpdates[styleName] = nextProp[styleName];\n                }\n              }\n            } else {\n              if (!styleUpdates) {\n                if (!updatePayload) {\n                  updatePayload = [];\n                }\n                updatePayload.push(propKey, styleUpdates);\n              }\n              styleUpdates = nextProp;\n            }\n          } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n            var nextHtml = nextProp ? nextProp[HTML$1] : undefined;\n            var lastHtml = lastProp ? lastProp[HTML$1] : undefined;\n            if (nextHtml != null) {\n              if (lastHtml !== nextHtml) {\n                (updatePayload = updatePayload || []).push(propKey, nextHtml);\n              }\n            }\n          } else if (propKey === CHILDREN) {\n            if (typeof nextProp === \"string\" || typeof nextProp === \"number\") {\n              (updatePayload = updatePayload || []).push(propKey, \"\" + nextProp);\n            }\n          } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)\n            ;\n          else if (registrationNameDependencies.hasOwnProperty(propKey)) {\n            if (nextProp != null) {\n              if (typeof nextProp !== \"function\") {\n                warnForInvalidEventListener(propKey, nextProp);\n              }\n              if (propKey === \"onScroll\") {\n                listenToNonDelegatedEvent(\"scroll\", domElement);\n              }\n            }\n            if (!updatePayload && lastProp !== nextProp) {\n              updatePayload = [];\n            }\n          } else {\n            (updatePayload = updatePayload || []).push(propKey, nextProp);\n          }\n        }\n        if (styleUpdates) {\n          {\n            validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);\n          }\n          (updatePayload = updatePayload || []).push(STYLE, styleUpdates);\n        }\n        return updatePayload;\n      }\n      function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {\n        if (tag === \"input\" && nextRawProps.type === \"radio\" && nextRawProps.name != null) {\n          updateChecked(domElement, nextRawProps);\n        }\n        var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);\n        var isCustomComponentTag = isCustomComponent(tag, nextRawProps);\n        updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);\n        switch (tag) {\n          case \"input\":\n            updateWrapper(domElement, nextRawProps);\n            break;\n          case \"textarea\":\n            updateWrapper$1(domElement, nextRawProps);\n            break;\n          case \"select\":\n            postUpdateWrapper(domElement, nextRawProps);\n            break;\n        }\n      }\n      function getPossibleStandardName(propName) {\n        {\n          var lowerCasedName = propName.toLowerCase();\n          if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n            return null;\n          }\n          return possibleStandardNames[lowerCasedName] || null;\n        }\n      }\n      function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement, isConcurrentMode, shouldWarnDev) {\n        var isCustomComponentTag;\n        var extraAttributeNames;\n        {\n          isCustomComponentTag = isCustomComponent(tag, rawProps);\n          validatePropertiesInDevelopment(tag, rawProps);\n        }\n        switch (tag) {\n          case \"dialog\":\n            listenToNonDelegatedEvent(\"cancel\", domElement);\n            listenToNonDelegatedEvent(\"close\", domElement);\n            break;\n          case \"iframe\":\n          case \"object\":\n          case \"embed\":\n            listenToNonDelegatedEvent(\"load\", domElement);\n            break;\n          case \"video\":\n          case \"audio\":\n            for (var i = 0;i < mediaEventTypes.length; i++) {\n              listenToNonDelegatedEvent(mediaEventTypes[i], domElement);\n            }\n            break;\n          case \"source\":\n            listenToNonDelegatedEvent(\"error\", domElement);\n            break;\n          case \"img\":\n          case \"image\":\n          case \"link\":\n            listenToNonDelegatedEvent(\"error\", domElement);\n            listenToNonDelegatedEvent(\"load\", domElement);\n            break;\n          case \"details\":\n            listenToNonDelegatedEvent(\"toggle\", domElement);\n            break;\n          case \"input\":\n            initWrapperState(domElement, rawProps);\n            listenToNonDelegatedEvent(\"invalid\", domElement);\n            break;\n          case \"option\":\n            validateProps(domElement, rawProps);\n            break;\n          case \"select\":\n            initWrapperState$1(domElement, rawProps);\n            listenToNonDelegatedEvent(\"invalid\", domElement);\n            break;\n          case \"textarea\":\n            initWrapperState$2(domElement, rawProps);\n            listenToNonDelegatedEvent(\"invalid\", domElement);\n            break;\n        }\n        assertValidProps(tag, rawProps);\n        {\n          extraAttributeNames = new Set;\n          var attributes = domElement.attributes;\n          for (var _i = 0;_i < attributes.length; _i++) {\n            var name = attributes[_i].name.toLowerCase();\n            switch (name) {\n              case \"value\":\n                break;\n              case \"checked\":\n                break;\n              case \"selected\":\n                break;\n              default:\n                extraAttributeNames.add(attributes[_i].name);\n            }\n          }\n        }\n        var updatePayload = null;\n        for (var propKey in rawProps) {\n          if (!rawProps.hasOwnProperty(propKey)) {\n            continue;\n          }\n          var nextProp = rawProps[propKey];\n          if (propKey === CHILDREN) {\n            if (typeof nextProp === \"string\") {\n              if (domElement.textContent !== nextProp) {\n                if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n                  checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);\n                }\n                updatePayload = [CHILDREN, nextProp];\n              }\n            } else if (typeof nextProp === \"number\") {\n              if (domElement.textContent !== \"\" + nextProp) {\n                if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n                  checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);\n                }\n                updatePayload = [CHILDREN, \"\" + nextProp];\n              }\n            }\n          } else if (registrationNameDependencies.hasOwnProperty(propKey)) {\n            if (nextProp != null) {\n              if (typeof nextProp !== \"function\") {\n                warnForInvalidEventListener(propKey, nextProp);\n              }\n              if (propKey === \"onScroll\") {\n                listenToNonDelegatedEvent(\"scroll\", domElement);\n              }\n            }\n          } else if (shouldWarnDev && true && typeof isCustomComponentTag === \"boolean\") {\n            var serverValue = undefined;\n            var propertyInfo = isCustomComponentTag && enableCustomElementPropertySupport ? null : getPropertyInfo(propKey);\n            if (rawProps[SUPPRESS_HYDRATION_WARNING] === true)\n              ;\n            else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || propKey === \"value\" || propKey === \"checked\" || propKey === \"selected\")\n              ;\n            else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n              var serverHTML = domElement.innerHTML;\n              var nextHtml = nextProp ? nextProp[HTML$1] : undefined;\n              if (nextHtml != null) {\n                var expectedHTML = normalizeHTML(domElement, nextHtml);\n                if (expectedHTML !== serverHTML) {\n                  warnForPropDifference(propKey, serverHTML, expectedHTML);\n                }\n              }\n            } else if (propKey === STYLE) {\n              extraAttributeNames.delete(propKey);\n              if (canDiffStyleForHydrationWarning) {\n                var expectedStyle = createDangerousStringForStyles(nextProp);\n                serverValue = domElement.getAttribute(\"style\");\n                if (expectedStyle !== serverValue) {\n                  warnForPropDifference(propKey, serverValue, expectedStyle);\n                }\n              }\n            } else if (isCustomComponentTag && !enableCustomElementPropertySupport) {\n              extraAttributeNames.delete(propKey.toLowerCase());\n              serverValue = getValueForAttribute(domElement, propKey, nextProp);\n              if (nextProp !== serverValue) {\n                warnForPropDifference(propKey, serverValue, nextProp);\n              }\n            } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {\n              var isMismatchDueToBadCasing = false;\n              if (propertyInfo !== null) {\n                extraAttributeNames.delete(propertyInfo.attributeName);\n                serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);\n              } else {\n                var ownNamespace = parentNamespace;\n                if (ownNamespace === HTML_NAMESPACE) {\n                  ownNamespace = getIntrinsicNamespace(tag);\n                }\n                if (ownNamespace === HTML_NAMESPACE) {\n                  extraAttributeNames.delete(propKey.toLowerCase());\n                } else {\n                  var standardName = getPossibleStandardName(propKey);\n                  if (standardName !== null && standardName !== propKey) {\n                    isMismatchDueToBadCasing = true;\n                    extraAttributeNames.delete(standardName);\n                  }\n                  extraAttributeNames.delete(propKey);\n                }\n                serverValue = getValueForAttribute(domElement, propKey, nextProp);\n              }\n              var dontWarnCustomElement = enableCustomElementPropertySupport;\n              if (!dontWarnCustomElement && nextProp !== serverValue && !isMismatchDueToBadCasing) {\n                warnForPropDifference(propKey, serverValue, nextProp);\n              }\n            }\n          }\n        }\n        {\n          if (shouldWarnDev) {\n            if (extraAttributeNames.size > 0 && rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n              warnForExtraAttributes(extraAttributeNames);\n            }\n          }\n        }\n        switch (tag) {\n          case \"input\":\n            track(domElement);\n            postMountWrapper(domElement, rawProps, true);\n            break;\n          case \"textarea\":\n            track(domElement);\n            postMountWrapper$3(domElement);\n            break;\n          case \"select\":\n          case \"option\":\n            break;\n          default:\n            if (typeof rawProps.onClick === \"function\") {\n              trapClickOnNonInteractiveElement(domElement);\n            }\n            break;\n        }\n        return updatePayload;\n      }\n      function diffHydratedText(textNode, text, isConcurrentMode) {\n        var isDifferent = textNode.nodeValue !== text;\n        return isDifferent;\n      }\n      function warnForDeletedHydratableElement(parentNode, child) {\n        {\n          if (didWarnInvalidHydration) {\n            return;\n          }\n          didWarnInvalidHydration = true;\n          error(\"Did not expect server HTML to contain a <%s> in <%s>.\", child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());\n        }\n      }\n      function warnForDeletedHydratableText(parentNode, child) {\n        {\n          if (didWarnInvalidHydration) {\n            return;\n          }\n          didWarnInvalidHydration = true;\n          error('Did not expect server HTML to contain the text node \"%s\" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());\n        }\n      }\n      function warnForInsertedHydratedElement(parentNode, tag, props) {\n        {\n          if (didWarnInvalidHydration) {\n            return;\n          }\n          didWarnInvalidHydration = true;\n          error(\"Expected server HTML to contain a matching <%s> in <%s>.\", tag, parentNode.nodeName.toLowerCase());\n        }\n      }\n      function warnForInsertedHydratedText(parentNode, text) {\n        {\n          if (text === \"\") {\n            return;\n          }\n          if (didWarnInvalidHydration) {\n            return;\n          }\n          didWarnInvalidHydration = true;\n          error('Expected server HTML to contain a matching text node for \"%s\" in <%s>.', text, parentNode.nodeName.toLowerCase());\n        }\n      }\n      function restoreControlledState$3(domElement, tag, props) {\n        switch (tag) {\n          case \"input\":\n            restoreControlledState(domElement, props);\n            return;\n          case \"textarea\":\n            restoreControlledState$2(domElement, props);\n            return;\n          case \"select\":\n            restoreControlledState$1(domElement, props);\n            return;\n        }\n      }\n      var validateDOMNesting = function() {};\n      var updatedAncestorInfo = function() {};\n      {\n        var specialTags = [\"address\", \"applet\", \"area\", \"article\", \"aside\", \"base\", \"basefont\", \"bgsound\", \"blockquote\", \"body\", \"br\", \"button\", \"caption\", \"center\", \"col\", \"colgroup\", \"dd\", \"details\", \"dir\", \"div\", \"dl\", \"dt\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\", \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"iframe\", \"img\", \"input\", \"isindex\", \"li\", \"link\", \"listing\", \"main\", \"marquee\", \"menu\", \"menuitem\", \"meta\", \"nav\", \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"p\", \"param\", \"plaintext\", \"pre\", \"script\", \"section\", \"select\", \"source\", \"style\", \"summary\", \"table\", \"tbody\", \"td\", \"template\", \"textarea\", \"tfoot\", \"th\", \"thead\", \"title\", \"tr\", \"track\", \"ul\", \"wbr\", \"xmp\"];\n        var inScopeTags = [\n          \"applet\",\n          \"caption\",\n          \"html\",\n          \"table\",\n          \"td\",\n          \"th\",\n          \"marquee\",\n          \"object\",\n          \"template\",\n          \"foreignObject\",\n          \"desc\",\n          \"title\"\n        ];\n        var buttonScopeTags = inScopeTags.concat([\"button\"]);\n        var impliedEndTags = [\"dd\", \"dt\", \"li\", \"option\", \"optgroup\", \"p\", \"rp\", \"rt\"];\n        var emptyAncestorInfo = {\n          current: null,\n          formTag: null,\n          aTagInScope: null,\n          buttonTagInScope: null,\n          nobrTagInScope: null,\n          pTagInButtonScope: null,\n          listItemTagAutoclosing: null,\n          dlItemTagAutoclosing: null\n        };\n        updatedAncestorInfo = function(oldInfo, tag) {\n          var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);\n          var info = {\n            tag\n          };\n          if (inScopeTags.indexOf(tag) !== -1) {\n            ancestorInfo.aTagInScope = null;\n            ancestorInfo.buttonTagInScope = null;\n            ancestorInfo.nobrTagInScope = null;\n          }\n          if (buttonScopeTags.indexOf(tag) !== -1) {\n            ancestorInfo.pTagInButtonScope = null;\n          }\n          if (specialTags.indexOf(tag) !== -1 && tag !== \"address\" && tag !== \"div\" && tag !== \"p\") {\n            ancestorInfo.listItemTagAutoclosing = null;\n            ancestorInfo.dlItemTagAutoclosing = null;\n          }\n          ancestorInfo.current = info;\n          if (tag === \"form\") {\n            ancestorInfo.formTag = info;\n          }\n          if (tag === \"a\") {\n            ancestorInfo.aTagInScope = info;\n          }\n          if (tag === \"button\") {\n            ancestorInfo.buttonTagInScope = info;\n          }\n          if (tag === \"nobr\") {\n            ancestorInfo.nobrTagInScope = info;\n          }\n          if (tag === \"p\") {\n            ancestorInfo.pTagInButtonScope = info;\n          }\n          if (tag === \"li\") {\n            ancestorInfo.listItemTagAutoclosing = info;\n          }\n          if (tag === \"dd\" || tag === \"dt\") {\n            ancestorInfo.dlItemTagAutoclosing = info;\n          }\n          return ancestorInfo;\n        };\n        var isTagValidWithParent = function(tag, parentTag) {\n          switch (parentTag) {\n            case \"select\":\n              return tag === \"option\" || tag === \"optgroup\" || tag === \"#text\";\n            case \"optgroup\":\n              return tag === \"option\" || tag === \"#text\";\n            case \"option\":\n              return tag === \"#text\";\n            case \"tr\":\n              return tag === \"th\" || tag === \"td\" || tag === \"style\" || tag === \"script\" || tag === \"template\";\n            case \"tbody\":\n            case \"thead\":\n            case \"tfoot\":\n              return tag === \"tr\" || tag === \"style\" || tag === \"script\" || tag === \"template\";\n            case \"colgroup\":\n              return tag === \"col\" || tag === \"template\";\n            case \"table\":\n              return tag === \"caption\" || tag === \"colgroup\" || tag === \"tbody\" || tag === \"tfoot\" || tag === \"thead\" || tag === \"style\" || tag === \"script\" || tag === \"template\";\n            case \"head\":\n              return tag === \"base\" || tag === \"basefont\" || tag === \"bgsound\" || tag === \"link\" || tag === \"meta\" || tag === \"title\" || tag === \"noscript\" || tag === \"noframes\" || tag === \"style\" || tag === \"script\" || tag === \"template\";\n            case \"html\":\n              return tag === \"head\" || tag === \"body\" || tag === \"frameset\";\n            case \"frameset\":\n              return tag === \"frame\";\n            case \"#document\":\n              return tag === \"html\";\n          }\n          switch (tag) {\n            case \"h1\":\n            case \"h2\":\n            case \"h3\":\n            case \"h4\":\n            case \"h5\":\n            case \"h6\":\n              return parentTag !== \"h1\" && parentTag !== \"h2\" && parentTag !== \"h3\" && parentTag !== \"h4\" && parentTag !== \"h5\" && parentTag !== \"h6\";\n            case \"rp\":\n            case \"rt\":\n              return impliedEndTags.indexOf(parentTag) === -1;\n            case \"body\":\n            case \"caption\":\n            case \"col\":\n            case \"colgroup\":\n            case \"frameset\":\n            case \"frame\":\n            case \"head\":\n            case \"html\":\n            case \"tbody\":\n            case \"td\":\n            case \"tfoot\":\n            case \"th\":\n            case \"thead\":\n            case \"tr\":\n              return parentTag == null;\n          }\n          return true;\n        };\n        var findInvalidAncestorForTag = function(tag, ancestorInfo) {\n          switch (tag) {\n            case \"address\":\n            case \"article\":\n            case \"aside\":\n            case \"blockquote\":\n            case \"center\":\n            case \"details\":\n            case \"dialog\":\n            case \"dir\":\n            case \"div\":\n            case \"dl\":\n            case \"fieldset\":\n            case \"figcaption\":\n            case \"figure\":\n            case \"footer\":\n            case \"header\":\n            case \"hgroup\":\n            case \"main\":\n            case \"menu\":\n            case \"nav\":\n            case \"ol\":\n            case \"p\":\n            case \"section\":\n            case \"summary\":\n            case \"ul\":\n            case \"pre\":\n            case \"listing\":\n            case \"table\":\n            case \"hr\":\n            case \"xmp\":\n            case \"h1\":\n            case \"h2\":\n            case \"h3\":\n            case \"h4\":\n            case \"h5\":\n            case \"h6\":\n              return ancestorInfo.pTagInButtonScope;\n            case \"form\":\n              return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;\n            case \"li\":\n              return ancestorInfo.listItemTagAutoclosing;\n            case \"dd\":\n            case \"dt\":\n              return ancestorInfo.dlItemTagAutoclosing;\n            case \"button\":\n              return ancestorInfo.buttonTagInScope;\n            case \"a\":\n              return ancestorInfo.aTagInScope;\n            case \"nobr\":\n              return ancestorInfo.nobrTagInScope;\n          }\n          return null;\n        };\n        var didWarn$1 = {};\n        validateDOMNesting = function(childTag, childText, ancestorInfo) {\n          ancestorInfo = ancestorInfo || emptyAncestorInfo;\n          var parentInfo = ancestorInfo.current;\n          var parentTag = parentInfo && parentInfo.tag;\n          if (childText != null) {\n            if (childTag != null) {\n              error(\"validateDOMNesting: when childText is passed, childTag should be null\");\n            }\n            childTag = \"#text\";\n          }\n          var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;\n          var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);\n          var invalidParentOrAncestor = invalidParent || invalidAncestor;\n          if (!invalidParentOrAncestor) {\n            return;\n          }\n          var ancestorTag = invalidParentOrAncestor.tag;\n          var warnKey = !!invalidParent + \"|\" + childTag + \"|\" + ancestorTag;\n          if (didWarn$1[warnKey]) {\n            return;\n          }\n          didWarn$1[warnKey] = true;\n          var tagDisplayName = childTag;\n          var whitespaceInfo = \"\";\n          if (childTag === \"#text\") {\n            if (/\\S/.test(childText)) {\n              tagDisplayName = \"Text nodes\";\n            } else {\n              tagDisplayName = \"Whitespace text nodes\";\n              whitespaceInfo = \" Make sure you don't have any extra whitespace between tags on \" + \"each line of your source code.\";\n            }\n          } else {\n            tagDisplayName = \"<\" + childTag + \">\";\n          }\n          if (invalidParent) {\n            var info = \"\";\n            if (ancestorTag === \"table\" && childTag === \"tr\") {\n              info += \" Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by \" + \"the browser.\";\n            }\n            error(\"validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s\", tagDisplayName, ancestorTag, whitespaceInfo, info);\n          } else {\n            error(\"validateDOMNesting(...): %s cannot appear as a descendant of \" + \"<%s>.\", tagDisplayName, ancestorTag);\n          }\n        };\n      }\n      var SUPPRESS_HYDRATION_WARNING$1 = \"suppressHydrationWarning\";\n      var SUSPENSE_START_DATA = \"$\";\n      var SUSPENSE_END_DATA = \"/$\";\n      var SUSPENSE_PENDING_START_DATA = \"$?\";\n      var SUSPENSE_FALLBACK_START_DATA = \"$!\";\n      var STYLE$1 = \"style\";\n      var eventsEnabled = null;\n      var selectionInformation = null;\n      function getRootHostContext(rootContainerInstance) {\n        var type;\n        var namespace;\n        var nodeType = rootContainerInstance.nodeType;\n        switch (nodeType) {\n          case DOCUMENT_NODE:\n          case DOCUMENT_FRAGMENT_NODE: {\n            type = nodeType === DOCUMENT_NODE ? \"#document\" : \"#fragment\";\n            var root2 = rootContainerInstance.documentElement;\n            namespace = root2 ? root2.namespaceURI : getChildNamespace(null, \"\");\n            break;\n          }\n          default: {\n            var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;\n            var ownNamespace = container.namespaceURI || null;\n            type = container.tagName;\n            namespace = getChildNamespace(ownNamespace, type);\n            break;\n          }\n        }\n        {\n          var validatedTag = type.toLowerCase();\n          var ancestorInfo = updatedAncestorInfo(null, validatedTag);\n          return {\n            namespace,\n            ancestorInfo\n          };\n        }\n      }\n      function getChildHostContext(parentHostContext, type, rootContainerInstance) {\n        {\n          var parentHostContextDev = parentHostContext;\n          var namespace = getChildNamespace(parentHostContextDev.namespace, type);\n          var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);\n          return {\n            namespace,\n            ancestorInfo\n          };\n        }\n      }\n      function getPublicInstance(instance) {\n        return instance;\n      }\n      function prepareForCommit(containerInfo) {\n        eventsEnabled = isEnabled();\n        selectionInformation = getSelectionInformation();\n        var activeInstance = null;\n        setEnabled(false);\n        return activeInstance;\n      }\n      function resetAfterCommit(containerInfo) {\n        restoreSelection(selectionInformation);\n        setEnabled(eventsEnabled);\n        eventsEnabled = null;\n        selectionInformation = null;\n      }\n      function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n        var parentNamespace;\n        {\n          var hostContextDev = hostContext;\n          validateDOMNesting(type, null, hostContextDev.ancestorInfo);\n          if (typeof props.children === \"string\" || typeof props.children === \"number\") {\n            var string = \"\" + props.children;\n            var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);\n            validateDOMNesting(null, string, ownAncestorInfo);\n          }\n          parentNamespace = hostContextDev.namespace;\n        }\n        var domElement = createElement(type, props, rootContainerInstance, parentNamespace);\n        precacheFiberNode(internalInstanceHandle, domElement);\n        updateFiberProps(domElement, props);\n        return domElement;\n      }\n      function appendInitialChild(parentInstance, child) {\n        parentInstance.appendChild(child);\n      }\n      function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {\n        setInitialProperties(domElement, type, props, rootContainerInstance);\n        switch (type) {\n          case \"button\":\n          case \"input\":\n          case \"select\":\n          case \"textarea\":\n            return !!props.autoFocus;\n          case \"img\":\n            return true;\n          default:\n            return false;\n        }\n      }\n      function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {\n        {\n          var hostContextDev = hostContext;\n          if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === \"string\" || typeof newProps.children === \"number\")) {\n            var string = \"\" + newProps.children;\n            var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);\n            validateDOMNesting(null, string, ownAncestorInfo);\n          }\n        }\n        return diffProperties(domElement, type, oldProps, newProps);\n      }\n      function shouldSetTextContent(type, props) {\n        return type === \"textarea\" || type === \"noscript\" || typeof props.children === \"string\" || typeof props.children === \"number\" || typeof props.dangerouslySetInnerHTML === \"object\" && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;\n      }\n      function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {\n        {\n          var hostContextDev = hostContext;\n          validateDOMNesting(null, text, hostContextDev.ancestorInfo);\n        }\n        var textNode = createTextNode(text, rootContainerInstance);\n        precacheFiberNode(internalInstanceHandle, textNode);\n        return textNode;\n      }\n      function getCurrentEventPriority() {\n        var currentEvent = window.event;\n        if (currentEvent === undefined) {\n          return DefaultEventPriority;\n        }\n        return getEventPriority(currentEvent.type);\n      }\n      var scheduleTimeout = typeof setTimeout === \"function\" ? setTimeout : undefined;\n      var cancelTimeout = typeof clearTimeout === \"function\" ? clearTimeout : undefined;\n      var noTimeout = -1;\n      var localPromise = typeof Promise === \"function\" ? Promise : undefined;\n      var scheduleMicrotask = typeof queueMicrotask === \"function\" ? queueMicrotask : typeof localPromise !== \"undefined\" ? function(callback) {\n        return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);\n      } : scheduleTimeout;\n      function handleErrorInNextTick(error2) {\n        setTimeout(function() {\n          throw error2;\n        });\n      }\n      function commitMount(domElement, type, newProps, internalInstanceHandle) {\n        switch (type) {\n          case \"button\":\n          case \"input\":\n          case \"select\":\n          case \"textarea\":\n            if (newProps.autoFocus) {\n              domElement.focus();\n            }\n            return;\n          case \"img\": {\n            if (newProps.src) {\n              domElement.src = newProps.src;\n            }\n            return;\n          }\n        }\n      }\n      function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {\n        updateProperties(domElement, updatePayload, type, oldProps, newProps);\n        updateFiberProps(domElement, newProps);\n      }\n      function resetTextContent(domElement) {\n        setTextContent(domElement, \"\");\n      }\n      function commitTextUpdate(textInstance, oldText, newText) {\n        textInstance.nodeValue = newText;\n      }\n      function appendChild(parentInstance, child) {\n        parentInstance.appendChild(child);\n      }\n      function appendChildToContainer(container, child) {\n        var parentNode;\n        if (container.nodeType === COMMENT_NODE) {\n          parentNode = container.parentNode;\n          parentNode.insertBefore(child, container);\n        } else {\n          parentNode = container;\n          parentNode.appendChild(child);\n        }\n        var reactRootContainer = container._reactRootContainer;\n        if ((reactRootContainer === null || reactRootContainer === undefined) && parentNode.onclick === null) {\n          trapClickOnNonInteractiveElement(parentNode);\n        }\n      }\n      function insertBefore(parentInstance, child, beforeChild) {\n        parentInstance.insertBefore(child, beforeChild);\n      }\n      function insertInContainerBefore(container, child, beforeChild) {\n        if (container.nodeType === COMMENT_NODE) {\n          container.parentNode.insertBefore(child, beforeChild);\n        } else {\n          container.insertBefore(child, beforeChild);\n        }\n      }\n      function removeChild(parentInstance, child) {\n        parentInstance.removeChild(child);\n      }\n      function removeChildFromContainer(container, child) {\n        if (container.nodeType === COMMENT_NODE) {\n          container.parentNode.removeChild(child);\n        } else {\n          container.removeChild(child);\n        }\n      }\n      function clearSuspenseBoundary(parentInstance, suspenseInstance) {\n        var node = suspenseInstance;\n        var depth = 0;\n        do {\n          var nextNode = node.nextSibling;\n          parentInstance.removeChild(node);\n          if (nextNode && nextNode.nodeType === COMMENT_NODE) {\n            var data = nextNode.data;\n            if (data === SUSPENSE_END_DATA) {\n              if (depth === 0) {\n                parentInstance.removeChild(nextNode);\n                retryIfBlockedOn(suspenseInstance);\n                return;\n              } else {\n                depth--;\n              }\n            } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_FALLBACK_START_DATA) {\n              depth++;\n            }\n          }\n          node = nextNode;\n        } while (node);\n        retryIfBlockedOn(suspenseInstance);\n      }\n      function clearSuspenseBoundaryFromContainer(container, suspenseInstance) {\n        if (container.nodeType === COMMENT_NODE) {\n          clearSuspenseBoundary(container.parentNode, suspenseInstance);\n        } else if (container.nodeType === ELEMENT_NODE) {\n          clearSuspenseBoundary(container, suspenseInstance);\n        }\n        retryIfBlockedOn(container);\n      }\n      function hideInstance(instance) {\n        instance = instance;\n        var style2 = instance.style;\n        if (typeof style2.setProperty === \"function\") {\n          style2.setProperty(\"display\", \"none\", \"important\");\n        } else {\n          style2.display = \"none\";\n        }\n      }\n      function hideTextInstance(textInstance) {\n        textInstance.nodeValue = \"\";\n      }\n      function unhideInstance(instance, props) {\n        instance = instance;\n        var styleProp = props[STYLE$1];\n        var display = styleProp !== undefined && styleProp !== null && styleProp.hasOwnProperty(\"display\") ? styleProp.display : null;\n        instance.style.display = dangerousStyleValue(\"display\", display);\n      }\n      function unhideTextInstance(textInstance, text) {\n        textInstance.nodeValue = text;\n      }\n      function clearContainer(container) {\n        if (container.nodeType === ELEMENT_NODE) {\n          container.textContent = \"\";\n        } else if (container.nodeType === DOCUMENT_NODE) {\n          if (container.documentElement) {\n            container.removeChild(container.documentElement);\n          }\n        }\n      }\n      function canHydrateInstance(instance, type, props) {\n        if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {\n          return null;\n        }\n        return instance;\n      }\n      function canHydrateTextInstance(instance, text) {\n        if (text === \"\" || instance.nodeType !== TEXT_NODE) {\n          return null;\n        }\n        return instance;\n      }\n      function canHydrateSuspenseInstance(instance) {\n        if (instance.nodeType !== COMMENT_NODE) {\n          return null;\n        }\n        return instance;\n      }\n      function isSuspenseInstancePending(instance) {\n        return instance.data === SUSPENSE_PENDING_START_DATA;\n      }\n      function isSuspenseInstanceFallback(instance) {\n        return instance.data === SUSPENSE_FALLBACK_START_DATA;\n      }\n      function getSuspenseInstanceFallbackErrorDetails(instance) {\n        var dataset = instance.nextSibling && instance.nextSibling.dataset;\n        var digest, message, stack;\n        if (dataset) {\n          digest = dataset.dgst;\n          {\n            message = dataset.msg;\n            stack = dataset.stck;\n          }\n        }\n        {\n          return {\n            message,\n            digest,\n            stack\n          };\n        }\n      }\n      function registerSuspenseInstanceRetry(instance, callback) {\n        instance._reactRetry = callback;\n      }\n      function getNextHydratable(node) {\n        for (;node != null; node = node.nextSibling) {\n          var nodeType = node.nodeType;\n          if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {\n            break;\n          }\n          if (nodeType === COMMENT_NODE) {\n            var nodeData = node.data;\n            if (nodeData === SUSPENSE_START_DATA || nodeData === SUSPENSE_FALLBACK_START_DATA || nodeData === SUSPENSE_PENDING_START_DATA) {\n              break;\n            }\n            if (nodeData === SUSPENSE_END_DATA) {\n              return null;\n            }\n          }\n        }\n        return node;\n      }\n      function getNextHydratableSibling(instance) {\n        return getNextHydratable(instance.nextSibling);\n      }\n      function getFirstHydratableChild(parentInstance) {\n        return getNextHydratable(parentInstance.firstChild);\n      }\n      function getFirstHydratableChildWithinContainer(parentContainer) {\n        return getNextHydratable(parentContainer.firstChild);\n      }\n      function getFirstHydratableChildWithinSuspenseInstance(parentInstance) {\n        return getNextHydratable(parentInstance.nextSibling);\n      }\n      function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle, shouldWarnDev) {\n        precacheFiberNode(internalInstanceHandle, instance);\n        updateFiberProps(instance, props);\n        var parentNamespace;\n        {\n          var hostContextDev = hostContext;\n          parentNamespace = hostContextDev.namespace;\n        }\n        var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;\n        return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance, isConcurrentMode, shouldWarnDev);\n      }\n      function hydrateTextInstance(textInstance, text, internalInstanceHandle, shouldWarnDev) {\n        precacheFiberNode(internalInstanceHandle, textInstance);\n        var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;\n        return diffHydratedText(textInstance, text);\n      }\n      function hydrateSuspenseInstance(suspenseInstance, internalInstanceHandle) {\n        precacheFiberNode(internalInstanceHandle, suspenseInstance);\n      }\n      function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {\n        var node = suspenseInstance.nextSibling;\n        var depth = 0;\n        while (node) {\n          if (node.nodeType === COMMENT_NODE) {\n            var data = node.data;\n            if (data === SUSPENSE_END_DATA) {\n              if (depth === 0) {\n                return getNextHydratableSibling(node);\n              } else {\n                depth--;\n              }\n            } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {\n              depth++;\n            }\n          }\n          node = node.nextSibling;\n        }\n        return null;\n      }\n      function getParentSuspenseInstance(targetInstance) {\n        var node = targetInstance.previousSibling;\n        var depth = 0;\n        while (node) {\n          if (node.nodeType === COMMENT_NODE) {\n            var data = node.data;\n            if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {\n              if (depth === 0) {\n                return node;\n              } else {\n                depth--;\n              }\n            } else if (data === SUSPENSE_END_DATA) {\n              depth++;\n            }\n          }\n          node = node.previousSibling;\n        }\n        return null;\n      }\n      function commitHydratedContainer(container) {\n        retryIfBlockedOn(container);\n      }\n      function commitHydratedSuspenseInstance(suspenseInstance) {\n        retryIfBlockedOn(suspenseInstance);\n      }\n      function shouldDeleteUnhydratedTailInstances(parentType) {\n        return parentType !== \"head\" && parentType !== \"body\";\n      }\n      function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text, isConcurrentMode) {\n        var shouldWarnDev = true;\n        checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);\n      }\n      function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text, isConcurrentMode) {\n        if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {\n          var shouldWarnDev = true;\n          checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);\n        }\n      }\n      function didNotHydrateInstanceWithinContainer(parentContainer, instance) {\n        {\n          if (instance.nodeType === ELEMENT_NODE) {\n            warnForDeletedHydratableElement(parentContainer, instance);\n          } else if (instance.nodeType === COMMENT_NODE)\n            ;\n          else {\n            warnForDeletedHydratableText(parentContainer, instance);\n          }\n        }\n      }\n      function didNotHydrateInstanceWithinSuspenseInstance(parentInstance, instance) {\n        {\n          var parentNode = parentInstance.parentNode;\n          if (parentNode !== null) {\n            if (instance.nodeType === ELEMENT_NODE) {\n              warnForDeletedHydratableElement(parentNode, instance);\n            } else if (instance.nodeType === COMMENT_NODE)\n              ;\n            else {\n              warnForDeletedHydratableText(parentNode, instance);\n            }\n          }\n        }\n      }\n      function didNotHydrateInstance(parentType, parentProps, parentInstance, instance, isConcurrentMode) {\n        {\n          if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {\n            if (instance.nodeType === ELEMENT_NODE) {\n              warnForDeletedHydratableElement(parentInstance, instance);\n            } else if (instance.nodeType === COMMENT_NODE)\n              ;\n            else {\n              warnForDeletedHydratableText(parentInstance, instance);\n            }\n          }\n        }\n      }\n      function didNotFindHydratableInstanceWithinContainer(parentContainer, type, props) {\n        {\n          warnForInsertedHydratedElement(parentContainer, type);\n        }\n      }\n      function didNotFindHydratableTextInstanceWithinContainer(parentContainer, text) {\n        {\n          warnForInsertedHydratedText(parentContainer, text);\n        }\n      }\n      function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance, type, props) {\n        {\n          var parentNode = parentInstance.parentNode;\n          if (parentNode !== null)\n            warnForInsertedHydratedElement(parentNode, type);\n        }\n      }\n      function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance, text) {\n        {\n          var parentNode = parentInstance.parentNode;\n          if (parentNode !== null)\n            warnForInsertedHydratedText(parentNode, text);\n        }\n      }\n      function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props, isConcurrentMode) {\n        {\n          if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {\n            warnForInsertedHydratedElement(parentInstance, type);\n          }\n        }\n      }\n      function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text, isConcurrentMode) {\n        {\n          if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {\n            warnForInsertedHydratedText(parentInstance, text);\n          }\n        }\n      }\n      function errorHydratingContainer(parentContainer) {\n        {\n          error(\"An error occurred during hydration. The server HTML was replaced with client content in <%s>.\", parentContainer.nodeName.toLowerCase());\n        }\n      }\n      function preparePortalMount(portalInstance) {\n        listenToAllSupportedEvents(portalInstance);\n      }\n      var randomKey = Math.random().toString(36).slice(2);\n      var internalInstanceKey = \"__reactFiber$\" + randomKey;\n      var internalPropsKey = \"__reactProps$\" + randomKey;\n      var internalContainerInstanceKey = \"__reactContainer$\" + randomKey;\n      var internalEventHandlersKey = \"__reactEvents$\" + randomKey;\n      var internalEventHandlerListenersKey = \"__reactListeners$\" + randomKey;\n      var internalEventHandlesSetKey = \"__reactHandles$\" + randomKey;\n      function detachDeletedInstance(node) {\n        delete node[internalInstanceKey];\n        delete node[internalPropsKey];\n        delete node[internalEventHandlersKey];\n        delete node[internalEventHandlerListenersKey];\n        delete node[internalEventHandlesSetKey];\n      }\n      function precacheFiberNode(hostInst, node) {\n        node[internalInstanceKey] = hostInst;\n      }\n      function markContainerAsRoot(hostRoot, node) {\n        node[internalContainerInstanceKey] = hostRoot;\n      }\n      function unmarkContainerAsRoot(node) {\n        node[internalContainerInstanceKey] = null;\n      }\n      function isContainerMarkedAsRoot(node) {\n        return !!node[internalContainerInstanceKey];\n      }\n      function getClosestInstanceFromNode(targetNode) {\n        var targetInst = targetNode[internalInstanceKey];\n        if (targetInst) {\n          return targetInst;\n        }\n        var parentNode = targetNode.parentNode;\n        while (parentNode) {\n          targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];\n          if (targetInst) {\n            var alternate = targetInst.alternate;\n            if (targetInst.child !== null || alternate !== null && alternate.child !== null) {\n              var suspenseInstance = getParentSuspenseInstance(targetNode);\n              while (suspenseInstance !== null) {\n                var targetSuspenseInst = suspenseInstance[internalInstanceKey];\n                if (targetSuspenseInst) {\n                  return targetSuspenseInst;\n                }\n                suspenseInstance = getParentSuspenseInstance(suspenseInstance);\n              }\n            }\n            return targetInst;\n          }\n          targetNode = parentNode;\n          parentNode = targetNode.parentNode;\n        }\n        return null;\n      }\n      function getInstanceFromNode(node) {\n        var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];\n        if (inst) {\n          if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {\n            return inst;\n          } else {\n            return null;\n          }\n        }\n        return null;\n      }\n      function getNodeFromInstance(inst) {\n        if (inst.tag === HostComponent || inst.tag === HostText) {\n          return inst.stateNode;\n        }\n        throw new Error(\"getNodeFromInstance: Invalid argument.\");\n      }\n      function getFiberCurrentPropsFromNode(node) {\n        return node[internalPropsKey] || null;\n      }\n      function updateFiberProps(node, props) {\n        node[internalPropsKey] = props;\n      }\n      function getEventListenerSet(node) {\n        var elementListenerSet = node[internalEventHandlersKey];\n        if (elementListenerSet === undefined) {\n          elementListenerSet = node[internalEventHandlersKey] = new Set;\n        }\n        return elementListenerSet;\n      }\n      var loggedTypeFailures = {};\n      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n      function setCurrentlyValidatingElement(element) {\n        {\n          if (element) {\n            var owner = element._owner;\n            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n          } else {\n            ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n          }\n        }\n      }\n      function checkPropTypes(typeSpecs, values, location, componentName, element) {\n        {\n          var has2 = Function.call.bind(hasOwnProperty);\n          for (var typeSpecName in typeSpecs) {\n            if (has2(typeSpecs, typeSpecName)) {\n              var error$1 = undefined;\n              try {\n                if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                  var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                  err.name = \"Invariant Violation\";\n                  throw err;\n                }\n                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n              } catch (ex) {\n                error$1 = ex;\n              }\n              if (error$1 && !(error$1 instanceof Error)) {\n                setCurrentlyValidatingElement(element);\n                error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                setCurrentlyValidatingElement(null);\n              }\n              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                loggedTypeFailures[error$1.message] = true;\n                setCurrentlyValidatingElement(element);\n                error(\"Failed %s type: %s\", location, error$1.message);\n                setCurrentlyValidatingElement(null);\n              }\n            }\n          }\n        }\n      }\n      var valueStack = [];\n      var fiberStack;\n      {\n        fiberStack = [];\n      }\n      var index = -1;\n      function createCursor(defaultValue) {\n        return {\n          current: defaultValue\n        };\n      }\n      function pop(cursor, fiber) {\n        if (index < 0) {\n          {\n            error(\"Unexpected pop.\");\n          }\n          return;\n        }\n        {\n          if (fiber !== fiberStack[index]) {\n            error(\"Unexpected Fiber popped.\");\n          }\n        }\n        cursor.current = valueStack[index];\n        valueStack[index] = null;\n        {\n          fiberStack[index] = null;\n        }\n        index--;\n      }\n      function push(cursor, value, fiber) {\n        index++;\n        valueStack[index] = cursor.current;\n        {\n          fiberStack[index] = fiber;\n        }\n        cursor.current = value;\n      }\n      var warnedAboutMissingGetChildContext;\n      {\n        warnedAboutMissingGetChildContext = {};\n      }\n      var emptyContextObject = {};\n      {\n        Object.freeze(emptyContextObject);\n      }\n      var contextStackCursor = createCursor(emptyContextObject);\n      var didPerformWorkStackCursor = createCursor(false);\n      var previousContext = emptyContextObject;\n      function getUnmaskedContext(workInProgress2, Component, didPushOwnContextIfProvider) {\n        {\n          if (didPushOwnContextIfProvider && isContextProvider(Component)) {\n            return previousContext;\n          }\n          return contextStackCursor.current;\n        }\n      }\n      function cacheContext(workInProgress2, unmaskedContext, maskedContext) {\n        {\n          var instance = workInProgress2.stateNode;\n          instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n          instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n        }\n      }\n      function getMaskedContext(workInProgress2, unmaskedContext) {\n        {\n          var type = workInProgress2.type;\n          var contextTypes = type.contextTypes;\n          if (!contextTypes) {\n            return emptyContextObject;\n          }\n          var instance = workInProgress2.stateNode;\n          if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {\n            return instance.__reactInternalMemoizedMaskedChildContext;\n          }\n          var context = {};\n          for (var key in contextTypes) {\n            context[key] = unmaskedContext[key];\n          }\n          {\n            var name = getComponentNameFromFiber(workInProgress2) || \"Unknown\";\n            checkPropTypes(contextTypes, context, \"context\", name);\n          }\n          if (instance) {\n            cacheContext(workInProgress2, unmaskedContext, context);\n          }\n          return context;\n        }\n      }\n      function hasContextChanged() {\n        {\n          return didPerformWorkStackCursor.current;\n        }\n      }\n      function isContextProvider(type) {\n        {\n          var childContextTypes = type.childContextTypes;\n          return childContextTypes !== null && childContextTypes !== undefined;\n        }\n      }\n      function popContext(fiber) {\n        {\n          pop(didPerformWorkStackCursor, fiber);\n          pop(contextStackCursor, fiber);\n        }\n      }\n      function popTopLevelContextObject(fiber) {\n        {\n          pop(didPerformWorkStackCursor, fiber);\n          pop(contextStackCursor, fiber);\n        }\n      }\n      function pushTopLevelContextObject(fiber, context, didChange) {\n        {\n          if (contextStackCursor.current !== emptyContextObject) {\n            throw new Error(\"Unexpected context found on stack. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n          }\n          push(contextStackCursor, context, fiber);\n          push(didPerformWorkStackCursor, didChange, fiber);\n        }\n      }\n      function processChildContext(fiber, type, parentContext) {\n        {\n          var instance = fiber.stateNode;\n          var childContextTypes = type.childContextTypes;\n          if (typeof instance.getChildContext !== \"function\") {\n            {\n              var componentName = getComponentNameFromFiber(fiber) || \"Unknown\";\n              if (!warnedAboutMissingGetChildContext[componentName]) {\n                warnedAboutMissingGetChildContext[componentName] = true;\n                error(\"%s.childContextTypes is specified but there is no getChildContext() method \" + \"on the instance. You can either define getChildContext() on %s or remove \" + \"childContextTypes from it.\", componentName, componentName);\n              }\n            }\n            return parentContext;\n          }\n          var childContext = instance.getChildContext();\n          for (var contextKey in childContext) {\n            if (!(contextKey in childContextTypes)) {\n              throw new Error((getComponentNameFromFiber(fiber) || \"Unknown\") + '.getChildContext(): key \"' + contextKey + '\" is not defined in childContextTypes.');\n            }\n          }\n          {\n            var name = getComponentNameFromFiber(fiber) || \"Unknown\";\n            checkPropTypes(childContextTypes, childContext, \"child context\", name);\n          }\n          return assign({}, parentContext, childContext);\n        }\n      }\n      function pushContextProvider(workInProgress2) {\n        {\n          var instance = workInProgress2.stateNode;\n          var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;\n          previousContext = contextStackCursor.current;\n          push(contextStackCursor, memoizedMergedChildContext, workInProgress2);\n          push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress2);\n          return true;\n        }\n      }\n      function invalidateContextProvider(workInProgress2, type, didChange) {\n        {\n          var instance = workInProgress2.stateNode;\n          if (!instance) {\n            throw new Error(\"Expected to have an instance by this point. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n          }\n          if (didChange) {\n            var mergedContext = processChildContext(workInProgress2, type, previousContext);\n            instance.__reactInternalMemoizedMergedChildContext = mergedContext;\n            pop(didPerformWorkStackCursor, workInProgress2);\n            pop(contextStackCursor, workInProgress2);\n            push(contextStackCursor, mergedContext, workInProgress2);\n            push(didPerformWorkStackCursor, didChange, workInProgress2);\n          } else {\n            pop(didPerformWorkStackCursor, workInProgress2);\n            push(didPerformWorkStackCursor, didChange, workInProgress2);\n          }\n        }\n      }\n      function findCurrentUnmaskedContext(fiber) {\n        {\n          if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {\n            throw new Error(\"Expected subtree parent to be a mounted class component. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n          }\n          var node = fiber;\n          do {\n            switch (node.tag) {\n              case HostRoot:\n                return node.stateNode.context;\n              case ClassComponent: {\n                var Component = node.type;\n                if (isContextProvider(Component)) {\n                  return node.stateNode.__reactInternalMemoizedMergedChildContext;\n                }\n                break;\n              }\n            }\n            node = node.return;\n          } while (node !== null);\n          throw new Error(\"Found unexpected detached subtree parent. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n        }\n      }\n      var LegacyRoot = 0;\n      var ConcurrentRoot = 1;\n      var syncQueue = null;\n      var includesLegacySyncCallbacks = false;\n      var isFlushingSyncQueue = false;\n      function scheduleSyncCallback(callback) {\n        if (syncQueue === null) {\n          syncQueue = [callback];\n        } else {\n          syncQueue.push(callback);\n        }\n      }\n      function scheduleLegacySyncCallback(callback) {\n        includesLegacySyncCallbacks = true;\n        scheduleSyncCallback(callback);\n      }\n      function flushSyncCallbacksOnlyInLegacyMode() {\n        if (includesLegacySyncCallbacks) {\n          flushSyncCallbacks();\n        }\n      }\n      function flushSyncCallbacks() {\n        if (!isFlushingSyncQueue && syncQueue !== null) {\n          isFlushingSyncQueue = true;\n          var i = 0;\n          var previousUpdatePriority = getCurrentUpdatePriority();\n          try {\n            var isSync = true;\n            var queue = syncQueue;\n            setCurrentUpdatePriority(DiscreteEventPriority);\n            for (;i < queue.length; i++) {\n              var callback = queue[i];\n              do {\n                callback = callback(isSync);\n              } while (callback !== null);\n            }\n            syncQueue = null;\n            includesLegacySyncCallbacks = false;\n          } catch (error2) {\n            if (syncQueue !== null) {\n              syncQueue = syncQueue.slice(i + 1);\n            }\n            scheduleCallback(ImmediatePriority, flushSyncCallbacks);\n            throw error2;\n          } finally {\n            setCurrentUpdatePriority(previousUpdatePriority);\n            isFlushingSyncQueue = false;\n          }\n        }\n        return null;\n      }\n      var forkStack = [];\n      var forkStackIndex = 0;\n      var treeForkProvider = null;\n      var treeForkCount = 0;\n      var idStack = [];\n      var idStackIndex = 0;\n      var treeContextProvider = null;\n      var treeContextId = 1;\n      var treeContextOverflow = \"\";\n      function isForkedChild(workInProgress2) {\n        warnIfNotHydrating();\n        return (workInProgress2.flags & Forked) !== NoFlags;\n      }\n      function getForksAtLevel(workInProgress2) {\n        warnIfNotHydrating();\n        return treeForkCount;\n      }\n      function getTreeId() {\n        var overflow = treeContextOverflow;\n        var idWithLeadingBit = treeContextId;\n        var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);\n        return id.toString(32) + overflow;\n      }\n      function pushTreeFork(workInProgress2, totalChildren) {\n        warnIfNotHydrating();\n        forkStack[forkStackIndex++] = treeForkCount;\n        forkStack[forkStackIndex++] = treeForkProvider;\n        treeForkProvider = workInProgress2;\n        treeForkCount = totalChildren;\n      }\n      function pushTreeId(workInProgress2, totalChildren, index2) {\n        warnIfNotHydrating();\n        idStack[idStackIndex++] = treeContextId;\n        idStack[idStackIndex++] = treeContextOverflow;\n        idStack[idStackIndex++] = treeContextProvider;\n        treeContextProvider = workInProgress2;\n        var baseIdWithLeadingBit = treeContextId;\n        var baseOverflow = treeContextOverflow;\n        var baseLength = getBitLength(baseIdWithLeadingBit) - 1;\n        var baseId = baseIdWithLeadingBit & ~(1 << baseLength);\n        var slot = index2 + 1;\n        var length = getBitLength(totalChildren) + baseLength;\n        if (length > 30) {\n          var numberOfOverflowBits = baseLength - baseLength % 5;\n          var newOverflowBits = (1 << numberOfOverflowBits) - 1;\n          var newOverflow = (baseId & newOverflowBits).toString(32);\n          var restOfBaseId = baseId >> numberOfOverflowBits;\n          var restOfBaseLength = baseLength - numberOfOverflowBits;\n          var restOfLength = getBitLength(totalChildren) + restOfBaseLength;\n          var restOfNewBits = slot << restOfBaseLength;\n          var id = restOfNewBits | restOfBaseId;\n          var overflow = newOverflow + baseOverflow;\n          treeContextId = 1 << restOfLength | id;\n          treeContextOverflow = overflow;\n        } else {\n          var newBits = slot << baseLength;\n          var _id = newBits | baseId;\n          var _overflow = baseOverflow;\n          treeContextId = 1 << length | _id;\n          treeContextOverflow = _overflow;\n        }\n      }\n      function pushMaterializedTreeId(workInProgress2) {\n        warnIfNotHydrating();\n        var returnFiber = workInProgress2.return;\n        if (returnFiber !== null) {\n          var numberOfForks = 1;\n          var slotIndex = 0;\n          pushTreeFork(workInProgress2, numberOfForks);\n          pushTreeId(workInProgress2, numberOfForks, slotIndex);\n        }\n      }\n      function getBitLength(number) {\n        return 32 - clz32(number);\n      }\n      function getLeadingBit(id) {\n        return 1 << getBitLength(id) - 1;\n      }\n      function popTreeContext(workInProgress2) {\n        while (workInProgress2 === treeForkProvider) {\n          treeForkProvider = forkStack[--forkStackIndex];\n          forkStack[forkStackIndex] = null;\n          treeForkCount = forkStack[--forkStackIndex];\n          forkStack[forkStackIndex] = null;\n        }\n        while (workInProgress2 === treeContextProvider) {\n          treeContextProvider = idStack[--idStackIndex];\n          idStack[idStackIndex] = null;\n          treeContextOverflow = idStack[--idStackIndex];\n          idStack[idStackIndex] = null;\n          treeContextId = idStack[--idStackIndex];\n          idStack[idStackIndex] = null;\n        }\n      }\n      function getSuspendedTreeContext() {\n        warnIfNotHydrating();\n        if (treeContextProvider !== null) {\n          return {\n            id: treeContextId,\n            overflow: treeContextOverflow\n          };\n        } else {\n          return null;\n        }\n      }\n      function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {\n        warnIfNotHydrating();\n        idStack[idStackIndex++] = treeContextId;\n        idStack[idStackIndex++] = treeContextOverflow;\n        idStack[idStackIndex++] = treeContextProvider;\n        treeContextId = suspendedContext.id;\n        treeContextOverflow = suspendedContext.overflow;\n        treeContextProvider = workInProgress2;\n      }\n      function warnIfNotHydrating() {\n        {\n          if (!getIsHydrating()) {\n            error(\"Expected to be hydrating. This is a bug in React. Please file \" + \"an issue.\");\n          }\n        }\n      }\n      var hydrationParentFiber = null;\n      var nextHydratableInstance = null;\n      var isHydrating = false;\n      var didSuspendOrErrorDEV = false;\n      var hydrationErrors = null;\n      function warnIfHydrating() {\n        {\n          if (isHydrating) {\n            error(\"We should not be hydrating here. This is a bug in React. Please file a bug.\");\n          }\n        }\n      }\n      function markDidThrowWhileHydratingDEV() {\n        {\n          didSuspendOrErrorDEV = true;\n        }\n      }\n      function didSuspendOrErrorWhileHydratingDEV() {\n        {\n          return didSuspendOrErrorDEV;\n        }\n      }\n      function enterHydrationState(fiber) {\n        var parentInstance = fiber.stateNode.containerInfo;\n        nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);\n        hydrationParentFiber = fiber;\n        isHydrating = true;\n        hydrationErrors = null;\n        didSuspendOrErrorDEV = false;\n        return true;\n      }\n      function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {\n        nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);\n        hydrationParentFiber = fiber;\n        isHydrating = true;\n        hydrationErrors = null;\n        didSuspendOrErrorDEV = false;\n        if (treeContext !== null) {\n          restoreSuspendedTreeContext(fiber, treeContext);\n        }\n        return true;\n      }\n      function warnUnhydratedInstance(returnFiber, instance) {\n        {\n          switch (returnFiber.tag) {\n            case HostRoot: {\n              didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);\n              break;\n            }\n            case HostComponent: {\n              var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n              didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance, isConcurrentMode);\n              break;\n            }\n            case SuspenseComponent: {\n              var suspenseState = returnFiber.memoizedState;\n              if (suspenseState.dehydrated !== null)\n                didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);\n              break;\n            }\n          }\n        }\n      }\n      function deleteHydratableInstance(returnFiber, instance) {\n        warnUnhydratedInstance(returnFiber, instance);\n        var childToDelete = createFiberFromHostInstanceForDeletion();\n        childToDelete.stateNode = instance;\n        childToDelete.return = returnFiber;\n        var deletions = returnFiber.deletions;\n        if (deletions === null) {\n          returnFiber.deletions = [childToDelete];\n          returnFiber.flags |= ChildDeletion;\n        } else {\n          deletions.push(childToDelete);\n        }\n      }\n      function warnNonhydratedInstance(returnFiber, fiber) {\n        {\n          if (didSuspendOrErrorDEV) {\n            return;\n          }\n          switch (returnFiber.tag) {\n            case HostRoot: {\n              var parentContainer = returnFiber.stateNode.containerInfo;\n              switch (fiber.tag) {\n                case HostComponent:\n                  var type = fiber.type;\n                  var props = fiber.pendingProps;\n                  didNotFindHydratableInstanceWithinContainer(parentContainer, type);\n                  break;\n                case HostText:\n                  var text = fiber.pendingProps;\n                  didNotFindHydratableTextInstanceWithinContainer(parentContainer, text);\n                  break;\n              }\n              break;\n            }\n            case HostComponent: {\n              var parentType = returnFiber.type;\n              var parentProps = returnFiber.memoizedProps;\n              var parentInstance = returnFiber.stateNode;\n              switch (fiber.tag) {\n                case HostComponent: {\n                  var _type = fiber.type;\n                  var _props = fiber.pendingProps;\n                  var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n                  didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props, isConcurrentMode);\n                  break;\n                }\n                case HostText: {\n                  var _text = fiber.pendingProps;\n                  var _isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n                  didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text, _isConcurrentMode);\n                  break;\n                }\n              }\n              break;\n            }\n            case SuspenseComponent: {\n              var suspenseState = returnFiber.memoizedState;\n              var _parentInstance = suspenseState.dehydrated;\n              if (_parentInstance !== null)\n                switch (fiber.tag) {\n                  case HostComponent:\n                    var _type2 = fiber.type;\n                    var _props2 = fiber.pendingProps;\n                    didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2);\n                    break;\n                  case HostText:\n                    var _text2 = fiber.pendingProps;\n                    didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);\n                    break;\n                }\n              break;\n            }\n            default:\n              return;\n          }\n        }\n      }\n      function insertNonHydratedInstance(returnFiber, fiber) {\n        fiber.flags = fiber.flags & ~Hydrating | Placement;\n        warnNonhydratedInstance(returnFiber, fiber);\n      }\n      function tryHydrate(fiber, nextInstance) {\n        switch (fiber.tag) {\n          case HostComponent: {\n            var type = fiber.type;\n            var props = fiber.pendingProps;\n            var instance = canHydrateInstance(nextInstance, type);\n            if (instance !== null) {\n              fiber.stateNode = instance;\n              hydrationParentFiber = fiber;\n              nextHydratableInstance = getFirstHydratableChild(instance);\n              return true;\n            }\n            return false;\n          }\n          case HostText: {\n            var text = fiber.pendingProps;\n            var textInstance = canHydrateTextInstance(nextInstance, text);\n            if (textInstance !== null) {\n              fiber.stateNode = textInstance;\n              hydrationParentFiber = fiber;\n              nextHydratableInstance = null;\n              return true;\n            }\n            return false;\n          }\n          case SuspenseComponent: {\n            var suspenseInstance = canHydrateSuspenseInstance(nextInstance);\n            if (suspenseInstance !== null) {\n              var suspenseState = {\n                dehydrated: suspenseInstance,\n                treeContext: getSuspendedTreeContext(),\n                retryLane: OffscreenLane\n              };\n              fiber.memoizedState = suspenseState;\n              var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);\n              dehydratedFragment.return = fiber;\n              fiber.child = dehydratedFragment;\n              hydrationParentFiber = fiber;\n              nextHydratableInstance = null;\n              return true;\n            }\n            return false;\n          }\n          default:\n            return false;\n        }\n      }\n      function shouldClientRenderOnMismatch(fiber) {\n        return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;\n      }\n      function throwOnHydrationMismatch(fiber) {\n        throw new Error(\"Hydration failed because the initial UI does not match what was \" + \"rendered on the server.\");\n      }\n      function tryToClaimNextHydratableInstance(fiber) {\n        if (!isHydrating) {\n          return;\n        }\n        var nextInstance = nextHydratableInstance;\n        if (!nextInstance) {\n          if (shouldClientRenderOnMismatch(fiber)) {\n            warnNonhydratedInstance(hydrationParentFiber, fiber);\n            throwOnHydrationMismatch();\n          }\n          insertNonHydratedInstance(hydrationParentFiber, fiber);\n          isHydrating = false;\n          hydrationParentFiber = fiber;\n          return;\n        }\n        var firstAttemptedInstance = nextInstance;\n        if (!tryHydrate(fiber, nextInstance)) {\n          if (shouldClientRenderOnMismatch(fiber)) {\n            warnNonhydratedInstance(hydrationParentFiber, fiber);\n            throwOnHydrationMismatch();\n          }\n          nextInstance = getNextHydratableSibling(firstAttemptedInstance);\n          var prevHydrationParentFiber = hydrationParentFiber;\n          if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n            insertNonHydratedInstance(hydrationParentFiber, fiber);\n            isHydrating = false;\n            hydrationParentFiber = fiber;\n            return;\n          }\n          deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);\n        }\n      }\n      function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {\n        var instance = fiber.stateNode;\n        var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;\n        var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev);\n        fiber.updateQueue = updatePayload;\n        if (updatePayload !== null) {\n          return true;\n        }\n        return false;\n      }\n      function prepareToHydrateHostTextInstance(fiber) {\n        var textInstance = fiber.stateNode;\n        var textContent = fiber.memoizedProps;\n        var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);\n        if (shouldUpdate) {\n          var returnFiber = hydrationParentFiber;\n          if (returnFiber !== null) {\n            switch (returnFiber.tag) {\n              case HostRoot: {\n                var parentContainer = returnFiber.stateNode.containerInfo;\n                var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n                didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent, isConcurrentMode);\n                break;\n              }\n              case HostComponent: {\n                var parentType = returnFiber.type;\n                var parentProps = returnFiber.memoizedProps;\n                var parentInstance = returnFiber.stateNode;\n                var _isConcurrentMode2 = (returnFiber.mode & ConcurrentMode) !== NoMode;\n                didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent, _isConcurrentMode2);\n                break;\n              }\n            }\n          }\n        }\n        return shouldUpdate;\n      }\n      function prepareToHydrateHostSuspenseInstance(fiber) {\n        var suspenseState = fiber.memoizedState;\n        var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n        if (!suspenseInstance) {\n          throw new Error(\"Expected to have a hydrated suspense instance. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n        }\n        hydrateSuspenseInstance(suspenseInstance, fiber);\n      }\n      function skipPastDehydratedSuspenseInstance(fiber) {\n        var suspenseState = fiber.memoizedState;\n        var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n        if (!suspenseInstance) {\n          throw new Error(\"Expected to have a hydrated suspense instance. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n        }\n        return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);\n      }\n      function popToNextHostParent(fiber) {\n        var parent = fiber.return;\n        while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {\n          parent = parent.return;\n        }\n        hydrationParentFiber = parent;\n      }\n      function popHydrationState(fiber) {\n        if (fiber !== hydrationParentFiber) {\n          return false;\n        }\n        if (!isHydrating) {\n          popToNextHostParent(fiber);\n          isHydrating = true;\n          return false;\n        }\n        if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {\n          var nextInstance = nextHydratableInstance;\n          if (nextInstance) {\n            if (shouldClientRenderOnMismatch(fiber)) {\n              warnIfUnhydratedTailNodes(fiber);\n              throwOnHydrationMismatch();\n            } else {\n              while (nextInstance) {\n                deleteHydratableInstance(fiber, nextInstance);\n                nextInstance = getNextHydratableSibling(nextInstance);\n              }\n            }\n          }\n        }\n        popToNextHostParent(fiber);\n        if (fiber.tag === SuspenseComponent) {\n          nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);\n        } else {\n          nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n        }\n        return true;\n      }\n      function hasUnhydratedTailNodes() {\n        return isHydrating && nextHydratableInstance !== null;\n      }\n      function warnIfUnhydratedTailNodes(fiber) {\n        var nextInstance = nextHydratableInstance;\n        while (nextInstance) {\n          warnUnhydratedInstance(fiber, nextInstance);\n          nextInstance = getNextHydratableSibling(nextInstance);\n        }\n      }\n      function resetHydrationState() {\n        hydrationParentFiber = null;\n        nextHydratableInstance = null;\n        isHydrating = false;\n        didSuspendOrErrorDEV = false;\n      }\n      function upgradeHydrationErrorsToRecoverable() {\n        if (hydrationErrors !== null) {\n          queueRecoverableErrors(hydrationErrors);\n          hydrationErrors = null;\n        }\n      }\n      function getIsHydrating() {\n        return isHydrating;\n      }\n      function queueHydrationError(error2) {\n        if (hydrationErrors === null) {\n          hydrationErrors = [error2];\n        } else {\n          hydrationErrors.push(error2);\n        }\n      }\n      var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;\n      var NoTransition = null;\n      function requestCurrentTransition() {\n        return ReactCurrentBatchConfig$1.transition;\n      }\n      var ReactStrictModeWarnings = {\n        recordUnsafeLifecycleWarnings: function(fiber, instance) {},\n        flushPendingUnsafeLifecycleWarnings: function() {},\n        recordLegacyContextWarning: function(fiber, instance) {},\n        flushLegacyContextWarning: function() {},\n        discardPendingWarnings: function() {}\n      };\n      {\n        var findStrictRoot = function(fiber) {\n          var maybeStrictRoot = null;\n          var node = fiber;\n          while (node !== null) {\n            if (node.mode & StrictLegacyMode) {\n              maybeStrictRoot = node;\n            }\n            node = node.return;\n          }\n          return maybeStrictRoot;\n        };\n        var setToSortedString = function(set2) {\n          var array = [];\n          set2.forEach(function(value) {\n            array.push(value);\n          });\n          return array.sort().join(\", \");\n        };\n        var pendingComponentWillMountWarnings = [];\n        var pendingUNSAFE_ComponentWillMountWarnings = [];\n        var pendingComponentWillReceivePropsWarnings = [];\n        var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n        var pendingComponentWillUpdateWarnings = [];\n        var pendingUNSAFE_ComponentWillUpdateWarnings = [];\n        var didWarnAboutUnsafeLifecycles = new Set;\n        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {\n          if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {\n            return;\n          }\n          if (typeof instance.componentWillMount === \"function\" && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n            pendingComponentWillMountWarnings.push(fiber);\n          }\n          if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === \"function\") {\n            pendingUNSAFE_ComponentWillMountWarnings.push(fiber);\n          }\n          if (typeof instance.componentWillReceiveProps === \"function\" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n            pendingComponentWillReceivePropsWarnings.push(fiber);\n          }\n          if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n            pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);\n          }\n          if (typeof instance.componentWillUpdate === \"function\" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n            pendingComponentWillUpdateWarnings.push(fiber);\n          }\n          if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n            pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);\n          }\n        };\n        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {\n          var componentWillMountUniqueNames = new Set;\n          if (pendingComponentWillMountWarnings.length > 0) {\n            pendingComponentWillMountWarnings.forEach(function(fiber) {\n              componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n              didWarnAboutUnsafeLifecycles.add(fiber.type);\n            });\n            pendingComponentWillMountWarnings = [];\n          }\n          var UNSAFE_componentWillMountUniqueNames = new Set;\n          if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {\n            pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {\n              UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n              didWarnAboutUnsafeLifecycles.add(fiber.type);\n            });\n            pendingUNSAFE_ComponentWillMountWarnings = [];\n          }\n          var componentWillReceivePropsUniqueNames = new Set;\n          if (pendingComponentWillReceivePropsWarnings.length > 0) {\n            pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {\n              componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n              didWarnAboutUnsafeLifecycles.add(fiber.type);\n            });\n            pendingComponentWillReceivePropsWarnings = [];\n          }\n          var UNSAFE_componentWillReceivePropsUniqueNames = new Set;\n          if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {\n            pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {\n              UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n              didWarnAboutUnsafeLifecycles.add(fiber.type);\n            });\n            pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n          }\n          var componentWillUpdateUniqueNames = new Set;\n          if (pendingComponentWillUpdateWarnings.length > 0) {\n            pendingComponentWillUpdateWarnings.forEach(function(fiber) {\n              componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n              didWarnAboutUnsafeLifecycles.add(fiber.type);\n            });\n            pendingComponentWillUpdateWarnings = [];\n          }\n          var UNSAFE_componentWillUpdateUniqueNames = new Set;\n          if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {\n            pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {\n              UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n              didWarnAboutUnsafeLifecycles.add(fiber.type);\n            });\n            pendingUNSAFE_ComponentWillUpdateWarnings = [];\n          }\n          if (UNSAFE_componentWillMountUniqueNames.size > 0) {\n            var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);\n            error(\"Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. \" + `See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n` + `* Move code with side effects to componentDidMount, and set initial state in the constructor.\n` + `\nPlease update the following components: %s`, sortedNames);\n          }\n          if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {\n            var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);\n            error(\"Using UNSAFE_componentWillReceiveProps in strict mode is not recommended \" + \"and may indicate bugs in your code. \" + `See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n` + `* Move data fetching code or side effects to componentDidUpdate.\n` + \"* If you're updating state whenever props change, \" + \"refactor your code to use memoization techniques or move it to \" + `static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n` + `\nPlease update the following components: %s`, _sortedNames);\n          }\n          if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {\n            var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);\n            error(\"Using UNSAFE_componentWillUpdate in strict mode is not recommended \" + \"and may indicate bugs in your code. \" + `See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n` + `* Move data fetching code or side effects to componentDidUpdate.\n` + `\nPlease update the following components: %s`, _sortedNames2);\n          }\n          if (componentWillMountUniqueNames.size > 0) {\n            var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);\n            warn(\"componentWillMount has been renamed, and is not recommended for use. \" + `See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n` + `* Move code with side effects to componentDidMount, and set initial state in the constructor.\n` + \"* Rename componentWillMount to UNSAFE_componentWillMount to suppress \" + \"this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. \" + \"To rename all deprecated lifecycles to their new names, you can run \" + \"`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\" + `\nPlease update the following components: %s`, _sortedNames3);\n          }\n          if (componentWillReceivePropsUniqueNames.size > 0) {\n            var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);\n            warn(\"componentWillReceiveProps has been renamed, and is not recommended for use. \" + `See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n` + `* Move data fetching code or side effects to componentDidUpdate.\n` + \"* If you're updating state whenever props change, refactor your \" + \"code to use memoization techniques or move it to \" + `static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n` + \"* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress \" + \"this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. \" + \"To rename all deprecated lifecycles to their new names, you can run \" + \"`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\" + `\nPlease update the following components: %s`, _sortedNames4);\n          }\n          if (componentWillUpdateUniqueNames.size > 0) {\n            var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);\n            warn(\"componentWillUpdate has been renamed, and is not recommended for use. \" + `See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n` + `* Move data fetching code or side effects to componentDidUpdate.\n` + \"* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress \" + \"this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. \" + \"To rename all deprecated lifecycles to their new names, you can run \" + \"`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\" + `\nPlease update the following components: %s`, _sortedNames5);\n          }\n        };\n        var pendingLegacyContextWarning = new Map;\n        var didWarnAboutLegacyContext = new Set;\n        ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {\n          var strictRoot = findStrictRoot(fiber);\n          if (strictRoot === null) {\n            error(\"Expected to find a StrictMode component in a strict mode tree. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n            return;\n          }\n          if (didWarnAboutLegacyContext.has(fiber.type)) {\n            return;\n          }\n          var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);\n          if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === \"function\") {\n            if (warningsForRoot === undefined) {\n              warningsForRoot = [];\n              pendingLegacyContextWarning.set(strictRoot, warningsForRoot);\n            }\n            warningsForRoot.push(fiber);\n          }\n        };\n        ReactStrictModeWarnings.flushLegacyContextWarning = function() {\n          pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {\n            if (fiberArray.length === 0) {\n              return;\n            }\n            var firstFiber = fiberArray[0];\n            var uniqueNames = new Set;\n            fiberArray.forEach(function(fiber) {\n              uniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n              didWarnAboutLegacyContext.add(fiber.type);\n            });\n            var sortedNames = setToSortedString(uniqueNames);\n            try {\n              setCurrentFiber(firstFiber);\n              error(\"Legacy context API has been detected within a strict-mode tree.\" + `\n\nThe old API will be supported in all 16.x releases, but applications ` + \"using it should migrate to the new version.\" + `\n\nPlease update the following components: %s` + `\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context`, sortedNames);\n            } finally {\n              resetCurrentFiber();\n            }\n          });\n        };\n        ReactStrictModeWarnings.discardPendingWarnings = function() {\n          pendingComponentWillMountWarnings = [];\n          pendingUNSAFE_ComponentWillMountWarnings = [];\n          pendingComponentWillReceivePropsWarnings = [];\n          pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n          pendingComponentWillUpdateWarnings = [];\n          pendingUNSAFE_ComponentWillUpdateWarnings = [];\n          pendingLegacyContextWarning = new Map;\n        };\n      }\n      var didWarnAboutMaps;\n      var didWarnAboutGenerators;\n      var didWarnAboutStringRefs;\n      var ownerHasKeyUseWarning;\n      var ownerHasFunctionTypeWarning;\n      var warnForMissingKey = function(child, returnFiber) {};\n      {\n        didWarnAboutMaps = false;\n        didWarnAboutGenerators = false;\n        didWarnAboutStringRefs = {};\n        ownerHasKeyUseWarning = {};\n        ownerHasFunctionTypeWarning = {};\n        warnForMissingKey = function(child, returnFiber) {\n          if (child === null || typeof child !== \"object\") {\n            return;\n          }\n          if (!child._store || child._store.validated || child.key != null) {\n            return;\n          }\n          if (typeof child._store !== \"object\") {\n            throw new Error(\"React Component in warnForMissingKey should have a _store. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n          }\n          child._store.validated = true;\n          var componentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n          if (ownerHasKeyUseWarning[componentName]) {\n            return;\n          }\n          ownerHasKeyUseWarning[componentName] = true;\n          error(\"Each child in a list should have a unique \" + '\"key\" prop. See https://reactjs.org/link/warning-keys for ' + \"more information.\");\n        };\n      }\n      function isReactClass(type) {\n        return type.prototype && type.prototype.isReactComponent;\n      }\n      function coerceRef(returnFiber, current2, element) {\n        var mixedRef = element.ref;\n        if (mixedRef !== null && typeof mixedRef !== \"function\" && typeof mixedRef !== \"object\") {\n          {\n            if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && !(element._owner && element._self && element._owner.stateNode !== element._self) && !(element._owner && element._owner.tag !== ClassComponent) && !(typeof element.type === \"function\" && !isReactClass(element.type)) && element._owner) {\n              var componentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n              if (!didWarnAboutStringRefs[componentName]) {\n                {\n                  error('Component \"%s\" contains the string ref \"%s\". Support for string refs ' + \"will be removed in a future major release. We recommend using \" + \"useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", componentName, mixedRef);\n                }\n                didWarnAboutStringRefs[componentName] = true;\n              }\n            }\n          }\n          if (element._owner) {\n            var owner = element._owner;\n            var inst;\n            if (owner) {\n              var ownerFiber = owner;\n              if (ownerFiber.tag !== ClassComponent) {\n                throw new Error(\"Function components cannot have string refs. \" + \"We recommend using useRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\");\n              }\n              inst = ownerFiber.stateNode;\n            }\n            if (!inst) {\n              throw new Error(\"Missing owner for string ref \" + mixedRef + \". This error is likely caused by a \" + \"bug in React. Please file an issue.\");\n            }\n            var resolvedInst = inst;\n            {\n              checkPropStringCoercion(mixedRef, \"ref\");\n            }\n            var stringRef = \"\" + mixedRef;\n            if (current2 !== null && current2.ref !== null && typeof current2.ref === \"function\" && current2.ref._stringRef === stringRef) {\n              return current2.ref;\n            }\n            var ref = function(value) {\n              var refs = resolvedInst.refs;\n              if (value === null) {\n                delete refs[stringRef];\n              } else {\n                refs[stringRef] = value;\n              }\n            };\n            ref._stringRef = stringRef;\n            return ref;\n          } else {\n            if (typeof mixedRef !== \"string\") {\n              throw new Error(\"Expected ref to be a function, a string, an object returned by React.createRef(), or null.\");\n            }\n            if (!element._owner) {\n              throw new Error(\"Element ref was specified as a string (\" + mixedRef + \") but no owner was set. This could happen for one of\" + ` the following reasons:\n` + `1. You may be adding a ref to a function component\n` + `2. You may be adding a ref to a component that was not created inside a component's render method\n` + `3. You have multiple copies of React loaded\n` + \"See https://reactjs.org/link/refs-must-have-owner for more information.\");\n            }\n          }\n        }\n        return mixedRef;\n      }\n      function throwOnInvalidObjectType(returnFiber, newChild) {\n        var childString = Object.prototype.toString.call(newChild);\n        throw new Error(\"Objects are not valid as a React child (found: \" + (childString === \"[object Object]\" ? \"object with keys {\" + Object.keys(newChild).join(\", \") + \"}\" : childString) + \"). \" + \"If you meant to render a collection of children, use an array \" + \"instead.\");\n      }\n      function warnOnFunctionType(returnFiber) {\n        {\n          var componentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n          if (ownerHasFunctionTypeWarning[componentName]) {\n            return;\n          }\n          ownerHasFunctionTypeWarning[componentName] = true;\n          error(\"Functions are not valid as a React child. This may happen if \" + \"you return a Component instead of <Component /> from render. \" + \"Or maybe you meant to call this function rather than return it.\");\n        }\n      }\n      function resolveLazy(lazyType) {\n        var payload = lazyType._payload;\n        var init = lazyType._init;\n        return init(payload);\n      }\n      function ChildReconciler(shouldTrackSideEffects) {\n        function deleteChild(returnFiber, childToDelete) {\n          if (!shouldTrackSideEffects) {\n            return;\n          }\n          var deletions = returnFiber.deletions;\n          if (deletions === null) {\n            returnFiber.deletions = [childToDelete];\n            returnFiber.flags |= ChildDeletion;\n          } else {\n            deletions.push(childToDelete);\n          }\n        }\n        function deleteRemainingChildren(returnFiber, currentFirstChild) {\n          if (!shouldTrackSideEffects) {\n            return null;\n          }\n          var childToDelete = currentFirstChild;\n          while (childToDelete !== null) {\n            deleteChild(returnFiber, childToDelete);\n            childToDelete = childToDelete.sibling;\n          }\n          return null;\n        }\n        function mapRemainingChildren(returnFiber, currentFirstChild) {\n          var existingChildren = new Map;\n          var existingChild = currentFirstChild;\n          while (existingChild !== null) {\n            if (existingChild.key !== null) {\n              existingChildren.set(existingChild.key, existingChild);\n            } else {\n              existingChildren.set(existingChild.index, existingChild);\n            }\n            existingChild = existingChild.sibling;\n          }\n          return existingChildren;\n        }\n        function useFiber(fiber, pendingProps) {\n          var clone = createWorkInProgress(fiber, pendingProps);\n          clone.index = 0;\n          clone.sibling = null;\n          return clone;\n        }\n        function placeChild(newFiber, lastPlacedIndex, newIndex) {\n          newFiber.index = newIndex;\n          if (!shouldTrackSideEffects) {\n            newFiber.flags |= Forked;\n            return lastPlacedIndex;\n          }\n          var current2 = newFiber.alternate;\n          if (current2 !== null) {\n            var oldIndex = current2.index;\n            if (oldIndex < lastPlacedIndex) {\n              newFiber.flags |= Placement;\n              return lastPlacedIndex;\n            } else {\n              return oldIndex;\n            }\n          } else {\n            newFiber.flags |= Placement;\n            return lastPlacedIndex;\n          }\n        }\n        function placeSingleChild(newFiber) {\n          if (shouldTrackSideEffects && newFiber.alternate === null) {\n            newFiber.flags |= Placement;\n          }\n          return newFiber;\n        }\n        function updateTextNode(returnFiber, current2, textContent, lanes) {\n          if (current2 === null || current2.tag !== HostText) {\n            var created = createFiberFromText(textContent, returnFiber.mode, lanes);\n            created.return = returnFiber;\n            return created;\n          } else {\n            var existing = useFiber(current2, textContent);\n            existing.return = returnFiber;\n            return existing;\n          }\n        }\n        function updateElement(returnFiber, current2, element, lanes) {\n          var elementType = element.type;\n          if (elementType === REACT_FRAGMENT_TYPE) {\n            return updateFragment2(returnFiber, current2, element.props.children, lanes, element.key);\n          }\n          if (current2 !== null) {\n            if (current2.elementType === elementType || isCompatibleFamilyForHotReloading(current2, element) || typeof elementType === \"object\" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current2.type) {\n              var existing = useFiber(current2, element.props);\n              existing.ref = coerceRef(returnFiber, current2, element);\n              existing.return = returnFiber;\n              {\n                existing._debugSource = element._source;\n                existing._debugOwner = element._owner;\n              }\n              return existing;\n            }\n          }\n          var created = createFiberFromElement(element, returnFiber.mode, lanes);\n          created.ref = coerceRef(returnFiber, current2, element);\n          created.return = returnFiber;\n          return created;\n        }\n        function updatePortal(returnFiber, current2, portal, lanes) {\n          if (current2 === null || current2.tag !== HostPortal || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation) {\n            var created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n            created.return = returnFiber;\n            return created;\n          } else {\n            var existing = useFiber(current2, portal.children || []);\n            existing.return = returnFiber;\n            return existing;\n          }\n        }\n        function updateFragment2(returnFiber, current2, fragment, lanes, key) {\n          if (current2 === null || current2.tag !== Fragment) {\n            var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);\n            created.return = returnFiber;\n            return created;\n          } else {\n            var existing = useFiber(current2, fragment);\n            existing.return = returnFiber;\n            return existing;\n          }\n        }\n        function createChild(returnFiber, newChild, lanes) {\n          if (typeof newChild === \"string\" && newChild !== \"\" || typeof newChild === \"number\") {\n            var created = createFiberFromText(\"\" + newChild, returnFiber.mode, lanes);\n            created.return = returnFiber;\n            return created;\n          }\n          if (typeof newChild === \"object\" && newChild !== null) {\n            switch (newChild.$$typeof) {\n              case REACT_ELEMENT_TYPE: {\n                var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);\n                _created.ref = coerceRef(returnFiber, null, newChild);\n                _created.return = returnFiber;\n                return _created;\n              }\n              case REACT_PORTAL_TYPE: {\n                var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);\n                _created2.return = returnFiber;\n                return _created2;\n              }\n              case REACT_LAZY_TYPE: {\n                var payload = newChild._payload;\n                var init = newChild._init;\n                return createChild(returnFiber, init(payload), lanes);\n              }\n            }\n            if (isArray(newChild) || getIteratorFn(newChild)) {\n              var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);\n              _created3.return = returnFiber;\n              return _created3;\n            }\n            throwOnInvalidObjectType(returnFiber, newChild);\n          }\n          {\n            if (typeof newChild === \"function\") {\n              warnOnFunctionType(returnFiber);\n            }\n          }\n          return null;\n        }\n        function updateSlot(returnFiber, oldFiber, newChild, lanes) {\n          var key = oldFiber !== null ? oldFiber.key : null;\n          if (typeof newChild === \"string\" && newChild !== \"\" || typeof newChild === \"number\") {\n            if (key !== null) {\n              return null;\n            }\n            return updateTextNode(returnFiber, oldFiber, \"\" + newChild, lanes);\n          }\n          if (typeof newChild === \"object\" && newChild !== null) {\n            switch (newChild.$$typeof) {\n              case REACT_ELEMENT_TYPE: {\n                if (newChild.key === key) {\n                  return updateElement(returnFiber, oldFiber, newChild, lanes);\n                } else {\n                  return null;\n                }\n              }\n              case REACT_PORTAL_TYPE: {\n                if (newChild.key === key) {\n                  return updatePortal(returnFiber, oldFiber, newChild, lanes);\n                } else {\n                  return null;\n                }\n              }\n              case REACT_LAZY_TYPE: {\n                var payload = newChild._payload;\n                var init = newChild._init;\n                return updateSlot(returnFiber, oldFiber, init(payload), lanes);\n              }\n            }\n            if (isArray(newChild) || getIteratorFn(newChild)) {\n              if (key !== null) {\n                return null;\n              }\n              return updateFragment2(returnFiber, oldFiber, newChild, lanes, null);\n            }\n            throwOnInvalidObjectType(returnFiber, newChild);\n          }\n          {\n            if (typeof newChild === \"function\") {\n              warnOnFunctionType(returnFiber);\n            }\n          }\n          return null;\n        }\n        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {\n          if (typeof newChild === \"string\" && newChild !== \"\" || typeof newChild === \"number\") {\n            var matchedFiber = existingChildren.get(newIdx) || null;\n            return updateTextNode(returnFiber, matchedFiber, \"\" + newChild, lanes);\n          }\n          if (typeof newChild === \"object\" && newChild !== null) {\n            switch (newChild.$$typeof) {\n              case REACT_ELEMENT_TYPE: {\n                var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n                return updateElement(returnFiber, _matchedFiber, newChild, lanes);\n              }\n              case REACT_PORTAL_TYPE: {\n                var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n                return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);\n              }\n              case REACT_LAZY_TYPE:\n                var payload = newChild._payload;\n                var init = newChild._init;\n                return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes);\n            }\n            if (isArray(newChild) || getIteratorFn(newChild)) {\n              var _matchedFiber3 = existingChildren.get(newIdx) || null;\n              return updateFragment2(returnFiber, _matchedFiber3, newChild, lanes, null);\n            }\n            throwOnInvalidObjectType(returnFiber, newChild);\n          }\n          {\n            if (typeof newChild === \"function\") {\n              warnOnFunctionType(returnFiber);\n            }\n          }\n          return null;\n        }\n        function warnOnInvalidKey(child, knownKeys, returnFiber) {\n          {\n            if (typeof child !== \"object\" || child === null) {\n              return knownKeys;\n            }\n            switch (child.$$typeof) {\n              case REACT_ELEMENT_TYPE:\n              case REACT_PORTAL_TYPE:\n                warnForMissingKey(child, returnFiber);\n                var key = child.key;\n                if (typeof key !== \"string\") {\n                  break;\n                }\n                if (knownKeys === null) {\n                  knownKeys = new Set;\n                  knownKeys.add(key);\n                  break;\n                }\n                if (!knownKeys.has(key)) {\n                  knownKeys.add(key);\n                  break;\n                }\n                error(\"Encountered two children with the same key, `%s`. \" + \"Keys should be unique so that components maintain their identity \" + \"across updates. Non-unique keys may cause children to be \" + \"duplicated and/or omitted  the behavior is unsupported and \" + \"could change in a future version.\", key);\n                break;\n              case REACT_LAZY_TYPE:\n                var payload = child._payload;\n                var init = child._init;\n                warnOnInvalidKey(init(payload), knownKeys, returnFiber);\n                break;\n            }\n          }\n          return knownKeys;\n        }\n        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {\n          {\n            var knownKeys = null;\n            for (var i = 0;i < newChildren.length; i++) {\n              var child = newChildren[i];\n              knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n            }\n          }\n          var resultingFirstChild = null;\n          var previousNewFiber = null;\n          var oldFiber = currentFirstChild;\n          var lastPlacedIndex = 0;\n          var newIdx = 0;\n          var nextOldFiber = null;\n          for (;oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n            if (oldFiber.index > newIdx) {\n              nextOldFiber = oldFiber;\n              oldFiber = null;\n            } else {\n              nextOldFiber = oldFiber.sibling;\n            }\n            var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);\n            if (newFiber === null) {\n              if (oldFiber === null) {\n                oldFiber = nextOldFiber;\n              }\n              break;\n            }\n            if (shouldTrackSideEffects) {\n              if (oldFiber && newFiber.alternate === null) {\n                deleteChild(returnFiber, oldFiber);\n              }\n            }\n            lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n            if (previousNewFiber === null) {\n              resultingFirstChild = newFiber;\n            } else {\n              previousNewFiber.sibling = newFiber;\n            }\n            previousNewFiber = newFiber;\n            oldFiber = nextOldFiber;\n          }\n          if (newIdx === newChildren.length) {\n            deleteRemainingChildren(returnFiber, oldFiber);\n            if (getIsHydrating()) {\n              var numberOfForks = newIdx;\n              pushTreeFork(returnFiber, numberOfForks);\n            }\n            return resultingFirstChild;\n          }\n          if (oldFiber === null) {\n            for (;newIdx < newChildren.length; newIdx++) {\n              var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);\n              if (_newFiber === null) {\n                continue;\n              }\n              lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n              if (previousNewFiber === null) {\n                resultingFirstChild = _newFiber;\n              } else {\n                previousNewFiber.sibling = _newFiber;\n              }\n              previousNewFiber = _newFiber;\n            }\n            if (getIsHydrating()) {\n              var _numberOfForks = newIdx;\n              pushTreeFork(returnFiber, _numberOfForks);\n            }\n            return resultingFirstChild;\n          }\n          var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n          for (;newIdx < newChildren.length; newIdx++) {\n            var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);\n            if (_newFiber2 !== null) {\n              if (shouldTrackSideEffects) {\n                if (_newFiber2.alternate !== null) {\n                  existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);\n                }\n              }\n              lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n              if (previousNewFiber === null) {\n                resultingFirstChild = _newFiber2;\n              } else {\n                previousNewFiber.sibling = _newFiber2;\n              }\n              previousNewFiber = _newFiber2;\n            }\n          }\n          if (shouldTrackSideEffects) {\n            existingChildren.forEach(function(child2) {\n              return deleteChild(returnFiber, child2);\n            });\n          }\n          if (getIsHydrating()) {\n            var _numberOfForks2 = newIdx;\n            pushTreeFork(returnFiber, _numberOfForks2);\n          }\n          return resultingFirstChild;\n        }\n        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {\n          var iteratorFn = getIteratorFn(newChildrenIterable);\n          if (typeof iteratorFn !== \"function\") {\n            throw new Error(\"An object is not an iterable. This error is likely caused by a bug in \" + \"React. Please file an issue.\");\n          }\n          {\n            if (typeof Symbol === \"function\" && newChildrenIterable[Symbol.toStringTag] === \"Generator\") {\n              if (!didWarnAboutGenerators) {\n                error(\"Using Generators as children is unsupported and will likely yield \" + \"unexpected results because enumerating a generator mutates it. \" + \"You may convert it to an array with `Array.from()` or the \" + \"`[...spread]` operator before rendering. Keep in mind \" + \"you might need to polyfill these features for older browsers.\");\n              }\n              didWarnAboutGenerators = true;\n            }\n            if (newChildrenIterable.entries === iteratorFn) {\n              if (!didWarnAboutMaps) {\n                error(\"Using Maps as children is not supported. \" + \"Use an array of keyed ReactElements instead.\");\n              }\n              didWarnAboutMaps = true;\n            }\n            var _newChildren = iteratorFn.call(newChildrenIterable);\n            if (_newChildren) {\n              var knownKeys = null;\n              var _step = _newChildren.next();\n              for (;!_step.done; _step = _newChildren.next()) {\n                var child = _step.value;\n                knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n              }\n            }\n          }\n          var newChildren = iteratorFn.call(newChildrenIterable);\n          if (newChildren == null) {\n            throw new Error(\"An iterable object provided no iterator.\");\n          }\n          var resultingFirstChild = null;\n          var previousNewFiber = null;\n          var oldFiber = currentFirstChild;\n          var lastPlacedIndex = 0;\n          var newIdx = 0;\n          var nextOldFiber = null;\n          var step = newChildren.next();\n          for (;oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {\n            if (oldFiber.index > newIdx) {\n              nextOldFiber = oldFiber;\n              oldFiber = null;\n            } else {\n              nextOldFiber = oldFiber.sibling;\n            }\n            var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);\n            if (newFiber === null) {\n              if (oldFiber === null) {\n                oldFiber = nextOldFiber;\n              }\n              break;\n            }\n            if (shouldTrackSideEffects) {\n              if (oldFiber && newFiber.alternate === null) {\n                deleteChild(returnFiber, oldFiber);\n              }\n            }\n            lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n            if (previousNewFiber === null) {\n              resultingFirstChild = newFiber;\n            } else {\n              previousNewFiber.sibling = newFiber;\n            }\n            previousNewFiber = newFiber;\n            oldFiber = nextOldFiber;\n          }\n          if (step.done) {\n            deleteRemainingChildren(returnFiber, oldFiber);\n            if (getIsHydrating()) {\n              var numberOfForks = newIdx;\n              pushTreeFork(returnFiber, numberOfForks);\n            }\n            return resultingFirstChild;\n          }\n          if (oldFiber === null) {\n            for (;!step.done; newIdx++, step = newChildren.next()) {\n              var _newFiber3 = createChild(returnFiber, step.value, lanes);\n              if (_newFiber3 === null) {\n                continue;\n              }\n              lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n              if (previousNewFiber === null) {\n                resultingFirstChild = _newFiber3;\n              } else {\n                previousNewFiber.sibling = _newFiber3;\n              }\n              previousNewFiber = _newFiber3;\n            }\n            if (getIsHydrating()) {\n              var _numberOfForks3 = newIdx;\n              pushTreeFork(returnFiber, _numberOfForks3);\n            }\n            return resultingFirstChild;\n          }\n          var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n          for (;!step.done; newIdx++, step = newChildren.next()) {\n            var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);\n            if (_newFiber4 !== null) {\n              if (shouldTrackSideEffects) {\n                if (_newFiber4.alternate !== null) {\n                  existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);\n                }\n              }\n              lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n              if (previousNewFiber === null) {\n                resultingFirstChild = _newFiber4;\n              } else {\n                previousNewFiber.sibling = _newFiber4;\n              }\n              previousNewFiber = _newFiber4;\n            }\n          }\n          if (shouldTrackSideEffects) {\n            existingChildren.forEach(function(child2) {\n              return deleteChild(returnFiber, child2);\n            });\n          }\n          if (getIsHydrating()) {\n            var _numberOfForks4 = newIdx;\n            pushTreeFork(returnFiber, _numberOfForks4);\n          }\n          return resultingFirstChild;\n        }\n        function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {\n          if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n            deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n            var existing = useFiber(currentFirstChild, textContent);\n            existing.return = returnFiber;\n            return existing;\n          }\n          deleteRemainingChildren(returnFiber, currentFirstChild);\n          var created = createFiberFromText(textContent, returnFiber.mode, lanes);\n          created.return = returnFiber;\n          return created;\n        }\n        function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {\n          var key = element.key;\n          var child = currentFirstChild;\n          while (child !== null) {\n            if (child.key === key) {\n              var elementType = element.type;\n              if (elementType === REACT_FRAGMENT_TYPE) {\n                if (child.tag === Fragment) {\n                  deleteRemainingChildren(returnFiber, child.sibling);\n                  var existing = useFiber(child, element.props.children);\n                  existing.return = returnFiber;\n                  {\n                    existing._debugSource = element._source;\n                    existing._debugOwner = element._owner;\n                  }\n                  return existing;\n                }\n              } else {\n                if (child.elementType === elementType || isCompatibleFamilyForHotReloading(child, element) || typeof elementType === \"object\" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {\n                  deleteRemainingChildren(returnFiber, child.sibling);\n                  var _existing = useFiber(child, element.props);\n                  _existing.ref = coerceRef(returnFiber, child, element);\n                  _existing.return = returnFiber;\n                  {\n                    _existing._debugSource = element._source;\n                    _existing._debugOwner = element._owner;\n                  }\n                  return _existing;\n                }\n              }\n              deleteRemainingChildren(returnFiber, child);\n              break;\n            } else {\n              deleteChild(returnFiber, child);\n            }\n            child = child.sibling;\n          }\n          if (element.type === REACT_FRAGMENT_TYPE) {\n            var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);\n            created.return = returnFiber;\n            return created;\n          } else {\n            var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);\n            _created4.ref = coerceRef(returnFiber, currentFirstChild, element);\n            _created4.return = returnFiber;\n            return _created4;\n          }\n        }\n        function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {\n          var key = portal.key;\n          var child = currentFirstChild;\n          while (child !== null) {\n            if (child.key === key) {\n              if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n                deleteRemainingChildren(returnFiber, child.sibling);\n                var existing = useFiber(child, portal.children || []);\n                existing.return = returnFiber;\n                return existing;\n              } else {\n                deleteRemainingChildren(returnFiber, child);\n                break;\n              }\n            } else {\n              deleteChild(returnFiber, child);\n            }\n            child = child.sibling;\n          }\n          var created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n          created.return = returnFiber;\n          return created;\n        }\n        function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, lanes) {\n          var isUnkeyedTopLevelFragment = typeof newChild === \"object\" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;\n          if (isUnkeyedTopLevelFragment) {\n            newChild = newChild.props.children;\n          }\n          if (typeof newChild === \"object\" && newChild !== null) {\n            switch (newChild.$$typeof) {\n              case REACT_ELEMENT_TYPE:\n                return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));\n              case REACT_PORTAL_TYPE:\n                return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));\n              case REACT_LAZY_TYPE:\n                var payload = newChild._payload;\n                var init = newChild._init;\n                return reconcileChildFibers2(returnFiber, currentFirstChild, init(payload), lanes);\n            }\n            if (isArray(newChild)) {\n              return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);\n            }\n            if (getIteratorFn(newChild)) {\n              return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);\n            }\n            throwOnInvalidObjectType(returnFiber, newChild);\n          }\n          if (typeof newChild === \"string\" && newChild !== \"\" || typeof newChild === \"number\") {\n            return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, \"\" + newChild, lanes));\n          }\n          {\n            if (typeof newChild === \"function\") {\n              warnOnFunctionType(returnFiber);\n            }\n          }\n          return deleteRemainingChildren(returnFiber, currentFirstChild);\n        }\n        return reconcileChildFibers2;\n      }\n      var reconcileChildFibers = ChildReconciler(true);\n      var mountChildFibers = ChildReconciler(false);\n      function cloneChildFibers(current2, workInProgress2) {\n        if (current2 !== null && workInProgress2.child !== current2.child) {\n          throw new Error(\"Resuming work not yet implemented.\");\n        }\n        if (workInProgress2.child === null) {\n          return;\n        }\n        var currentChild = workInProgress2.child;\n        var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);\n        workInProgress2.child = newChild;\n        newChild.return = workInProgress2;\n        while (currentChild.sibling !== null) {\n          currentChild = currentChild.sibling;\n          newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);\n          newChild.return = workInProgress2;\n        }\n        newChild.sibling = null;\n      }\n      function resetChildFibers(workInProgress2, lanes) {\n        var child = workInProgress2.child;\n        while (child !== null) {\n          resetWorkInProgress(child, lanes);\n          child = child.sibling;\n        }\n      }\n      var valueCursor = createCursor(null);\n      var rendererSigil;\n      {\n        rendererSigil = {};\n      }\n      var currentlyRenderingFiber = null;\n      var lastContextDependency = null;\n      var lastFullyObservedContext = null;\n      var isDisallowedContextReadInDEV = false;\n      function resetContextDependencies() {\n        currentlyRenderingFiber = null;\n        lastContextDependency = null;\n        lastFullyObservedContext = null;\n        {\n          isDisallowedContextReadInDEV = false;\n        }\n      }\n      function enterDisallowedContextReadInDEV() {\n        {\n          isDisallowedContextReadInDEV = true;\n        }\n      }\n      function exitDisallowedContextReadInDEV() {\n        {\n          isDisallowedContextReadInDEV = false;\n        }\n      }\n      function pushProvider(providerFiber, context, nextValue) {\n        {\n          push(valueCursor, context._currentValue, providerFiber);\n          context._currentValue = nextValue;\n          {\n            if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {\n              error(\"Detected multiple renderers concurrently rendering the \" + \"same context provider. This is currently unsupported.\");\n            }\n            context._currentRenderer = rendererSigil;\n          }\n        }\n      }\n      function popProvider(context, providerFiber) {\n        var currentValue = valueCursor.current;\n        pop(valueCursor, providerFiber);\n        {\n          {\n            context._currentValue = currentValue;\n          }\n        }\n      }\n      function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {\n        var node = parent;\n        while (node !== null) {\n          var alternate = node.alternate;\n          if (!isSubsetOfLanes(node.childLanes, renderLanes2)) {\n            node.childLanes = mergeLanes(node.childLanes, renderLanes2);\n            if (alternate !== null) {\n              alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);\n            }\n          } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes2)) {\n            alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);\n          }\n          if (node === propagationRoot) {\n            break;\n          }\n          node = node.return;\n        }\n        {\n          if (node !== propagationRoot) {\n            error(\"Expected to find the propagation root when scheduling context work. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n          }\n        }\n      }\n      function propagateContextChange(workInProgress2, context, renderLanes2) {\n        {\n          propagateContextChange_eager(workInProgress2, context, renderLanes2);\n        }\n      }\n      function propagateContextChange_eager(workInProgress2, context, renderLanes2) {\n        var fiber = workInProgress2.child;\n        if (fiber !== null) {\n          fiber.return = workInProgress2;\n        }\n        while (fiber !== null) {\n          var nextFiber = undefined;\n          var list = fiber.dependencies;\n          if (list !== null) {\n            nextFiber = fiber.child;\n            var dependency = list.firstContext;\n            while (dependency !== null) {\n              if (dependency.context === context) {\n                if (fiber.tag === ClassComponent) {\n                  var lane = pickArbitraryLane(renderLanes2);\n                  var update = createUpdate(NoTimestamp, lane);\n                  update.tag = ForceUpdate;\n                  var updateQueue = fiber.updateQueue;\n                  if (updateQueue === null)\n                    ;\n                  else {\n                    var sharedQueue = updateQueue.shared;\n                    var pending = sharedQueue.pending;\n                    if (pending === null) {\n                      update.next = update;\n                    } else {\n                      update.next = pending.next;\n                      pending.next = update;\n                    }\n                    sharedQueue.pending = update;\n                  }\n                }\n                fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);\n                var alternate = fiber.alternate;\n                if (alternate !== null) {\n                  alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);\n                }\n                scheduleContextWorkOnParentPath(fiber.return, renderLanes2, workInProgress2);\n                list.lanes = mergeLanes(list.lanes, renderLanes2);\n                break;\n              }\n              dependency = dependency.next;\n            }\n          } else if (fiber.tag === ContextProvider) {\n            nextFiber = fiber.type === workInProgress2.type ? null : fiber.child;\n          } else if (fiber.tag === DehydratedFragment) {\n            var parentSuspense = fiber.return;\n            if (parentSuspense === null) {\n              throw new Error(\"We just came from a parent so we must have had a parent. This is a bug in React.\");\n            }\n            parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes2);\n            var _alternate = parentSuspense.alternate;\n            if (_alternate !== null) {\n              _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes2);\n            }\n            scheduleContextWorkOnParentPath(parentSuspense, renderLanes2, workInProgress2);\n            nextFiber = fiber.sibling;\n          } else {\n            nextFiber = fiber.child;\n          }\n          if (nextFiber !== null) {\n            nextFiber.return = fiber;\n          } else {\n            nextFiber = fiber;\n            while (nextFiber !== null) {\n              if (nextFiber === workInProgress2) {\n                nextFiber = null;\n                break;\n              }\n              var sibling = nextFiber.sibling;\n              if (sibling !== null) {\n                sibling.return = nextFiber.return;\n                nextFiber = sibling;\n                break;\n              }\n              nextFiber = nextFiber.return;\n            }\n          }\n          fiber = nextFiber;\n        }\n      }\n      function prepareToReadContext(workInProgress2, renderLanes2) {\n        currentlyRenderingFiber = workInProgress2;\n        lastContextDependency = null;\n        lastFullyObservedContext = null;\n        var dependencies = workInProgress2.dependencies;\n        if (dependencies !== null) {\n          {\n            var firstContext = dependencies.firstContext;\n            if (firstContext !== null) {\n              if (includesSomeLane(dependencies.lanes, renderLanes2)) {\n                markWorkInProgressReceivedUpdate();\n              }\n              dependencies.firstContext = null;\n            }\n          }\n        }\n      }\n      function readContext(context) {\n        {\n          if (isDisallowedContextReadInDEV) {\n            error(\"Context can only be read while React is rendering. \" + \"In classes, you can read it in the render method or getDerivedStateFromProps. \" + \"In function components, you can read it directly in the function body, but not \" + \"inside Hooks like useReducer() or useMemo().\");\n          }\n        }\n        var value = context._currentValue;\n        if (lastFullyObservedContext === context)\n          ;\n        else {\n          var contextItem = {\n            context,\n            memoizedValue: value,\n            next: null\n          };\n          if (lastContextDependency === null) {\n            if (currentlyRenderingFiber === null) {\n              throw new Error(\"Context can only be read while React is rendering. \" + \"In classes, you can read it in the render method or getDerivedStateFromProps. \" + \"In function components, you can read it directly in the function body, but not \" + \"inside Hooks like useReducer() or useMemo().\");\n            }\n            lastContextDependency = contextItem;\n            currentlyRenderingFiber.dependencies = {\n              lanes: NoLanes,\n              firstContext: contextItem\n            };\n          } else {\n            lastContextDependency = lastContextDependency.next = contextItem;\n          }\n        }\n        return value;\n      }\n      var concurrentQueues = null;\n      function pushConcurrentUpdateQueue(queue) {\n        if (concurrentQueues === null) {\n          concurrentQueues = [queue];\n        } else {\n          concurrentQueues.push(queue);\n        }\n      }\n      function finishQueueingConcurrentUpdates() {\n        if (concurrentQueues !== null) {\n          for (var i = 0;i < concurrentQueues.length; i++) {\n            var queue = concurrentQueues[i];\n            var lastInterleavedUpdate = queue.interleaved;\n            if (lastInterleavedUpdate !== null) {\n              queue.interleaved = null;\n              var firstInterleavedUpdate = lastInterleavedUpdate.next;\n              var lastPendingUpdate = queue.pending;\n              if (lastPendingUpdate !== null) {\n                var firstPendingUpdate = lastPendingUpdate.next;\n                lastPendingUpdate.next = firstInterleavedUpdate;\n                lastInterleavedUpdate.next = firstPendingUpdate;\n              }\n              queue.pending = lastInterleavedUpdate;\n            }\n          }\n          concurrentQueues = null;\n        }\n      }\n      function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {\n        var interleaved = queue.interleaved;\n        if (interleaved === null) {\n          update.next = update;\n          pushConcurrentUpdateQueue(queue);\n        } else {\n          update.next = interleaved.next;\n          interleaved.next = update;\n        }\n        queue.interleaved = update;\n        return markUpdateLaneFromFiberToRoot(fiber, lane);\n      }\n      function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane) {\n        var interleaved = queue.interleaved;\n        if (interleaved === null) {\n          update.next = update;\n          pushConcurrentUpdateQueue(queue);\n        } else {\n          update.next = interleaved.next;\n          interleaved.next = update;\n        }\n        queue.interleaved = update;\n      }\n      function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {\n        var interleaved = queue.interleaved;\n        if (interleaved === null) {\n          update.next = update;\n          pushConcurrentUpdateQueue(queue);\n        } else {\n          update.next = interleaved.next;\n          interleaved.next = update;\n        }\n        queue.interleaved = update;\n        return markUpdateLaneFromFiberToRoot(fiber, lane);\n      }\n      function enqueueConcurrentRenderForLane(fiber, lane) {\n        return markUpdateLaneFromFiberToRoot(fiber, lane);\n      }\n      var unsafe_markUpdateLaneFromFiberToRoot = markUpdateLaneFromFiberToRoot;\n      function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {\n        sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\n        var alternate = sourceFiber.alternate;\n        if (alternate !== null) {\n          alternate.lanes = mergeLanes(alternate.lanes, lane);\n        }\n        {\n          if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {\n            warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n          }\n        }\n        var node = sourceFiber;\n        var parent = sourceFiber.return;\n        while (parent !== null) {\n          parent.childLanes = mergeLanes(parent.childLanes, lane);\n          alternate = parent.alternate;\n          if (alternate !== null) {\n            alternate.childLanes = mergeLanes(alternate.childLanes, lane);\n          } else {\n            {\n              if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {\n                warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n              }\n            }\n          }\n          node = parent;\n          parent = parent.return;\n        }\n        if (node.tag === HostRoot) {\n          var root2 = node.stateNode;\n          return root2;\n        } else {\n          return null;\n        }\n      }\n      var UpdateState = 0;\n      var ReplaceState = 1;\n      var ForceUpdate = 2;\n      var CaptureUpdate = 3;\n      var hasForceUpdate = false;\n      var didWarnUpdateInsideUpdate;\n      var currentlyProcessingQueue;\n      {\n        didWarnUpdateInsideUpdate = false;\n        currentlyProcessingQueue = null;\n      }\n      function initializeUpdateQueue(fiber) {\n        var queue = {\n          baseState: fiber.memoizedState,\n          firstBaseUpdate: null,\n          lastBaseUpdate: null,\n          shared: {\n            pending: null,\n            interleaved: null,\n            lanes: NoLanes\n          },\n          effects: null\n        };\n        fiber.updateQueue = queue;\n      }\n      function cloneUpdateQueue(current2, workInProgress2) {\n        var queue = workInProgress2.updateQueue;\n        var currentQueue = current2.updateQueue;\n        if (queue === currentQueue) {\n          var clone = {\n            baseState: currentQueue.baseState,\n            firstBaseUpdate: currentQueue.firstBaseUpdate,\n            lastBaseUpdate: currentQueue.lastBaseUpdate,\n            shared: currentQueue.shared,\n            effects: currentQueue.effects\n          };\n          workInProgress2.updateQueue = clone;\n        }\n      }\n      function createUpdate(eventTime, lane) {\n        var update = {\n          eventTime,\n          lane,\n          tag: UpdateState,\n          payload: null,\n          callback: null,\n          next: null\n        };\n        return update;\n      }\n      function enqueueUpdate(fiber, update, lane) {\n        var updateQueue = fiber.updateQueue;\n        if (updateQueue === null) {\n          return null;\n        }\n        var sharedQueue = updateQueue.shared;\n        {\n          if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {\n            error(\"An update (setState, replaceState, or forceUpdate) was scheduled \" + \"from inside an update function. Update functions should be pure, \" + \"with zero side-effects. Consider using componentDidUpdate or a \" + \"callback.\");\n            didWarnUpdateInsideUpdate = true;\n          }\n        }\n        if (isUnsafeClassRenderPhaseUpdate()) {\n          var pending = sharedQueue.pending;\n          if (pending === null) {\n            update.next = update;\n          } else {\n            update.next = pending.next;\n            pending.next = update;\n          }\n          sharedQueue.pending = update;\n          return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);\n        } else {\n          return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);\n        }\n      }\n      function entangleTransitions(root2, fiber, lane) {\n        var updateQueue = fiber.updateQueue;\n        if (updateQueue === null) {\n          return;\n        }\n        var sharedQueue = updateQueue.shared;\n        if (isTransitionLane(lane)) {\n          var queueLanes = sharedQueue.lanes;\n          queueLanes = intersectLanes(queueLanes, root2.pendingLanes);\n          var newQueueLanes = mergeLanes(queueLanes, lane);\n          sharedQueue.lanes = newQueueLanes;\n          markRootEntangled(root2, newQueueLanes);\n        }\n      }\n      function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {\n        var queue = workInProgress2.updateQueue;\n        var current2 = workInProgress2.alternate;\n        if (current2 !== null) {\n          var currentQueue = current2.updateQueue;\n          if (queue === currentQueue) {\n            var newFirst = null;\n            var newLast = null;\n            var firstBaseUpdate = queue.firstBaseUpdate;\n            if (firstBaseUpdate !== null) {\n              var update = firstBaseUpdate;\n              do {\n                var clone = {\n                  eventTime: update.eventTime,\n                  lane: update.lane,\n                  tag: update.tag,\n                  payload: update.payload,\n                  callback: update.callback,\n                  next: null\n                };\n                if (newLast === null) {\n                  newFirst = newLast = clone;\n                } else {\n                  newLast.next = clone;\n                  newLast = clone;\n                }\n                update = update.next;\n              } while (update !== null);\n              if (newLast === null) {\n                newFirst = newLast = capturedUpdate;\n              } else {\n                newLast.next = capturedUpdate;\n                newLast = capturedUpdate;\n              }\n            } else {\n              newFirst = newLast = capturedUpdate;\n            }\n            queue = {\n              baseState: currentQueue.baseState,\n              firstBaseUpdate: newFirst,\n              lastBaseUpdate: newLast,\n              shared: currentQueue.shared,\n              effects: currentQueue.effects\n            };\n            workInProgress2.updateQueue = queue;\n            return;\n          }\n        }\n        var lastBaseUpdate = queue.lastBaseUpdate;\n        if (lastBaseUpdate === null) {\n          queue.firstBaseUpdate = capturedUpdate;\n        } else {\n          lastBaseUpdate.next = capturedUpdate;\n        }\n        queue.lastBaseUpdate = capturedUpdate;\n      }\n      function getStateFromUpdate(workInProgress2, queue, update, prevState, nextProps, instance) {\n        switch (update.tag) {\n          case ReplaceState: {\n            var payload = update.payload;\n            if (typeof payload === \"function\") {\n              {\n                enterDisallowedContextReadInDEV();\n              }\n              var nextState = payload.call(instance, prevState, nextProps);\n              {\n                if (workInProgress2.mode & StrictLegacyMode) {\n                  setIsStrictModeForDevtools(true);\n                  try {\n                    payload.call(instance, prevState, nextProps);\n                  } finally {\n                    setIsStrictModeForDevtools(false);\n                  }\n                }\n                exitDisallowedContextReadInDEV();\n              }\n              return nextState;\n            }\n            return payload;\n          }\n          case CaptureUpdate: {\n            workInProgress2.flags = workInProgress2.flags & ~ShouldCapture | DidCapture;\n          }\n          case UpdateState: {\n            var _payload = update.payload;\n            var partialState;\n            if (typeof _payload === \"function\") {\n              {\n                enterDisallowedContextReadInDEV();\n              }\n              partialState = _payload.call(instance, prevState, nextProps);\n              {\n                if (workInProgress2.mode & StrictLegacyMode) {\n                  setIsStrictModeForDevtools(true);\n                  try {\n                    _payload.call(instance, prevState, nextProps);\n                  } finally {\n                    setIsStrictModeForDevtools(false);\n                  }\n                }\n                exitDisallowedContextReadInDEV();\n              }\n            } else {\n              partialState = _payload;\n            }\n            if (partialState === null || partialState === undefined) {\n              return prevState;\n            }\n            return assign({}, prevState, partialState);\n          }\n          case ForceUpdate: {\n            hasForceUpdate = true;\n            return prevState;\n          }\n        }\n        return prevState;\n      }\n      function processUpdateQueue(workInProgress2, props, instance, renderLanes2) {\n        var queue = workInProgress2.updateQueue;\n        hasForceUpdate = false;\n        {\n          currentlyProcessingQueue = queue.shared;\n        }\n        var firstBaseUpdate = queue.firstBaseUpdate;\n        var lastBaseUpdate = queue.lastBaseUpdate;\n        var pendingQueue = queue.shared.pending;\n        if (pendingQueue !== null) {\n          queue.shared.pending = null;\n          var lastPendingUpdate = pendingQueue;\n          var firstPendingUpdate = lastPendingUpdate.next;\n          lastPendingUpdate.next = null;\n          if (lastBaseUpdate === null) {\n            firstBaseUpdate = firstPendingUpdate;\n          } else {\n            lastBaseUpdate.next = firstPendingUpdate;\n          }\n          lastBaseUpdate = lastPendingUpdate;\n          var current2 = workInProgress2.alternate;\n          if (current2 !== null) {\n            var currentQueue = current2.updateQueue;\n            var currentLastBaseUpdate = currentQueue.lastBaseUpdate;\n            if (currentLastBaseUpdate !== lastBaseUpdate) {\n              if (currentLastBaseUpdate === null) {\n                currentQueue.firstBaseUpdate = firstPendingUpdate;\n              } else {\n                currentLastBaseUpdate.next = firstPendingUpdate;\n              }\n              currentQueue.lastBaseUpdate = lastPendingUpdate;\n            }\n          }\n        }\n        if (firstBaseUpdate !== null) {\n          var newState = queue.baseState;\n          var newLanes = NoLanes;\n          var newBaseState = null;\n          var newFirstBaseUpdate = null;\n          var newLastBaseUpdate = null;\n          var update = firstBaseUpdate;\n          do {\n            var updateLane = update.lane;\n            var updateEventTime = update.eventTime;\n            if (!isSubsetOfLanes(renderLanes2, updateLane)) {\n              var clone = {\n                eventTime: updateEventTime,\n                lane: updateLane,\n                tag: update.tag,\n                payload: update.payload,\n                callback: update.callback,\n                next: null\n              };\n              if (newLastBaseUpdate === null) {\n                newFirstBaseUpdate = newLastBaseUpdate = clone;\n                newBaseState = newState;\n              } else {\n                newLastBaseUpdate = newLastBaseUpdate.next = clone;\n              }\n              newLanes = mergeLanes(newLanes, updateLane);\n            } else {\n              if (newLastBaseUpdate !== null) {\n                var _clone = {\n                  eventTime: updateEventTime,\n                  lane: NoLane,\n                  tag: update.tag,\n                  payload: update.payload,\n                  callback: update.callback,\n                  next: null\n                };\n                newLastBaseUpdate = newLastBaseUpdate.next = _clone;\n              }\n              newState = getStateFromUpdate(workInProgress2, queue, update, newState, props, instance);\n              var callback = update.callback;\n              if (callback !== null && update.lane !== NoLane) {\n                workInProgress2.flags |= Callback;\n                var effects = queue.effects;\n                if (effects === null) {\n                  queue.effects = [update];\n                } else {\n                  effects.push(update);\n                }\n              }\n            }\n            update = update.next;\n            if (update === null) {\n              pendingQueue = queue.shared.pending;\n              if (pendingQueue === null) {\n                break;\n              } else {\n                var _lastPendingUpdate = pendingQueue;\n                var _firstPendingUpdate = _lastPendingUpdate.next;\n                _lastPendingUpdate.next = null;\n                update = _firstPendingUpdate;\n                queue.lastBaseUpdate = _lastPendingUpdate;\n                queue.shared.pending = null;\n              }\n            }\n          } while (true);\n          if (newLastBaseUpdate === null) {\n            newBaseState = newState;\n          }\n          queue.baseState = newBaseState;\n          queue.firstBaseUpdate = newFirstBaseUpdate;\n          queue.lastBaseUpdate = newLastBaseUpdate;\n          var lastInterleaved = queue.shared.interleaved;\n          if (lastInterleaved !== null) {\n            var interleaved = lastInterleaved;\n            do {\n              newLanes = mergeLanes(newLanes, interleaved.lane);\n              interleaved = interleaved.next;\n            } while (interleaved !== lastInterleaved);\n          } else if (firstBaseUpdate === null) {\n            queue.shared.lanes = NoLanes;\n          }\n          markSkippedUpdateLanes(newLanes);\n          workInProgress2.lanes = newLanes;\n          workInProgress2.memoizedState = newState;\n        }\n        {\n          currentlyProcessingQueue = null;\n        }\n      }\n      function callCallback(callback, context) {\n        if (typeof callback !== \"function\") {\n          throw new Error(\"Invalid argument passed as callback. Expected a function. Instead \" + (\"received: \" + callback));\n        }\n        callback.call(context);\n      }\n      function resetHasForceUpdateBeforeProcessing() {\n        hasForceUpdate = false;\n      }\n      function checkHasForceUpdateAfterProcessing() {\n        return hasForceUpdate;\n      }\n      function commitUpdateQueue(finishedWork, finishedQueue, instance) {\n        var effects = finishedQueue.effects;\n        finishedQueue.effects = null;\n        if (effects !== null) {\n          for (var i = 0;i < effects.length; i++) {\n            var effect = effects[i];\n            var callback = effect.callback;\n            if (callback !== null) {\n              effect.callback = null;\n              callCallback(callback, instance);\n            }\n          }\n        }\n      }\n      var NO_CONTEXT = {};\n      var contextStackCursor$1 = createCursor(NO_CONTEXT);\n      var contextFiberStackCursor = createCursor(NO_CONTEXT);\n      var rootInstanceStackCursor = createCursor(NO_CONTEXT);\n      function requiredContext(c) {\n        if (c === NO_CONTEXT) {\n          throw new Error(\"Expected host context to exist. This error is likely caused by a bug \" + \"in React. Please file an issue.\");\n        }\n        return c;\n      }\n      function getRootHostContainer() {\n        var rootInstance = requiredContext(rootInstanceStackCursor.current);\n        return rootInstance;\n      }\n      function pushHostContainer(fiber, nextRootInstance) {\n        push(rootInstanceStackCursor, nextRootInstance, fiber);\n        push(contextFiberStackCursor, fiber, fiber);\n        push(contextStackCursor$1, NO_CONTEXT, fiber);\n        var nextRootContext = getRootHostContext(nextRootInstance);\n        pop(contextStackCursor$1, fiber);\n        push(contextStackCursor$1, nextRootContext, fiber);\n      }\n      function popHostContainer(fiber) {\n        pop(contextStackCursor$1, fiber);\n        pop(contextFiberStackCursor, fiber);\n        pop(rootInstanceStackCursor, fiber);\n      }\n      function getHostContext() {\n        var context = requiredContext(contextStackCursor$1.current);\n        return context;\n      }\n      function pushHostContext(fiber) {\n        var rootInstance = requiredContext(rootInstanceStackCursor.current);\n        var context = requiredContext(contextStackCursor$1.current);\n        var nextContext = getChildHostContext(context, fiber.type);\n        if (context === nextContext) {\n          return;\n        }\n        push(contextFiberStackCursor, fiber, fiber);\n        push(contextStackCursor$1, nextContext, fiber);\n      }\n      function popHostContext(fiber) {\n        if (contextFiberStackCursor.current !== fiber) {\n          return;\n        }\n        pop(contextStackCursor$1, fiber);\n        pop(contextFiberStackCursor, fiber);\n      }\n      var DefaultSuspenseContext = 0;\n      var SubtreeSuspenseContextMask = 1;\n      var InvisibleParentSuspenseContext = 1;\n      var ForceSuspenseFallback = 2;\n      var suspenseStackCursor = createCursor(DefaultSuspenseContext);\n      function hasSuspenseContext(parentContext, flag) {\n        return (parentContext & flag) !== 0;\n      }\n      function setDefaultShallowSuspenseContext(parentContext) {\n        return parentContext & SubtreeSuspenseContextMask;\n      }\n      function setShallowSuspenseContext(parentContext, shallowContext) {\n        return parentContext & SubtreeSuspenseContextMask | shallowContext;\n      }\n      function addSubtreeSuspenseContext(parentContext, subtreeContext) {\n        return parentContext | subtreeContext;\n      }\n      function pushSuspenseContext(fiber, newContext) {\n        push(suspenseStackCursor, newContext, fiber);\n      }\n      function popSuspenseContext(fiber) {\n        pop(suspenseStackCursor, fiber);\n      }\n      function shouldCaptureSuspense(workInProgress2, hasInvisibleParent) {\n        var nextState = workInProgress2.memoizedState;\n        if (nextState !== null) {\n          if (nextState.dehydrated !== null) {\n            return true;\n          }\n          return false;\n        }\n        var props = workInProgress2.memoizedProps;\n        {\n          return true;\n        }\n      }\n      function findFirstSuspended(row) {\n        var node = row;\n        while (node !== null) {\n          if (node.tag === SuspenseComponent) {\n            var state = node.memoizedState;\n            if (state !== null) {\n              var dehydrated = state.dehydrated;\n              if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {\n                return node;\n              }\n            }\n          } else if (node.tag === SuspenseListComponent && node.memoizedProps.revealOrder !== undefined) {\n            var didSuspend = (node.flags & DidCapture) !== NoFlags;\n            if (didSuspend) {\n              return node;\n            }\n          } else if (node.child !== null) {\n            node.child.return = node;\n            node = node.child;\n            continue;\n          }\n          if (node === row) {\n            return null;\n          }\n          while (node.sibling === null) {\n            if (node.return === null || node.return === row) {\n              return null;\n            }\n            node = node.return;\n          }\n          node.sibling.return = node.return;\n          node = node.sibling;\n        }\n        return null;\n      }\n      var NoFlags$1 = 0;\n      var HasEffect = 1;\n      var Insertion = 2;\n      var Layout = 4;\n      var Passive$1 = 8;\n      var workInProgressSources = [];\n      function resetWorkInProgressVersions() {\n        for (var i = 0;i < workInProgressSources.length; i++) {\n          var mutableSource = workInProgressSources[i];\n          {\n            mutableSource._workInProgressVersionPrimary = null;\n          }\n        }\n        workInProgressSources.length = 0;\n      }\n      function registerMutableSourceForHydration(root2, mutableSource) {\n        var getVersion = mutableSource._getVersion;\n        var version = getVersion(mutableSource._source);\n        if (root2.mutableSourceEagerHydrationData == null) {\n          root2.mutableSourceEagerHydrationData = [mutableSource, version];\n        } else {\n          root2.mutableSourceEagerHydrationData.push(mutableSource, version);\n        }\n      }\n      var { ReactCurrentDispatcher: ReactCurrentDispatcher$1, ReactCurrentBatchConfig: ReactCurrentBatchConfig$2 } = ReactSharedInternals;\n      var didWarnAboutMismatchedHooksForComponent;\n      var didWarnUncachedGetSnapshot;\n      {\n        didWarnAboutMismatchedHooksForComponent = new Set;\n      }\n      var renderLanes = NoLanes;\n      var currentlyRenderingFiber$1 = null;\n      var currentHook = null;\n      var workInProgressHook = null;\n      var didScheduleRenderPhaseUpdate = false;\n      var didScheduleRenderPhaseUpdateDuringThisPass = false;\n      var localIdCounter = 0;\n      var globalClientIdCounter = 0;\n      var RE_RENDER_LIMIT = 25;\n      var currentHookNameInDev = null;\n      var hookTypesDev = null;\n      var hookTypesUpdateIndexDev = -1;\n      var ignorePreviousDependencies = false;\n      function mountHookTypesDev() {\n        {\n          var hookName = currentHookNameInDev;\n          if (hookTypesDev === null) {\n            hookTypesDev = [hookName];\n          } else {\n            hookTypesDev.push(hookName);\n          }\n        }\n      }\n      function updateHookTypesDev() {\n        {\n          var hookName = currentHookNameInDev;\n          if (hookTypesDev !== null) {\n            hookTypesUpdateIndexDev++;\n            if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {\n              warnOnHookMismatchInDev(hookName);\n            }\n          }\n        }\n      }\n      function checkDepsAreArrayDev(deps) {\n        {\n          if (deps !== undefined && deps !== null && !isArray(deps)) {\n            error(\"%s received a final argument that is not an array (instead, received `%s`). When \" + \"specified, the final argument must be an array.\", currentHookNameInDev, typeof deps);\n          }\n        }\n      }\n      function warnOnHookMismatchInDev(currentHookName) {\n        {\n          var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n          if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {\n            didWarnAboutMismatchedHooksForComponent.add(componentName);\n            if (hookTypesDev !== null) {\n              var table = \"\";\n              var secondColumnStart = 30;\n              for (var i = 0;i <= hookTypesUpdateIndexDev; i++) {\n                var oldHookName = hookTypesDev[i];\n                var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;\n                var row = i + 1 + \". \" + oldHookName;\n                while (row.length < secondColumnStart) {\n                  row += \" \";\n                }\n                row += newHookName + `\n`;\n                table += row;\n              }\n              error(\"React has detected a change in the order of Hooks called by %s. \" + \"This will lead to bugs and errors if not fixed. \" + `For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n` + `   Previous render            Next render\n` + `   ------------------------------------------------------\n` + \"%s\" + `   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n`, componentName, table);\n            }\n          }\n        }\n      }\n      function throwInvalidHookError() {\n        throw new Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for\" + ` one of the following reasons:\n` + `1. You might have mismatching versions of React and the renderer (such as React DOM)\n` + `2. You might be breaking the Rules of Hooks\n` + `3. You might have more than one copy of React in the same app\n` + \"See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.\");\n      }\n      function areHookInputsEqual(nextDeps, prevDeps) {\n        {\n          if (ignorePreviousDependencies) {\n            return false;\n          }\n        }\n        if (prevDeps === null) {\n          {\n            error(\"%s received a final argument during this render, but not during \" + \"the previous render. Even though the final argument is optional, \" + \"its type cannot change between renders.\", currentHookNameInDev);\n          }\n          return false;\n        }\n        {\n          if (nextDeps.length !== prevDeps.length) {\n            error(\"The final argument passed to %s changed size between renders. The \" + `order and size of this array must remain constant.\n\n` + `Previous: %s\n` + \"Incoming: %s\", currentHookNameInDev, \"[\" + prevDeps.join(\", \") + \"]\", \"[\" + nextDeps.join(\", \") + \"]\");\n          }\n        }\n        for (var i = 0;i < prevDeps.length && i < nextDeps.length; i++) {\n          if (objectIs(nextDeps[i], prevDeps[i])) {\n            continue;\n          }\n          return false;\n        }\n        return true;\n      }\n      function renderWithHooks(current2, workInProgress2, Component, props, secondArg, nextRenderLanes) {\n        renderLanes = nextRenderLanes;\n        currentlyRenderingFiber$1 = workInProgress2;\n        {\n          hookTypesDev = current2 !== null ? current2._debugHookTypes : null;\n          hookTypesUpdateIndexDev = -1;\n          ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;\n        }\n        workInProgress2.memoizedState = null;\n        workInProgress2.updateQueue = null;\n        workInProgress2.lanes = NoLanes;\n        {\n          if (current2 !== null && current2.memoizedState !== null) {\n            ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;\n          } else if (hookTypesDev !== null) {\n            ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;\n          } else {\n            ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;\n          }\n        }\n        var children = Component(props, secondArg);\n        if (didScheduleRenderPhaseUpdateDuringThisPass) {\n          var numberOfReRenders = 0;\n          do {\n            didScheduleRenderPhaseUpdateDuringThisPass = false;\n            localIdCounter = 0;\n            if (numberOfReRenders >= RE_RENDER_LIMIT) {\n              throw new Error(\"Too many re-renders. React limits the number of renders to prevent \" + \"an infinite loop.\");\n            }\n            numberOfReRenders += 1;\n            {\n              ignorePreviousDependencies = false;\n            }\n            currentHook = null;\n            workInProgressHook = null;\n            workInProgress2.updateQueue = null;\n            {\n              hookTypesUpdateIndexDev = -1;\n            }\n            ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;\n            children = Component(props, secondArg);\n          } while (didScheduleRenderPhaseUpdateDuringThisPass);\n        }\n        ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;\n        {\n          workInProgress2._debugHookTypes = hookTypesDev;\n        }\n        var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;\n        renderLanes = NoLanes;\n        currentlyRenderingFiber$1 = null;\n        currentHook = null;\n        workInProgressHook = null;\n        {\n          currentHookNameInDev = null;\n          hookTypesDev = null;\n          hookTypesUpdateIndexDev = -1;\n          if (current2 !== null && (current2.flags & StaticMask) !== (workInProgress2.flags & StaticMask) && (current2.mode & ConcurrentMode) !== NoMode) {\n            error(\"Internal React error: Expected static flag was missing. Please \" + \"notify the React team.\");\n          }\n        }\n        didScheduleRenderPhaseUpdate = false;\n        if (didRenderTooFewHooks) {\n          throw new Error(\"Rendered fewer hooks than expected. This may be caused by an accidental \" + \"early return statement.\");\n        }\n        return children;\n      }\n      function checkDidRenderIdHook() {\n        var didRenderIdHook = localIdCounter !== 0;\n        localIdCounter = 0;\n        return didRenderIdHook;\n      }\n      function bailoutHooks(current2, workInProgress2, lanes) {\n        workInProgress2.updateQueue = current2.updateQueue;\n        if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {\n          workInProgress2.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update);\n        } else {\n          workInProgress2.flags &= ~(Passive | Update);\n        }\n        current2.lanes = removeLanes(current2.lanes, lanes);\n      }\n      function resetHooksAfterThrow() {\n        ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;\n        if (didScheduleRenderPhaseUpdate) {\n          var hook = currentlyRenderingFiber$1.memoizedState;\n          while (hook !== null) {\n            var queue = hook.queue;\n            if (queue !== null) {\n              queue.pending = null;\n            }\n            hook = hook.next;\n          }\n          didScheduleRenderPhaseUpdate = false;\n        }\n        renderLanes = NoLanes;\n        currentlyRenderingFiber$1 = null;\n        currentHook = null;\n        workInProgressHook = null;\n        {\n          hookTypesDev = null;\n          hookTypesUpdateIndexDev = -1;\n          currentHookNameInDev = null;\n          isUpdatingOpaqueValueInRenderPhase = false;\n        }\n        didScheduleRenderPhaseUpdateDuringThisPass = false;\n        localIdCounter = 0;\n      }\n      function mountWorkInProgressHook() {\n        var hook = {\n          memoizedState: null,\n          baseState: null,\n          baseQueue: null,\n          queue: null,\n          next: null\n        };\n        if (workInProgressHook === null) {\n          currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;\n        } else {\n          workInProgressHook = workInProgressHook.next = hook;\n        }\n        return workInProgressHook;\n      }\n      function updateWorkInProgressHook() {\n        var nextCurrentHook;\n        if (currentHook === null) {\n          var current2 = currentlyRenderingFiber$1.alternate;\n          if (current2 !== null) {\n            nextCurrentHook = current2.memoizedState;\n          } else {\n            nextCurrentHook = null;\n          }\n        } else {\n          nextCurrentHook = currentHook.next;\n        }\n        var nextWorkInProgressHook;\n        if (workInProgressHook === null) {\n          nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;\n        } else {\n          nextWorkInProgressHook = workInProgressHook.next;\n        }\n        if (nextWorkInProgressHook !== null) {\n          workInProgressHook = nextWorkInProgressHook;\n          nextWorkInProgressHook = workInProgressHook.next;\n          currentHook = nextCurrentHook;\n        } else {\n          if (nextCurrentHook === null) {\n            throw new Error(\"Rendered more hooks than during the previous render.\");\n          }\n          currentHook = nextCurrentHook;\n          var newHook = {\n            memoizedState: currentHook.memoizedState,\n            baseState: currentHook.baseState,\n            baseQueue: currentHook.baseQueue,\n            queue: currentHook.queue,\n            next: null\n          };\n          if (workInProgressHook === null) {\n            currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;\n          } else {\n            workInProgressHook = workInProgressHook.next = newHook;\n          }\n        }\n        return workInProgressHook;\n      }\n      function createFunctionComponentUpdateQueue() {\n        return {\n          lastEffect: null,\n          stores: null\n        };\n      }\n      function basicStateReducer(state, action) {\n        return typeof action === \"function\" ? action(state) : action;\n      }\n      function mountReducer(reducer, initialArg, init) {\n        var hook = mountWorkInProgressHook();\n        var initialState;\n        if (init !== undefined) {\n          initialState = init(initialArg);\n        } else {\n          initialState = initialArg;\n        }\n        hook.memoizedState = hook.baseState = initialState;\n        var queue = {\n          pending: null,\n          interleaved: null,\n          lanes: NoLanes,\n          dispatch: null,\n          lastRenderedReducer: reducer,\n          lastRenderedState: initialState\n        };\n        hook.queue = queue;\n        var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);\n        return [hook.memoizedState, dispatch];\n      }\n      function updateReducer(reducer, initialArg, init) {\n        var hook = updateWorkInProgressHook();\n        var queue = hook.queue;\n        if (queue === null) {\n          throw new Error(\"Should have a queue. This is likely a bug in React. Please file an issue.\");\n        }\n        queue.lastRenderedReducer = reducer;\n        var current2 = currentHook;\n        var baseQueue = current2.baseQueue;\n        var pendingQueue = queue.pending;\n        if (pendingQueue !== null) {\n          if (baseQueue !== null) {\n            var baseFirst = baseQueue.next;\n            var pendingFirst = pendingQueue.next;\n            baseQueue.next = pendingFirst;\n            pendingQueue.next = baseFirst;\n          }\n          {\n            if (current2.baseQueue !== baseQueue) {\n              error(\"Internal error: Expected work-in-progress queue to be a clone. \" + \"This is a bug in React.\");\n            }\n          }\n          current2.baseQueue = baseQueue = pendingQueue;\n          queue.pending = null;\n        }\n        if (baseQueue !== null) {\n          var first = baseQueue.next;\n          var newState = current2.baseState;\n          var newBaseState = null;\n          var newBaseQueueFirst = null;\n          var newBaseQueueLast = null;\n          var update = first;\n          do {\n            var updateLane = update.lane;\n            if (!isSubsetOfLanes(renderLanes, updateLane)) {\n              var clone = {\n                lane: updateLane,\n                action: update.action,\n                hasEagerState: update.hasEagerState,\n                eagerState: update.eagerState,\n                next: null\n              };\n              if (newBaseQueueLast === null) {\n                newBaseQueueFirst = newBaseQueueLast = clone;\n                newBaseState = newState;\n              } else {\n                newBaseQueueLast = newBaseQueueLast.next = clone;\n              }\n              currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);\n              markSkippedUpdateLanes(updateLane);\n            } else {\n              if (newBaseQueueLast !== null) {\n                var _clone = {\n                  lane: NoLane,\n                  action: update.action,\n                  hasEagerState: update.hasEagerState,\n                  eagerState: update.eagerState,\n                  next: null\n                };\n                newBaseQueueLast = newBaseQueueLast.next = _clone;\n              }\n              if (update.hasEagerState) {\n                newState = update.eagerState;\n              } else {\n                var action = update.action;\n                newState = reducer(newState, action);\n              }\n            }\n            update = update.next;\n          } while (update !== null && update !== first);\n          if (newBaseQueueLast === null) {\n            newBaseState = newState;\n          } else {\n            newBaseQueueLast.next = newBaseQueueFirst;\n          }\n          if (!objectIs(newState, hook.memoizedState)) {\n            markWorkInProgressReceivedUpdate();\n          }\n          hook.memoizedState = newState;\n          hook.baseState = newBaseState;\n          hook.baseQueue = newBaseQueueLast;\n          queue.lastRenderedState = newState;\n        }\n        var lastInterleaved = queue.interleaved;\n        if (lastInterleaved !== null) {\n          var interleaved = lastInterleaved;\n          do {\n            var interleavedLane = interleaved.lane;\n            currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);\n            markSkippedUpdateLanes(interleavedLane);\n            interleaved = interleaved.next;\n          } while (interleaved !== lastInterleaved);\n        } else if (baseQueue === null) {\n          queue.lanes = NoLanes;\n        }\n        var dispatch = queue.dispatch;\n        return [hook.memoizedState, dispatch];\n      }\n      function rerenderReducer(reducer, initialArg, init) {\n        var hook = updateWorkInProgressHook();\n        var queue = hook.queue;\n        if (queue === null) {\n          throw new Error(\"Should have a queue. This is likely a bug in React. Please file an issue.\");\n        }\n        queue.lastRenderedReducer = reducer;\n        var dispatch = queue.dispatch;\n        var lastRenderPhaseUpdate = queue.pending;\n        var newState = hook.memoizedState;\n        if (lastRenderPhaseUpdate !== null) {\n          queue.pending = null;\n          var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n          var update = firstRenderPhaseUpdate;\n          do {\n            var action = update.action;\n            newState = reducer(newState, action);\n            update = update.next;\n          } while (update !== firstRenderPhaseUpdate);\n          if (!objectIs(newState, hook.memoizedState)) {\n            markWorkInProgressReceivedUpdate();\n          }\n          hook.memoizedState = newState;\n          if (hook.baseQueue === null) {\n            hook.baseState = newState;\n          }\n          queue.lastRenderedState = newState;\n        }\n        return [newState, dispatch];\n      }\n      function mountMutableSource(source, getSnapshot, subscribe) {\n        {\n          return;\n        }\n      }\n      function updateMutableSource(source, getSnapshot, subscribe) {\n        {\n          return;\n        }\n      }\n      function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n        var fiber = currentlyRenderingFiber$1;\n        var hook = mountWorkInProgressHook();\n        var nextSnapshot;\n        var isHydrating2 = getIsHydrating();\n        if (isHydrating2) {\n          if (getServerSnapshot === undefined) {\n            throw new Error(\"Missing getServerSnapshot, which is required for \" + \"server-rendered content. Will revert to client rendering.\");\n          }\n          nextSnapshot = getServerSnapshot();\n          {\n            if (!didWarnUncachedGetSnapshot) {\n              if (nextSnapshot !== getServerSnapshot()) {\n                error(\"The result of getServerSnapshot should be cached to avoid an infinite loop\");\n                didWarnUncachedGetSnapshot = true;\n              }\n            }\n          }\n        } else {\n          nextSnapshot = getSnapshot();\n          {\n            if (!didWarnUncachedGetSnapshot) {\n              var cachedSnapshot = getSnapshot();\n              if (!objectIs(nextSnapshot, cachedSnapshot)) {\n                error(\"The result of getSnapshot should be cached to avoid an infinite loop\");\n                didWarnUncachedGetSnapshot = true;\n              }\n            }\n          }\n          var root2 = getWorkInProgressRoot();\n          if (root2 === null) {\n            throw new Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n          }\n          if (!includesBlockingLane(root2, renderLanes)) {\n            pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n          }\n        }\n        hook.memoizedState = nextSnapshot;\n        var inst = {\n          value: nextSnapshot,\n          getSnapshot\n        };\n        hook.queue = inst;\n        mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);\n        fiber.flags |= Passive;\n        pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), undefined, null);\n        return nextSnapshot;\n      }\n      function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n        var fiber = currentlyRenderingFiber$1;\n        var hook = updateWorkInProgressHook();\n        var nextSnapshot = getSnapshot();\n        {\n          if (!didWarnUncachedGetSnapshot) {\n            var cachedSnapshot = getSnapshot();\n            if (!objectIs(nextSnapshot, cachedSnapshot)) {\n              error(\"The result of getSnapshot should be cached to avoid an infinite loop\");\n              didWarnUncachedGetSnapshot = true;\n            }\n          }\n        }\n        var prevSnapshot = hook.memoizedState;\n        var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);\n        if (snapshotChanged) {\n          hook.memoizedState = nextSnapshot;\n          markWorkInProgressReceivedUpdate();\n        }\n        var inst = hook.queue;\n        updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);\n        if (inst.getSnapshot !== getSnapshot || snapshotChanged || workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {\n          fiber.flags |= Passive;\n          pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), undefined, null);\n          var root2 = getWorkInProgressRoot();\n          if (root2 === null) {\n            throw new Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n          }\n          if (!includesBlockingLane(root2, renderLanes)) {\n            pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n          }\n        }\n        return nextSnapshot;\n      }\n      function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {\n        fiber.flags |= StoreConsistency;\n        var check = {\n          getSnapshot,\n          value: renderedSnapshot\n        };\n        var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;\n        if (componentUpdateQueue === null) {\n          componentUpdateQueue = createFunctionComponentUpdateQueue();\n          currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;\n          componentUpdateQueue.stores = [check];\n        } else {\n          var stores = componentUpdateQueue.stores;\n          if (stores === null) {\n            componentUpdateQueue.stores = [check];\n          } else {\n            stores.push(check);\n          }\n        }\n      }\n      function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {\n        inst.value = nextSnapshot;\n        inst.getSnapshot = getSnapshot;\n        if (checkIfSnapshotChanged(inst)) {\n          forceStoreRerender(fiber);\n        }\n      }\n      function subscribeToStore(fiber, inst, subscribe) {\n        var handleStoreChange = function() {\n          if (checkIfSnapshotChanged(inst)) {\n            forceStoreRerender(fiber);\n          }\n        };\n        return subscribe(handleStoreChange);\n      }\n      function checkIfSnapshotChanged(inst) {\n        var latestGetSnapshot = inst.getSnapshot;\n        var prevValue = inst.value;\n        try {\n          var nextValue = latestGetSnapshot();\n          return !objectIs(prevValue, nextValue);\n        } catch (error2) {\n          return true;\n        }\n      }\n      function forceStoreRerender(fiber) {\n        var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);\n        if (root2 !== null) {\n          scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);\n        }\n      }\n      function mountState(initialState) {\n        var hook = mountWorkInProgressHook();\n        if (typeof initialState === \"function\") {\n          initialState = initialState();\n        }\n        hook.memoizedState = hook.baseState = initialState;\n        var queue = {\n          pending: null,\n          interleaved: null,\n          lanes: NoLanes,\n          dispatch: null,\n          lastRenderedReducer: basicStateReducer,\n          lastRenderedState: initialState\n        };\n        hook.queue = queue;\n        var dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);\n        return [hook.memoizedState, dispatch];\n      }\n      function updateState(initialState) {\n        return updateReducer(basicStateReducer);\n      }\n      function rerenderState(initialState) {\n        return rerenderReducer(basicStateReducer);\n      }\n      function pushEffect(tag, create, destroy, deps) {\n        var effect = {\n          tag,\n          create,\n          destroy,\n          deps,\n          next: null\n        };\n        var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;\n        if (componentUpdateQueue === null) {\n          componentUpdateQueue = createFunctionComponentUpdateQueue();\n          currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;\n          componentUpdateQueue.lastEffect = effect.next = effect;\n        } else {\n          var lastEffect = componentUpdateQueue.lastEffect;\n          if (lastEffect === null) {\n            componentUpdateQueue.lastEffect = effect.next = effect;\n          } else {\n            var firstEffect = lastEffect.next;\n            lastEffect.next = effect;\n            effect.next = firstEffect;\n            componentUpdateQueue.lastEffect = effect;\n          }\n        }\n        return effect;\n      }\n      function mountRef(initialValue) {\n        var hook = mountWorkInProgressHook();\n        {\n          var _ref2 = {\n            current: initialValue\n          };\n          hook.memoizedState = _ref2;\n          return _ref2;\n        }\n      }\n      function updateRef(initialValue) {\n        var hook = updateWorkInProgressHook();\n        return hook.memoizedState;\n      }\n      function mountEffectImpl(fiberFlags, hookFlags, create, deps) {\n        var hook = mountWorkInProgressHook();\n        var nextDeps = deps === undefined ? null : deps;\n        currentlyRenderingFiber$1.flags |= fiberFlags;\n        hook.memoizedState = pushEffect(HasEffect | hookFlags, create, undefined, nextDeps);\n      }\n      function updateEffectImpl(fiberFlags, hookFlags, create, deps) {\n        var hook = updateWorkInProgressHook();\n        var nextDeps = deps === undefined ? null : deps;\n        var destroy = undefined;\n        if (currentHook !== null) {\n          var prevEffect = currentHook.memoizedState;\n          destroy = prevEffect.destroy;\n          if (nextDeps !== null) {\n            var prevDeps = prevEffect.deps;\n            if (areHookInputsEqual(nextDeps, prevDeps)) {\n              hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);\n              return;\n            }\n          }\n        }\n        currentlyRenderingFiber$1.flags |= fiberFlags;\n        hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);\n      }\n      function mountEffect(create, deps) {\n        if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n          return mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create, deps);\n        } else {\n          return mountEffectImpl(Passive | PassiveStatic, Passive$1, create, deps);\n        }\n      }\n      function updateEffect(create, deps) {\n        return updateEffectImpl(Passive, Passive$1, create, deps);\n      }\n      function mountInsertionEffect(create, deps) {\n        return mountEffectImpl(Update, Insertion, create, deps);\n      }\n      function updateInsertionEffect(create, deps) {\n        return updateEffectImpl(Update, Insertion, create, deps);\n      }\n      function mountLayoutEffect(create, deps) {\n        var fiberFlags = Update;\n        {\n          fiberFlags |= LayoutStatic;\n        }\n        if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n          fiberFlags |= MountLayoutDev;\n        }\n        return mountEffectImpl(fiberFlags, Layout, create, deps);\n      }\n      function updateLayoutEffect(create, deps) {\n        return updateEffectImpl(Update, Layout, create, deps);\n      }\n      function imperativeHandleEffect(create, ref) {\n        if (typeof ref === \"function\") {\n          var refCallback = ref;\n          var _inst = create();\n          refCallback(_inst);\n          return function() {\n            refCallback(null);\n          };\n        } else if (ref !== null && ref !== undefined) {\n          var refObject = ref;\n          {\n            if (!refObject.hasOwnProperty(\"current\")) {\n              error(\"Expected useImperativeHandle() first argument to either be a \" + \"ref callback or React.createRef() object. Instead received: %s.\", \"an object with keys {\" + Object.keys(refObject).join(\", \") + \"}\");\n            }\n          }\n          var _inst2 = create();\n          refObject.current = _inst2;\n          return function() {\n            refObject.current = null;\n          };\n        }\n      }\n      function mountImperativeHandle(ref, create, deps) {\n        {\n          if (typeof create !== \"function\") {\n            error(\"Expected useImperativeHandle() second argument to be a function \" + \"that creates a handle. Instead received: %s.\", create !== null ? typeof create : \"null\");\n          }\n        }\n        var effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;\n        var fiberFlags = Update;\n        {\n          fiberFlags |= LayoutStatic;\n        }\n        if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n          fiberFlags |= MountLayoutDev;\n        }\n        return mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n      }\n      function updateImperativeHandle(ref, create, deps) {\n        {\n          if (typeof create !== \"function\") {\n            error(\"Expected useImperativeHandle() second argument to be a function \" + \"that creates a handle. Instead received: %s.\", create !== null ? typeof create : \"null\");\n          }\n        }\n        var effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;\n        return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n      }\n      function mountDebugValue(value, formatterFn) {}\n      var updateDebugValue = mountDebugValue;\n      function mountCallback(callback, deps) {\n        var hook = mountWorkInProgressHook();\n        var nextDeps = deps === undefined ? null : deps;\n        hook.memoizedState = [callback, nextDeps];\n        return callback;\n      }\n      function updateCallback(callback, deps) {\n        var hook = updateWorkInProgressHook();\n        var nextDeps = deps === undefined ? null : deps;\n        var prevState = hook.memoizedState;\n        if (prevState !== null) {\n          if (nextDeps !== null) {\n            var prevDeps = prevState[1];\n            if (areHookInputsEqual(nextDeps, prevDeps)) {\n              return prevState[0];\n            }\n          }\n        }\n        hook.memoizedState = [callback, nextDeps];\n        return callback;\n      }\n      function mountMemo(nextCreate, deps) {\n        var hook = mountWorkInProgressHook();\n        var nextDeps = deps === undefined ? null : deps;\n        var nextValue = nextCreate();\n        hook.memoizedState = [nextValue, nextDeps];\n        return nextValue;\n      }\n      function updateMemo(nextCreate, deps) {\n        var hook = updateWorkInProgressHook();\n        var nextDeps = deps === undefined ? null : deps;\n        var prevState = hook.memoizedState;\n        if (prevState !== null) {\n          if (nextDeps !== null) {\n            var prevDeps = prevState[1];\n            if (areHookInputsEqual(nextDeps, prevDeps)) {\n              return prevState[0];\n            }\n          }\n        }\n        var nextValue = nextCreate();\n        hook.memoizedState = [nextValue, nextDeps];\n        return nextValue;\n      }\n      function mountDeferredValue(value) {\n        var hook = mountWorkInProgressHook();\n        hook.memoizedState = value;\n        return value;\n      }\n      function updateDeferredValue(value) {\n        var hook = updateWorkInProgressHook();\n        var resolvedCurrentHook = currentHook;\n        var prevValue = resolvedCurrentHook.memoizedState;\n        return updateDeferredValueImpl(hook, prevValue, value);\n      }\n      function rerenderDeferredValue(value) {\n        var hook = updateWorkInProgressHook();\n        if (currentHook === null) {\n          hook.memoizedState = value;\n          return value;\n        } else {\n          var prevValue = currentHook.memoizedState;\n          return updateDeferredValueImpl(hook, prevValue, value);\n        }\n      }\n      function updateDeferredValueImpl(hook, prevValue, value) {\n        var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);\n        if (shouldDeferValue) {\n          if (!objectIs(value, prevValue)) {\n            var deferredLane = claimNextTransitionLane();\n            currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);\n            markSkippedUpdateLanes(deferredLane);\n            hook.baseState = true;\n          }\n          return prevValue;\n        } else {\n          if (hook.baseState) {\n            hook.baseState = false;\n            markWorkInProgressReceivedUpdate();\n          }\n          hook.memoizedState = value;\n          return value;\n        }\n      }\n      function startTransition(setPending, callback, options2) {\n        var previousPriority = getCurrentUpdatePriority();\n        setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));\n        setPending(true);\n        var prevTransition = ReactCurrentBatchConfig$2.transition;\n        ReactCurrentBatchConfig$2.transition = {};\n        var currentTransition = ReactCurrentBatchConfig$2.transition;\n        {\n          ReactCurrentBatchConfig$2.transition._updatedFibers = new Set;\n        }\n        try {\n          setPending(false);\n          callback();\n        } finally {\n          setCurrentUpdatePriority(previousPriority);\n          ReactCurrentBatchConfig$2.transition = prevTransition;\n          {\n            if (prevTransition === null && currentTransition._updatedFibers) {\n              var updatedFibersCount = currentTransition._updatedFibers.size;\n              if (updatedFibersCount > 10) {\n                warn(\"Detected a large number of updates inside startTransition. \" + \"If this is due to a subscription please re-write it to use React provided hooks. \" + \"Otherwise concurrent mode guarantees are off the table.\");\n              }\n              currentTransition._updatedFibers.clear();\n            }\n          }\n        }\n      }\n      function mountTransition() {\n        var _mountState = mountState(false), isPending = _mountState[0], setPending = _mountState[1];\n        var start = startTransition.bind(null, setPending);\n        var hook = mountWorkInProgressHook();\n        hook.memoizedState = start;\n        return [isPending, start];\n      }\n      function updateTransition() {\n        var _updateState = updateState(), isPending = _updateState[0];\n        var hook = updateWorkInProgressHook();\n        var start = hook.memoizedState;\n        return [isPending, start];\n      }\n      function rerenderTransition() {\n        var _rerenderState = rerenderState(), isPending = _rerenderState[0];\n        var hook = updateWorkInProgressHook();\n        var start = hook.memoizedState;\n        return [isPending, start];\n      }\n      var isUpdatingOpaqueValueInRenderPhase = false;\n      function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {\n        {\n          return isUpdatingOpaqueValueInRenderPhase;\n        }\n      }\n      function mountId() {\n        var hook = mountWorkInProgressHook();\n        var root2 = getWorkInProgressRoot();\n        var identifierPrefix = root2.identifierPrefix;\n        var id;\n        if (getIsHydrating()) {\n          var treeId = getTreeId();\n          id = \":\" + identifierPrefix + \"R\" + treeId;\n          var localId = localIdCounter++;\n          if (localId > 0) {\n            id += \"H\" + localId.toString(32);\n          }\n          id += \":\";\n        } else {\n          var globalClientId = globalClientIdCounter++;\n          id = \":\" + identifierPrefix + \"r\" + globalClientId.toString(32) + \":\";\n        }\n        hook.memoizedState = id;\n        return id;\n      }\n      function updateId() {\n        var hook = updateWorkInProgressHook();\n        var id = hook.memoizedState;\n        return id;\n      }\n      function dispatchReducerAction(fiber, queue, action) {\n        {\n          if (typeof arguments[3] === \"function\") {\n            error(\"State updates from the useState() and useReducer() Hooks don't support the \" + \"second callback argument. To execute a side effect after \" + \"rendering, declare it in the component body with useEffect().\");\n          }\n        }\n        var lane = requestUpdateLane(fiber);\n        var update = {\n          lane,\n          action,\n          hasEagerState: false,\n          eagerState: null,\n          next: null\n        };\n        if (isRenderPhaseUpdate(fiber)) {\n          enqueueRenderPhaseUpdate(queue, update);\n        } else {\n          var root2 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n          if (root2 !== null) {\n            var eventTime = requestEventTime();\n            scheduleUpdateOnFiber(root2, fiber, lane, eventTime);\n            entangleTransitionUpdate(root2, queue, lane);\n          }\n        }\n        markUpdateInDevTools(fiber, lane);\n      }\n      function dispatchSetState(fiber, queue, action) {\n        {\n          if (typeof arguments[3] === \"function\") {\n            error(\"State updates from the useState() and useReducer() Hooks don't support the \" + \"second callback argument. To execute a side effect after \" + \"rendering, declare it in the component body with useEffect().\");\n          }\n        }\n        var lane = requestUpdateLane(fiber);\n        var update = {\n          lane,\n          action,\n          hasEagerState: false,\n          eagerState: null,\n          next: null\n        };\n        if (isRenderPhaseUpdate(fiber)) {\n          enqueueRenderPhaseUpdate(queue, update);\n        } else {\n          var alternate = fiber.alternate;\n          if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {\n            var lastRenderedReducer = queue.lastRenderedReducer;\n            if (lastRenderedReducer !== null) {\n              var prevDispatcher;\n              {\n                prevDispatcher = ReactCurrentDispatcher$1.current;\n                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n              }\n              try {\n                var currentState = queue.lastRenderedState;\n                var eagerState = lastRenderedReducer(currentState, action);\n                update.hasEagerState = true;\n                update.eagerState = eagerState;\n                if (objectIs(eagerState, currentState)) {\n                  enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane);\n                  return;\n                }\n              } catch (error2) {} finally {\n                {\n                  ReactCurrentDispatcher$1.current = prevDispatcher;\n                }\n              }\n            }\n          }\n          var root2 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n          if (root2 !== null) {\n            var eventTime = requestEventTime();\n            scheduleUpdateOnFiber(root2, fiber, lane, eventTime);\n            entangleTransitionUpdate(root2, queue, lane);\n          }\n        }\n        markUpdateInDevTools(fiber, lane);\n      }\n      function isRenderPhaseUpdate(fiber) {\n        var alternate = fiber.alternate;\n        return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;\n      }\n      function enqueueRenderPhaseUpdate(queue, update) {\n        didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;\n        var pending = queue.pending;\n        if (pending === null) {\n          update.next = update;\n        } else {\n          update.next = pending.next;\n          pending.next = update;\n        }\n        queue.pending = update;\n      }\n      function entangleTransitionUpdate(root2, queue, lane) {\n        if (isTransitionLane(lane)) {\n          var queueLanes = queue.lanes;\n          queueLanes = intersectLanes(queueLanes, root2.pendingLanes);\n          var newQueueLanes = mergeLanes(queueLanes, lane);\n          queue.lanes = newQueueLanes;\n          markRootEntangled(root2, newQueueLanes);\n        }\n      }\n      function markUpdateInDevTools(fiber, lane, action) {\n        {\n          markStateUpdateScheduled(fiber, lane);\n        }\n      }\n      var ContextOnlyDispatcher = {\n        readContext,\n        useCallback: throwInvalidHookError,\n        useContext: throwInvalidHookError,\n        useEffect: throwInvalidHookError,\n        useImperativeHandle: throwInvalidHookError,\n        useInsertionEffect: throwInvalidHookError,\n        useLayoutEffect: throwInvalidHookError,\n        useMemo: throwInvalidHookError,\n        useReducer: throwInvalidHookError,\n        useRef: throwInvalidHookError,\n        useState: throwInvalidHookError,\n        useDebugValue: throwInvalidHookError,\n        useDeferredValue: throwInvalidHookError,\n        useTransition: throwInvalidHookError,\n        useMutableSource: throwInvalidHookError,\n        useSyncExternalStore: throwInvalidHookError,\n        useId: throwInvalidHookError,\n        unstable_isNewReconciler: enableNewReconciler\n      };\n      var HooksDispatcherOnMountInDEV = null;\n      var HooksDispatcherOnMountWithHookTypesInDEV = null;\n      var HooksDispatcherOnUpdateInDEV = null;\n      var HooksDispatcherOnRerenderInDEV = null;\n      var InvalidNestedHooksDispatcherOnMountInDEV = null;\n      var InvalidNestedHooksDispatcherOnUpdateInDEV = null;\n      var InvalidNestedHooksDispatcherOnRerenderInDEV = null;\n      {\n        var warnInvalidContextAccess = function() {\n          error(\"Context can only be read while React is rendering. \" + \"In classes, you can read it in the render method or getDerivedStateFromProps. \" + \"In function components, you can read it directly in the function body, but not \" + \"inside Hooks like useReducer() or useMemo().\");\n        };\n        var warnInvalidHookAccess = function() {\n          error(\"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. \" + \"You can only call Hooks at the top level of your React function. \" + \"For more information, see \" + \"https://reactjs.org/link/rules-of-hooks\");\n        };\n        HooksDispatcherOnMountInDEV = {\n          readContext: function(context) {\n            return readContext(context);\n          },\n          useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountCallback(callback, deps);\n          },\n          useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            mountHookTypesDev();\n            return readContext(context);\n          },\n          useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountEffect(create, deps);\n          },\n          useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountImperativeHandle(ref, create, deps);\n          },\n          useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountInsertionEffect(create, deps);\n          },\n          useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountLayoutEffect(create, deps);\n          },\n          useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            var prevDispatcher = ReactCurrentDispatcher$1.current;\n            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n              return mountMemo(create, deps);\n            } finally {\n              ReactCurrentDispatcher$1.current = prevDispatcher;\n            }\n          },\n          useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            mountHookTypesDev();\n            var prevDispatcher = ReactCurrentDispatcher$1.current;\n            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n              return mountReducer(reducer, initialArg, init);\n            } finally {\n              ReactCurrentDispatcher$1.current = prevDispatcher;\n            }\n          },\n          useRef: function(initialValue) {\n            currentHookNameInDev = \"useRef\";\n            mountHookTypesDev();\n            return mountRef(initialValue);\n          },\n          useState: function(initialState) {\n            currentHookNameInDev = \"useState\";\n            mountHookTypesDev();\n            var prevDispatcher = ReactCurrentDispatcher$1.current;\n            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n              return mountState(initialState);\n            } finally {\n              ReactCurrentDispatcher$1.current = prevDispatcher;\n            }\n          },\n          useDebugValue: function(value, formatterFn) {\n            currentHookNameInDev = \"useDebugValue\";\n            mountHookTypesDev();\n            return mountDebugValue();\n          },\n          useDeferredValue: function(value) {\n            currentHookNameInDev = \"useDeferredValue\";\n            mountHookTypesDev();\n            return mountDeferredValue(value);\n          },\n          useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            mountHookTypesDev();\n            return mountTransition();\n          },\n          useMutableSource: function(source, getSnapshot, subscribe) {\n            currentHookNameInDev = \"useMutableSource\";\n            mountHookTypesDev();\n            return mountMutableSource();\n          },\n          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            mountHookTypesDev();\n            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n          },\n          useId: function() {\n            currentHookNameInDev = \"useId\";\n            mountHookTypesDev();\n            return mountId();\n          },\n          unstable_isNewReconciler: enableNewReconciler\n        };\n        HooksDispatcherOnMountWithHookTypesInDEV = {\n          readContext: function(context) {\n            return readContext(context);\n          },\n          useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            updateHookTypesDev();\n            return mountCallback(callback, deps);\n          },\n          useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            updateHookTypesDev();\n            return readContext(context);\n          },\n          useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            updateHookTypesDev();\n            return mountEffect(create, deps);\n          },\n          useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            updateHookTypesDev();\n            return mountImperativeHandle(ref, create, deps);\n          },\n          useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            updateHookTypesDev();\n            return mountInsertionEffect(create, deps);\n          },\n          useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            updateHookTypesDev();\n            return mountLayoutEffect(create, deps);\n          },\n          useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactCurrentDispatcher$1.current;\n            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n              return mountMemo(create, deps);\n            } finally {\n              ReactCurrentDispatcher$1.current = prevDispatcher;\n            }\n          },\n          useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactCurrentDispatcher$1.current;\n            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n              return mountReducer(reducer, initialArg, init);\n            } finally {\n              ReactCurrentDispatcher$1.current = prevDispatcher;\n            }\n          },\n          useRef: function(initialValue) {\n            currentHookNameInDev = \"useRef\";\n            updateHookTypesDev();\n            return mountRef(initialValue);\n          },\n          useState: function(initialState) {\n            currentHookNameInDev = \"useState\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactCurrentDispatcher$1.current;\n            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n              return mountState(initialState);\n            } finally {\n              ReactCurrentDispatcher$1.current = prevDispatcher;\n            }\n          },\n          useDebugValue: function(value, formatterFn) {\n            currentHookNameInDev = \"useDebugValue\";\n            updateHookTypesDev();\n            return mountDebugValue();\n          },\n          useDeferredValue: function(value) {\n            currentHookNameInDev = \"useDeferredValue\";\n            updateHookTypesDev();\n            return mountDeferredValue(value);\n          },\n          useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            updateHookTypesDev();\n            return mountTransition();\n          },\n          useMutableSource: function(source, getSnapshot, subscribe) {\n            currentHookNameInDev = \"useMutableSource\";\n            updateHookTypesDev();\n            return mountMutableSource();\n          },\n          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            updateHookTypesDev();\n            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n          },\n          useId: function() {\n            currentHookNameInDev = \"useId\";\n            updateHookTypesDev();\n            return mountId();\n          },\n          unstable_isNewReconciler: enableNewReconciler\n        };\n        HooksDispatcherOnUpdateInDEV = {\n          readContext: function(context) {\n            return readContext(context);\n          },\n          useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n          },\n          useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            updateHookTypesDev();\n            return readContext(context);\n          },\n          useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            updateHookTypesDev();\n            return updateEffect(create, deps);\n          },\n          useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n          },\n          useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            updateHookTypesDev();\n            return updateInsertionEffect(create, deps);\n          },\n          useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            updateHookTypesDev();\n            return updateLayoutEffect(create, deps);\n          },\n          useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactCurrentDispatcher$1.current;\n            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n              return updateMemo(create, deps);\n            } finally {\n              ReactCurrentDispatcher$1.current = prevDispatcher;\n            }\n          },\n          useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactCurrentDispatcher$1.current;\n            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n              return updateReducer(reducer, initialArg, init);\n            } finally {\n              ReactCurrentDispatcher$1.current = prevDispatcher;\n            }\n          },\n          useRef: function(initialValue) {\n            currentHookNameInDev = \"useRef\";\n            updateHookTypesDev();\n            return updateRef();\n          },\n          useState: function(initialState) {\n            currentHookNameInDev = \"useState\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactCurrentDispatcher$1.current;\n            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n              return updateState(initialState);\n            } finally {\n              ReactCurrentDispatcher$1.current = prevDispatcher;\n            }\n          },\n          useDebugValue: function(value, formatterFn) {\n            currentHookNameInDev = \"useDebugValue\";\n            updateHookTypesDev();\n            return updateDebugValue();\n          },\n          useDeferredValue: function(value) {\n            currentHookNameInDev = \"useDeferredValue\";\n            updateHookTypesDev();\n            return updateDeferredValue(value);\n          },\n          useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            updateHookTypesDev();\n            return updateTransition();\n          },\n          useMutableSource: function(source, getSnapshot, subscribe) {\n            currentHookNameInDev = \"useMutableSource\";\n            updateHookTypesDev();\n            return updateMutableSource();\n          },\n          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot);\n          },\n          useId: function() {\n            currentHookNameInDev = \"useId\";\n            updateHookTypesDev();\n            return updateId();\n          },\n          unstable_isNewReconciler: enableNewReconciler\n        };\n        HooksDispatcherOnRerenderInDEV = {\n          readContext: function(context) {\n            return readContext(context);\n          },\n          useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n          },\n          useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            updateHookTypesDev();\n            return readContext(context);\n          },\n          useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            updateHookTypesDev();\n            return updateEffect(create, deps);\n          },\n          useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n          },\n          useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            updateHookTypesDev();\n            return updateInsertionEffect(create, deps);\n          },\n          useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            updateHookTypesDev();\n            return updateLayoutEffect(create, deps);\n          },\n          useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactCurrentDispatcher$1.current;\n            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n            try {\n              return updateMemo(create, deps);\n            } finally {\n              ReactCurrentDispatcher$1.current = prevDispatcher;\n            }\n          },\n          useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactCurrentDispatcher$1.current;\n            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n            try {\n              return rerenderReducer(reducer, initialArg, init);\n            } finally {\n              ReactCurrentDispatcher$1.current = prevDispatcher;\n            }\n          },\n          useRef: function(initialValue) {\n            currentHookNameInDev = \"useRef\";\n            updateHookTypesDev();\n            return updateRef();\n          },\n          useState: function(initialState) {\n            currentHookNameInDev = \"useState\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactCurrentDispatcher$1.current;\n            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n            try {\n              return rerenderState(initialState);\n            } finally {\n              ReactCurrentDispatcher$1.current = prevDispatcher;\n            }\n          },\n          useDebugValue: function(value, formatterFn) {\n            currentHookNameInDev = \"useDebugValue\";\n            updateHookTypesDev();\n            return updateDebugValue();\n          },\n          useDeferredValue: function(value) {\n            currentHookNameInDev = \"useDeferredValue\";\n            updateHookTypesDev();\n            return rerenderDeferredValue(value);\n          },\n          useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            updateHookTypesDev();\n            return rerenderTransition();\n          },\n          useMutableSource: function(source, getSnapshot, subscribe) {\n            currentHookNameInDev = \"useMutableSource\";\n            updateHookTypesDev();\n            return updateMutableSource();\n          },\n          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot);\n          },\n          useId: function() {\n            currentHookNameInDev = \"useId\";\n            updateHookTypesDev();\n            return updateId();\n          },\n          unstable_isNewReconciler: enableNewReconciler\n        };\n        InvalidNestedHooksDispatcherOnMountInDEV = {\n          readContext: function(context) {\n            warnInvalidContextAccess();\n            return readContext(context);\n          },\n          useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountCallback(callback, deps);\n          },\n          useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return readContext(context);\n          },\n          useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountEffect(create, deps);\n          },\n          useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountImperativeHandle(ref, create, deps);\n          },\n          useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountInsertionEffect(create, deps);\n          },\n          useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountLayoutEffect(create, deps);\n          },\n          useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            var prevDispatcher = ReactCurrentDispatcher$1.current;\n            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n              return mountMemo(create, deps);\n            } finally {\n              ReactCurrentDispatcher$1.current = prevDispatcher;\n            }\n          },\n          useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            var prevDispatcher = ReactCurrentDispatcher$1.current;\n            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n              return mountReducer(reducer, initialArg, init);\n            } finally {\n              ReactCurrentDispatcher$1.current = prevDispatcher;\n            }\n          },\n          useRef: function(initialValue) {\n            currentHookNameInDev = \"useRef\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountRef(initialValue);\n          },\n          useState: function(initialState) {\n            currentHookNameInDev = \"useState\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            var prevDispatcher = ReactCurrentDispatcher$1.current;\n            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n              return mountState(initialState);\n            } finally {\n              ReactCurrentDispatcher$1.current = prevDispatcher;\n            }\n          },\n          useDebugValue: function(value, formatterFn) {\n            currentHookNameInDev = \"useDebugValue\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountDebugValue();\n          },\n          useDeferredValue: function(value) {\n            currentHookNameInDev = \"useDeferredValue\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountDeferredValue(value);\n          },\n          useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountTransition();\n          },\n          useMutableSource: function(source, getSnapshot, subscribe) {\n            currentHookNameInDev = \"useMutableSource\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountMutableSource();\n          },\n          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n          },\n          useId: function() {\n            currentHookNameInDev = \"useId\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountId();\n          },\n          unstable_isNewReconciler: enableNewReconciler\n        };\n        InvalidNestedHooksDispatcherOnUpdateInDEV = {\n          readContext: function(context) {\n            warnInvalidContextAccess();\n            return readContext(context);\n          },\n          useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n          },\n          useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return readContext(context);\n          },\n          useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffect(create, deps);\n          },\n          useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n          },\n          useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateInsertionEffect(create, deps);\n          },\n          useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateLayoutEffect(create, deps);\n          },\n          useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactCurrentDispatcher$1.current;\n            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n              return updateMemo(create, deps);\n            } finally {\n              ReactCurrentDispatcher$1.current = prevDispatcher;\n            }\n          },\n          useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactCurrentDispatcher$1.current;\n            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n              return updateReducer(reducer, initialArg, init);\n            } finally {\n              ReactCurrentDispatcher$1.current = prevDispatcher;\n            }\n          },\n          useRef: function(initialValue) {\n            currentHookNameInDev = \"useRef\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateRef();\n          },\n          useState: function(initialState) {\n            currentHookNameInDev = \"useState\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactCurrentDispatcher$1.current;\n            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n              return updateState(initialState);\n            } finally {\n              ReactCurrentDispatcher$1.current = prevDispatcher;\n            }\n          },\n          useDebugValue: function(value, formatterFn) {\n            currentHookNameInDev = \"useDebugValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateDebugValue();\n          },\n          useDeferredValue: function(value) {\n            currentHookNameInDev = \"useDeferredValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateDeferredValue(value);\n          },\n          useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateTransition();\n          },\n          useMutableSource: function(source, getSnapshot, subscribe) {\n            currentHookNameInDev = \"useMutableSource\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateMutableSource();\n          },\n          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot);\n          },\n          useId: function() {\n            currentHookNameInDev = \"useId\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateId();\n          },\n          unstable_isNewReconciler: enableNewReconciler\n        };\n        InvalidNestedHooksDispatcherOnRerenderInDEV = {\n          readContext: function(context) {\n            warnInvalidContextAccess();\n            return readContext(context);\n          },\n          useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n          },\n          useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return readContext(context);\n          },\n          useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffect(create, deps);\n          },\n          useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n          },\n          useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateInsertionEffect(create, deps);\n          },\n          useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateLayoutEffect(create, deps);\n          },\n          useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactCurrentDispatcher$1.current;\n            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n              return updateMemo(create, deps);\n            } finally {\n              ReactCurrentDispatcher$1.current = prevDispatcher;\n            }\n          },\n          useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactCurrentDispatcher$1.current;\n            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n              return rerenderReducer(reducer, initialArg, init);\n            } finally {\n              ReactCurrentDispatcher$1.current = prevDispatcher;\n            }\n          },\n          useRef: function(initialValue) {\n            currentHookNameInDev = \"useRef\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateRef();\n          },\n          useState: function(initialState) {\n            currentHookNameInDev = \"useState\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactCurrentDispatcher$1.current;\n            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n              return rerenderState(initialState);\n            } finally {\n              ReactCurrentDispatcher$1.current = prevDispatcher;\n            }\n          },\n          useDebugValue: function(value, formatterFn) {\n            currentHookNameInDev = \"useDebugValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateDebugValue();\n          },\n          useDeferredValue: function(value) {\n            currentHookNameInDev = \"useDeferredValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return rerenderDeferredValue(value);\n          },\n          useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return rerenderTransition();\n          },\n          useMutableSource: function(source, getSnapshot, subscribe) {\n            currentHookNameInDev = \"useMutableSource\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateMutableSource();\n          },\n          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot);\n          },\n          useId: function() {\n            currentHookNameInDev = \"useId\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateId();\n          },\n          unstable_isNewReconciler: enableNewReconciler\n        };\n      }\n      var now$1 = Scheduler.unstable_now;\n      var commitTime = 0;\n      var layoutEffectStartTime = -1;\n      var profilerStartTime = -1;\n      var passiveEffectStartTime = -1;\n      var currentUpdateIsNested = false;\n      var nestedUpdateScheduled = false;\n      function isCurrentUpdateNested() {\n        return currentUpdateIsNested;\n      }\n      function markNestedUpdateScheduled() {\n        {\n          nestedUpdateScheduled = true;\n        }\n      }\n      function resetNestedUpdateFlag() {\n        {\n          currentUpdateIsNested = false;\n          nestedUpdateScheduled = false;\n        }\n      }\n      function syncNestedUpdateFlag() {\n        {\n          currentUpdateIsNested = nestedUpdateScheduled;\n          nestedUpdateScheduled = false;\n        }\n      }\n      function getCommitTime() {\n        return commitTime;\n      }\n      function recordCommitTime() {\n        commitTime = now$1();\n      }\n      function startProfilerTimer(fiber) {\n        profilerStartTime = now$1();\n        if (fiber.actualStartTime < 0) {\n          fiber.actualStartTime = now$1();\n        }\n      }\n      function stopProfilerTimerIfRunning(fiber) {\n        profilerStartTime = -1;\n      }\n      function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {\n        if (profilerStartTime >= 0) {\n          var elapsedTime = now$1() - profilerStartTime;\n          fiber.actualDuration += elapsedTime;\n          if (overrideBaseTime) {\n            fiber.selfBaseDuration = elapsedTime;\n          }\n          profilerStartTime = -1;\n        }\n      }\n      function recordLayoutEffectDuration(fiber) {\n        if (layoutEffectStartTime >= 0) {\n          var elapsedTime = now$1() - layoutEffectStartTime;\n          layoutEffectStartTime = -1;\n          var parentFiber = fiber.return;\n          while (parentFiber !== null) {\n            switch (parentFiber.tag) {\n              case HostRoot:\n                var root2 = parentFiber.stateNode;\n                root2.effectDuration += elapsedTime;\n                return;\n              case Profiler:\n                var parentStateNode = parentFiber.stateNode;\n                parentStateNode.effectDuration += elapsedTime;\n                return;\n            }\n            parentFiber = parentFiber.return;\n          }\n        }\n      }\n      function recordPassiveEffectDuration(fiber) {\n        if (passiveEffectStartTime >= 0) {\n          var elapsedTime = now$1() - passiveEffectStartTime;\n          passiveEffectStartTime = -1;\n          var parentFiber = fiber.return;\n          while (parentFiber !== null) {\n            switch (parentFiber.tag) {\n              case HostRoot:\n                var root2 = parentFiber.stateNode;\n                if (root2 !== null) {\n                  root2.passiveEffectDuration += elapsedTime;\n                }\n                return;\n              case Profiler:\n                var parentStateNode = parentFiber.stateNode;\n                if (parentStateNode !== null) {\n                  parentStateNode.passiveEffectDuration += elapsedTime;\n                }\n                return;\n            }\n            parentFiber = parentFiber.return;\n          }\n        }\n      }\n      function startLayoutEffectTimer() {\n        layoutEffectStartTime = now$1();\n      }\n      function startPassiveEffectTimer() {\n        passiveEffectStartTime = now$1();\n      }\n      function transferActualDuration(fiber) {\n        var child = fiber.child;\n        while (child) {\n          fiber.actualDuration += child.actualDuration;\n          child = child.sibling;\n        }\n      }\n      function resolveDefaultProps(Component, baseProps) {\n        if (Component && Component.defaultProps) {\n          var props = assign({}, baseProps);\n          var defaultProps = Component.defaultProps;\n          for (var propName in defaultProps) {\n            if (props[propName] === undefined) {\n              props[propName] = defaultProps[propName];\n            }\n          }\n          return props;\n        }\n        return baseProps;\n      }\n      var fakeInternalInstance = {};\n      var didWarnAboutStateAssignmentForComponent;\n      var didWarnAboutUninitializedState;\n      var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\n      var didWarnAboutLegacyLifecyclesAndDerivedState;\n      var didWarnAboutUndefinedDerivedState;\n      var warnOnUndefinedDerivedState;\n      var warnOnInvalidCallback;\n      var didWarnAboutDirectlyAssigningPropsToState;\n      var didWarnAboutContextTypeAndContextTypes;\n      var didWarnAboutInvalidateContextType;\n      var didWarnAboutLegacyContext$1;\n      {\n        didWarnAboutStateAssignmentForComponent = new Set;\n        didWarnAboutUninitializedState = new Set;\n        didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set;\n        didWarnAboutLegacyLifecyclesAndDerivedState = new Set;\n        didWarnAboutDirectlyAssigningPropsToState = new Set;\n        didWarnAboutUndefinedDerivedState = new Set;\n        didWarnAboutContextTypeAndContextTypes = new Set;\n        didWarnAboutInvalidateContextType = new Set;\n        didWarnAboutLegacyContext$1 = new Set;\n        var didWarnOnInvalidCallback = new Set;\n        warnOnInvalidCallback = function(callback, callerName) {\n          if (callback === null || typeof callback === \"function\") {\n            return;\n          }\n          var key = callerName + \"_\" + callback;\n          if (!didWarnOnInvalidCallback.has(key)) {\n            didWarnOnInvalidCallback.add(key);\n            error(\"%s(...): Expected the last optional `callback` argument to be a \" + \"function. Instead received: %s.\", callerName, callback);\n          }\n        };\n        warnOnUndefinedDerivedState = function(type, partialState) {\n          if (partialState === undefined) {\n            var componentName = getComponentNameFromType(type) || \"Component\";\n            if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n              didWarnAboutUndefinedDerivedState.add(componentName);\n              error(\"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. \" + \"You have returned undefined.\", componentName);\n            }\n          }\n        };\n        Object.defineProperty(fakeInternalInstance, \"_processChildContext\", {\n          enumerable: false,\n          value: function() {\n            throw new Error(\"_processChildContext is not available in React 16+. This likely \" + \"means you have multiple copies of React and are attempting to nest \" + \"a React 15 tree inside a React 16 tree using \" + \"unstable_renderSubtreeIntoContainer, which isn't supported. Try \" + \"to make sure you have only one copy of React (and ideally, switch \" + \"to ReactDOM.createPortal).\");\n          }\n        });\n        Object.freeze(fakeInternalInstance);\n      }\n      function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {\n        var prevState = workInProgress2.memoizedState;\n        var partialState = getDerivedStateFromProps(nextProps, prevState);\n        {\n          if (workInProgress2.mode & StrictLegacyMode) {\n            setIsStrictModeForDevtools(true);\n            try {\n              partialState = getDerivedStateFromProps(nextProps, prevState);\n            } finally {\n              setIsStrictModeForDevtools(false);\n            }\n          }\n          warnOnUndefinedDerivedState(ctor, partialState);\n        }\n        var memoizedState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);\n        workInProgress2.memoizedState = memoizedState;\n        if (workInProgress2.lanes === NoLanes) {\n          var updateQueue = workInProgress2.updateQueue;\n          updateQueue.baseState = memoizedState;\n        }\n      }\n      var classComponentUpdater = {\n        isMounted,\n        enqueueSetState: function(inst, payload, callback) {\n          var fiber = get(inst);\n          var eventTime = requestEventTime();\n          var lane = requestUpdateLane(fiber);\n          var update = createUpdate(eventTime, lane);\n          update.payload = payload;\n          if (callback !== undefined && callback !== null) {\n            {\n              warnOnInvalidCallback(callback, \"setState\");\n            }\n            update.callback = callback;\n          }\n          var root2 = enqueueUpdate(fiber, update, lane);\n          if (root2 !== null) {\n            scheduleUpdateOnFiber(root2, fiber, lane, eventTime);\n            entangleTransitions(root2, fiber, lane);\n          }\n          {\n            markStateUpdateScheduled(fiber, lane);\n          }\n        },\n        enqueueReplaceState: function(inst, payload, callback) {\n          var fiber = get(inst);\n          var eventTime = requestEventTime();\n          var lane = requestUpdateLane(fiber);\n          var update = createUpdate(eventTime, lane);\n          update.tag = ReplaceState;\n          update.payload = payload;\n          if (callback !== undefined && callback !== null) {\n            {\n              warnOnInvalidCallback(callback, \"replaceState\");\n            }\n            update.callback = callback;\n          }\n          var root2 = enqueueUpdate(fiber, update, lane);\n          if (root2 !== null) {\n            scheduleUpdateOnFiber(root2, fiber, lane, eventTime);\n            entangleTransitions(root2, fiber, lane);\n          }\n          {\n            markStateUpdateScheduled(fiber, lane);\n          }\n        },\n        enqueueForceUpdate: function(inst, callback) {\n          var fiber = get(inst);\n          var eventTime = requestEventTime();\n          var lane = requestUpdateLane(fiber);\n          var update = createUpdate(eventTime, lane);\n          update.tag = ForceUpdate;\n          if (callback !== undefined && callback !== null) {\n            {\n              warnOnInvalidCallback(callback, \"forceUpdate\");\n            }\n            update.callback = callback;\n          }\n          var root2 = enqueueUpdate(fiber, update, lane);\n          if (root2 !== null) {\n            scheduleUpdateOnFiber(root2, fiber, lane, eventTime);\n            entangleTransitions(root2, fiber, lane);\n          }\n          {\n            markForceUpdateScheduled(fiber, lane);\n          }\n        }\n      };\n      function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {\n        var instance = workInProgress2.stateNode;\n        if (typeof instance.shouldComponentUpdate === \"function\") {\n          var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n          {\n            if (workInProgress2.mode & StrictLegacyMode) {\n              setIsStrictModeForDevtools(true);\n              try {\n                shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n              } finally {\n                setIsStrictModeForDevtools(false);\n              }\n            }\n            if (shouldUpdate === undefined) {\n              error(\"%s.shouldComponentUpdate(): Returned undefined instead of a \" + \"boolean value. Make sure to return true or false.\", getComponentNameFromType(ctor) || \"Component\");\n            }\n          }\n          return shouldUpdate;\n        }\n        if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n          return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n        }\n        return true;\n      }\n      function checkClassInstance(workInProgress2, ctor, newProps) {\n        var instance = workInProgress2.stateNode;\n        {\n          var name = getComponentNameFromType(ctor) || \"Component\";\n          var renderPresent = instance.render;\n          if (!renderPresent) {\n            if (ctor.prototype && typeof ctor.prototype.render === \"function\") {\n              error(\"%s(...): No `render` method found on the returned component \" + \"instance: did you accidentally return an object from the constructor?\", name);\n            } else {\n              error(\"%s(...): No `render` method found on the returned component \" + \"instance: you may have forgotten to define `render`.\", name);\n            }\n          }\n          if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {\n            error(\"getInitialState was defined on %s, a plain JavaScript class. \" + \"This is only supported for classes created using React.createClass. \" + \"Did you mean to define a state property instead?\", name);\n          }\n          if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {\n            error(\"getDefaultProps was defined on %s, a plain JavaScript class. \" + \"This is only supported for classes created using React.createClass. \" + \"Use a static property to define defaultProps instead.\", name);\n          }\n          if (instance.propTypes) {\n            error(\"propTypes was defined as an instance property on %s. Use a static \" + \"property to define propTypes instead.\", name);\n          }\n          if (instance.contextType) {\n            error(\"contextType was defined as an instance property on %s. Use a static \" + \"property to define contextType instead.\", name);\n          }\n          {\n            if (ctor.childContextTypes && !didWarnAboutLegacyContext$1.has(ctor) && (workInProgress2.mode & StrictLegacyMode) === NoMode) {\n              didWarnAboutLegacyContext$1.add(ctor);\n              error(\"%s uses the legacy childContextTypes API which is no longer \" + \"supported and will be removed in the next major release. Use \" + `React.createContext() instead\n\n.` + \"Learn more about this warning here: https://reactjs.org/link/legacy-context\", name);\n            }\n            if (ctor.contextTypes && !didWarnAboutLegacyContext$1.has(ctor) && (workInProgress2.mode & StrictLegacyMode) === NoMode) {\n              didWarnAboutLegacyContext$1.add(ctor);\n              error(\"%s uses the legacy contextTypes API which is no longer supported \" + \"and will be removed in the next major release. Use \" + `React.createContext() with static contextType instead.\n\n` + \"Learn more about this warning here: https://reactjs.org/link/legacy-context\", name);\n            }\n            if (instance.contextTypes) {\n              error(\"contextTypes was defined as an instance property on %s. Use a static \" + \"property to define contextTypes instead.\", name);\n            }\n            if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {\n              didWarnAboutContextTypeAndContextTypes.add(ctor);\n              error(\"%s declares both contextTypes and contextType static properties. \" + \"The legacy contextTypes property will be ignored.\", name);\n            }\n          }\n          if (typeof instance.componentShouldUpdate === \"function\") {\n            error(\"%s has a method called \" + \"componentShouldUpdate(). Did you mean shouldComponentUpdate()? \" + \"The name is phrased as a question because the function is \" + \"expected to return a value.\", name);\n          }\n          if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== \"undefined\") {\n            error(\"%s has a method called shouldComponentUpdate(). \" + \"shouldComponentUpdate should not be used when extending React.PureComponent. \" + \"Please extend React.Component if shouldComponentUpdate is used.\", getComponentNameFromType(ctor) || \"A pure component\");\n          }\n          if (typeof instance.componentDidUnmount === \"function\") {\n            error(\"%s has a method called \" + \"componentDidUnmount(). But there is no such lifecycle method. \" + \"Did you mean componentWillUnmount()?\", name);\n          }\n          if (typeof instance.componentDidReceiveProps === \"function\") {\n            error(\"%s has a method called \" + \"componentDidReceiveProps(). But there is no such lifecycle method. \" + \"If you meant to update the state in response to changing props, \" + \"use componentWillReceiveProps(). If you meant to fetch data or \" + \"run side-effects or mutations after React has updated the UI, use componentDidUpdate().\", name);\n          }\n          if (typeof instance.componentWillRecieveProps === \"function\") {\n            error(\"%s has a method called \" + \"componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\", name);\n          }\n          if (typeof instance.UNSAFE_componentWillRecieveProps === \"function\") {\n            error(\"%s has a method called \" + \"UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\", name);\n          }\n          var hasMutatedProps = instance.props !== newProps;\n          if (instance.props !== undefined && hasMutatedProps) {\n            error(\"%s(...): When calling super() in `%s`, make sure to pass \" + \"up the same props that your component's constructor was passed.\", name, name);\n          }\n          if (instance.defaultProps) {\n            error(\"Setting defaultProps as an instance property on %s is not supported and will be ignored.\" + \" Instead, define defaultProps as a static property on %s.\", name, name);\n          }\n          if (typeof instance.getSnapshotBeforeUpdate === \"function\" && typeof instance.componentDidUpdate !== \"function\" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {\n            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n            error(\"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). \" + \"This component defines getSnapshotBeforeUpdate() only.\", getComponentNameFromType(ctor));\n          }\n          if (typeof instance.getDerivedStateFromProps === \"function\") {\n            error(\"%s: getDerivedStateFromProps() is defined as an instance method \" + \"and will be ignored. Instead, declare it as a static method.\", name);\n          }\n          if (typeof instance.getDerivedStateFromError === \"function\") {\n            error(\"%s: getDerivedStateFromError() is defined as an instance method \" + \"and will be ignored. Instead, declare it as a static method.\", name);\n          }\n          if (typeof ctor.getSnapshotBeforeUpdate === \"function\") {\n            error(\"%s: getSnapshotBeforeUpdate() is defined as a static method \" + \"and will be ignored. Instead, declare it as an instance method.\", name);\n          }\n          var _state = instance.state;\n          if (_state && (typeof _state !== \"object\" || isArray(_state))) {\n            error(\"%s.state: must be set to an object or null\", name);\n          }\n          if (typeof instance.getChildContext === \"function\" && typeof ctor.childContextTypes !== \"object\") {\n            error(\"%s.getChildContext(): childContextTypes must be defined in order to \" + \"use getChildContext().\", name);\n          }\n        }\n      }\n      function adoptClassInstance(workInProgress2, instance) {\n        instance.updater = classComponentUpdater;\n        workInProgress2.stateNode = instance;\n        set(instance, workInProgress2);\n        {\n          instance._reactInternalInstance = fakeInternalInstance;\n        }\n      }\n      function constructClassInstance(workInProgress2, ctor, props) {\n        var isLegacyContextConsumer = false;\n        var unmaskedContext = emptyContextObject;\n        var context = emptyContextObject;\n        var contextType = ctor.contextType;\n        {\n          if (\"contextType\" in ctor) {\n            var isValid = contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined;\n            if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\n              didWarnAboutInvalidateContextType.add(ctor);\n              var addendum = \"\";\n              if (contextType === undefined) {\n                addendum = \" However, it is set to undefined. \" + \"This can be caused by a typo or by mixing up named and default imports. \" + \"This can also happen due to a circular dependency, so \" + \"try moving the createContext() call to a separate file.\";\n              } else if (typeof contextType !== \"object\") {\n                addendum = \" However, it is set to a \" + typeof contextType + \".\";\n              } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {\n                addendum = \" Did you accidentally pass the Context.Provider instead?\";\n              } else if (contextType._context !== undefined) {\n                addendum = \" Did you accidentally pass the Context.Consumer instead?\";\n              } else {\n                addendum = \" However, it is set to an object with keys {\" + Object.keys(contextType).join(\", \") + \"}.\";\n              }\n              error(\"%s defines an invalid contextType. \" + \"contextType should point to the Context object returned by React.createContext().%s\", getComponentNameFromType(ctor) || \"Component\", addendum);\n            }\n          }\n        }\n        if (typeof contextType === \"object\" && contextType !== null) {\n          context = readContext(contextType);\n        } else {\n          unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);\n          var contextTypes = ctor.contextTypes;\n          isLegacyContextConsumer = contextTypes !== null && contextTypes !== undefined;\n          context = isLegacyContextConsumer ? getMaskedContext(workInProgress2, unmaskedContext) : emptyContextObject;\n        }\n        var instance = new ctor(props, context);\n        {\n          if (workInProgress2.mode & StrictLegacyMode) {\n            setIsStrictModeForDevtools(true);\n            try {\n              instance = new ctor(props, context);\n            } finally {\n              setIsStrictModeForDevtools(false);\n            }\n          }\n        }\n        var state = workInProgress2.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;\n        adoptClassInstance(workInProgress2, instance);\n        {\n          if (typeof ctor.getDerivedStateFromProps === \"function\" && state === null) {\n            var componentName = getComponentNameFromType(ctor) || \"Component\";\n            if (!didWarnAboutUninitializedState.has(componentName)) {\n              didWarnAboutUninitializedState.add(componentName);\n              error(\"`%s` uses `getDerivedStateFromProps` but its initial state is \" + \"%s. This is not recommended. Instead, define the initial state by \" + \"assigning an object to `this.state` in the constructor of `%s`. \" + \"This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\", componentName, instance.state === null ? \"null\" : \"undefined\", componentName);\n            }\n          }\n          if (typeof ctor.getDerivedStateFromProps === \"function\" || typeof instance.getSnapshotBeforeUpdate === \"function\") {\n            var foundWillMountName = null;\n            var foundWillReceivePropsName = null;\n            var foundWillUpdateName = null;\n            if (typeof instance.componentWillMount === \"function\" && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n              foundWillMountName = \"componentWillMount\";\n            } else if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n              foundWillMountName = \"UNSAFE_componentWillMount\";\n            }\n            if (typeof instance.componentWillReceiveProps === \"function\" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n              foundWillReceivePropsName = \"componentWillReceiveProps\";\n            } else if (typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n              foundWillReceivePropsName = \"UNSAFE_componentWillReceiveProps\";\n            }\n            if (typeof instance.componentWillUpdate === \"function\" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n              foundWillUpdateName = \"componentWillUpdate\";\n            } else if (typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n              foundWillUpdateName = \"UNSAFE_componentWillUpdate\";\n            }\n            if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n              var _componentName = getComponentNameFromType(ctor) || \"Component\";\n              var newApiName = typeof ctor.getDerivedStateFromProps === \"function\" ? \"getDerivedStateFromProps()\" : \"getSnapshotBeforeUpdate()\";\n              if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {\n                didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\n                error(`Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n` + `%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n` + `The above lifecycles should be removed. Learn more about this warning here:\n` + \"https://reactjs.org/link/unsafe-component-lifecycles\", _componentName, newApiName, foundWillMountName !== null ? `\n  ` + foundWillMountName : \"\", foundWillReceivePropsName !== null ? `\n  ` + foundWillReceivePropsName : \"\", foundWillUpdateName !== null ? `\n  ` + foundWillUpdateName : \"\");\n              }\n            }\n          }\n        }\n        if (isLegacyContextConsumer) {\n          cacheContext(workInProgress2, unmaskedContext, context);\n        }\n        return instance;\n      }\n      function callComponentWillMount(workInProgress2, instance) {\n        var oldState = instance.state;\n        if (typeof instance.componentWillMount === \"function\") {\n          instance.componentWillMount();\n        }\n        if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n          instance.UNSAFE_componentWillMount();\n        }\n        if (oldState !== instance.state) {\n          {\n            error(\"%s.componentWillMount(): Assigning directly to this.state is \" + \"deprecated (except inside a component's \" + \"constructor). Use setState instead.\", getComponentNameFromFiber(workInProgress2) || \"Component\");\n          }\n          classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n        }\n      }\n      function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {\n        var oldState = instance.state;\n        if (typeof instance.componentWillReceiveProps === \"function\") {\n          instance.componentWillReceiveProps(newProps, nextContext);\n        }\n        if (typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n          instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n        }\n        if (instance.state !== oldState) {\n          {\n            var componentName = getComponentNameFromFiber(workInProgress2) || \"Component\";\n            if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\n              didWarnAboutStateAssignmentForComponent.add(componentName);\n              error(\"%s.componentWillReceiveProps(): Assigning directly to \" + \"this.state is deprecated (except inside a component's \" + \"constructor). Use setState instead.\", componentName);\n            }\n          }\n          classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n        }\n      }\n      function mountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {\n        {\n          checkClassInstance(workInProgress2, ctor, newProps);\n        }\n        var instance = workInProgress2.stateNode;\n        instance.props = newProps;\n        instance.state = workInProgress2.memoizedState;\n        instance.refs = {};\n        initializeUpdateQueue(workInProgress2);\n        var contextType = ctor.contextType;\n        if (typeof contextType === \"object\" && contextType !== null) {\n          instance.context = readContext(contextType);\n        } else {\n          var unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);\n          instance.context = getMaskedContext(workInProgress2, unmaskedContext);\n        }\n        {\n          if (instance.state === newProps) {\n            var componentName = getComponentNameFromType(ctor) || \"Component\";\n            if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n              didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n              error(\"%s: It is not recommended to assign props directly to state \" + \"because updates to props won't be reflected in state. \" + \"In most cases, it is better to use props directly.\", componentName);\n            }\n          }\n          if (workInProgress2.mode & StrictLegacyMode) {\n            ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, instance);\n          }\n          {\n            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, instance);\n          }\n        }\n        instance.state = workInProgress2.memoizedState;\n        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n        if (typeof getDerivedStateFromProps === \"function\") {\n          applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);\n          instance.state = workInProgress2.memoizedState;\n        }\n        if (typeof ctor.getDerivedStateFromProps !== \"function\" && typeof instance.getSnapshotBeforeUpdate !== \"function\" && (typeof instance.UNSAFE_componentWillMount === \"function\" || typeof instance.componentWillMount === \"function\")) {\n          callComponentWillMount(workInProgress2, instance);\n          processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);\n          instance.state = workInProgress2.memoizedState;\n        }\n        if (typeof instance.componentDidMount === \"function\") {\n          var fiberFlags = Update;\n          {\n            fiberFlags |= LayoutStatic;\n          }\n          if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {\n            fiberFlags |= MountLayoutDev;\n          }\n          workInProgress2.flags |= fiberFlags;\n        }\n      }\n      function resumeMountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {\n        var instance = workInProgress2.stateNode;\n        var oldProps = workInProgress2.memoizedProps;\n        instance.props = oldProps;\n        var oldContext = instance.context;\n        var contextType = ctor.contextType;\n        var nextContext = emptyContextObject;\n        if (typeof contextType === \"object\" && contextType !== null) {\n          nextContext = readContext(contextType);\n        } else {\n          var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);\n          nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext);\n        }\n        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n        var hasNewLifecycles = typeof getDerivedStateFromProps === \"function\" || typeof instance.getSnapshotBeforeUpdate === \"function\";\n        if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === \"function\" || typeof instance.componentWillReceiveProps === \"function\")) {\n          if (oldProps !== newProps || oldContext !== nextContext) {\n            callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);\n          }\n        }\n        resetHasForceUpdateBeforeProcessing();\n        var oldState = workInProgress2.memoizedState;\n        var newState = instance.state = oldState;\n        processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);\n        newState = workInProgress2.memoizedState;\n        if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {\n          if (typeof instance.componentDidMount === \"function\") {\n            var fiberFlags = Update;\n            {\n              fiberFlags |= LayoutStatic;\n            }\n            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {\n              fiberFlags |= MountLayoutDev;\n            }\n            workInProgress2.flags |= fiberFlags;\n          }\n          return false;\n        }\n        if (typeof getDerivedStateFromProps === \"function\") {\n          applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);\n          newState = workInProgress2.memoizedState;\n        }\n        var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);\n        if (shouldUpdate) {\n          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === \"function\" || typeof instance.componentWillMount === \"function\")) {\n            if (typeof instance.componentWillMount === \"function\") {\n              instance.componentWillMount();\n            }\n            if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n              instance.UNSAFE_componentWillMount();\n            }\n          }\n          if (typeof instance.componentDidMount === \"function\") {\n            var _fiberFlags = Update;\n            {\n              _fiberFlags |= LayoutStatic;\n            }\n            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {\n              _fiberFlags |= MountLayoutDev;\n            }\n            workInProgress2.flags |= _fiberFlags;\n          }\n        } else {\n          if (typeof instance.componentDidMount === \"function\") {\n            var _fiberFlags2 = Update;\n            {\n              _fiberFlags2 |= LayoutStatic;\n            }\n            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {\n              _fiberFlags2 |= MountLayoutDev;\n            }\n            workInProgress2.flags |= _fiberFlags2;\n          }\n          workInProgress2.memoizedProps = newProps;\n          workInProgress2.memoizedState = newState;\n        }\n        instance.props = newProps;\n        instance.state = newState;\n        instance.context = nextContext;\n        return shouldUpdate;\n      }\n      function updateClassInstance(current2, workInProgress2, ctor, newProps, renderLanes2) {\n        var instance = workInProgress2.stateNode;\n        cloneUpdateQueue(current2, workInProgress2);\n        var unresolvedOldProps = workInProgress2.memoizedProps;\n        var oldProps = workInProgress2.type === workInProgress2.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress2.type, unresolvedOldProps);\n        instance.props = oldProps;\n        var unresolvedNewProps = workInProgress2.pendingProps;\n        var oldContext = instance.context;\n        var contextType = ctor.contextType;\n        var nextContext = emptyContextObject;\n        if (typeof contextType === \"object\" && contextType !== null) {\n          nextContext = readContext(contextType);\n        } else {\n          var nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);\n          nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext);\n        }\n        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n        var hasNewLifecycles = typeof getDerivedStateFromProps === \"function\" || typeof instance.getSnapshotBeforeUpdate === \"function\";\n        if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === \"function\" || typeof instance.componentWillReceiveProps === \"function\")) {\n          if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {\n            callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);\n          }\n        }\n        resetHasForceUpdateBeforeProcessing();\n        var oldState = workInProgress2.memoizedState;\n        var newState = instance.state = oldState;\n        processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);\n        newState = workInProgress2.memoizedState;\n        if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !enableLazyContextPropagation) {\n          if (typeof instance.componentDidUpdate === \"function\") {\n            if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {\n              workInProgress2.flags |= Update;\n            }\n          }\n          if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n            if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {\n              workInProgress2.flags |= Snapshot;\n            }\n          }\n          return false;\n        }\n        if (typeof getDerivedStateFromProps === \"function\") {\n          applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);\n          newState = workInProgress2.memoizedState;\n        }\n        var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) || enableLazyContextPropagation;\n        if (shouldUpdate) {\n          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === \"function\" || typeof instance.componentWillUpdate === \"function\")) {\n            if (typeof instance.componentWillUpdate === \"function\") {\n              instance.componentWillUpdate(newProps, newState, nextContext);\n            }\n            if (typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n              instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);\n            }\n          }\n          if (typeof instance.componentDidUpdate === \"function\") {\n            workInProgress2.flags |= Update;\n          }\n          if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n            workInProgress2.flags |= Snapshot;\n          }\n        } else {\n          if (typeof instance.componentDidUpdate === \"function\") {\n            if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {\n              workInProgress2.flags |= Update;\n            }\n          }\n          if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n            if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {\n              workInProgress2.flags |= Snapshot;\n            }\n          }\n          workInProgress2.memoizedProps = newProps;\n          workInProgress2.memoizedState = newState;\n        }\n        instance.props = newProps;\n        instance.state = newState;\n        instance.context = nextContext;\n        return shouldUpdate;\n      }\n      function createCapturedValueAtFiber(value, source) {\n        return {\n          value,\n          source,\n          stack: getStackByFiberInDevAndProd(source),\n          digest: null\n        };\n      }\n      function createCapturedValue(value, digest, stack) {\n        return {\n          value,\n          source: null,\n          stack: stack != null ? stack : null,\n          digest: digest != null ? digest : null\n        };\n      }\n      function showErrorDialog(boundary, errorInfo) {\n        return true;\n      }\n      function logCapturedError(boundary, errorInfo) {\n        try {\n          var logError = showErrorDialog(boundary, errorInfo);\n          if (logError === false) {\n            return;\n          }\n          var error2 = errorInfo.value;\n          if (true) {\n            var source = errorInfo.source;\n            var stack = errorInfo.stack;\n            var componentStack = stack !== null ? stack : \"\";\n            if (error2 != null && error2._suppressLogging) {\n              if (boundary.tag === ClassComponent) {\n                return;\n              }\n              console[\"error\"](error2);\n            }\n            var componentName = source ? getComponentNameFromFiber(source) : null;\n            var componentNameMessage = componentName ? \"The above error occurred in the <\" + componentName + \"> component:\" : \"The above error occurred in one of your React components:\";\n            var errorBoundaryMessage;\n            if (boundary.tag === HostRoot) {\n              errorBoundaryMessage = `Consider adding an error boundary to your tree to customize error handling behavior.\n` + \"Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.\";\n            } else {\n              var errorBoundaryName = getComponentNameFromFiber(boundary) || \"Anonymous\";\n              errorBoundaryMessage = \"React will try to recreate this component tree from scratch \" + (\"using the error boundary you provided, \" + errorBoundaryName + \".\");\n            }\n            var combinedMessage = componentNameMessage + `\n` + componentStack + `\n\n` + (\"\" + errorBoundaryMessage);\n            console[\"error\"](combinedMessage);\n          } else {}\n        } catch (e) {\n          setTimeout(function() {\n            throw e;\n          });\n        }\n      }\n      var PossiblyWeakMap$1 = typeof WeakMap === \"function\" ? WeakMap : Map;\n      function createRootErrorUpdate(fiber, errorInfo, lane) {\n        var update = createUpdate(NoTimestamp, lane);\n        update.tag = CaptureUpdate;\n        update.payload = {\n          element: null\n        };\n        var error2 = errorInfo.value;\n        update.callback = function() {\n          onUncaughtError(error2);\n          logCapturedError(fiber, errorInfo);\n        };\n        return update;\n      }\n      function createClassErrorUpdate(fiber, errorInfo, lane) {\n        var update = createUpdate(NoTimestamp, lane);\n        update.tag = CaptureUpdate;\n        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n        if (typeof getDerivedStateFromError === \"function\") {\n          var error$1 = errorInfo.value;\n          update.payload = function() {\n            return getDerivedStateFromError(error$1);\n          };\n          update.callback = function() {\n            {\n              markFailedErrorBoundaryForHotReloading(fiber);\n            }\n            logCapturedError(fiber, errorInfo);\n          };\n        }\n        var inst = fiber.stateNode;\n        if (inst !== null && typeof inst.componentDidCatch === \"function\") {\n          update.callback = function callback() {\n            {\n              markFailedErrorBoundaryForHotReloading(fiber);\n            }\n            logCapturedError(fiber, errorInfo);\n            if (typeof getDerivedStateFromError !== \"function\") {\n              markLegacyErrorBoundaryAsFailed(this);\n            }\n            var error$12 = errorInfo.value;\n            var stack = errorInfo.stack;\n            this.componentDidCatch(error$12, {\n              componentStack: stack !== null ? stack : \"\"\n            });\n            {\n              if (typeof getDerivedStateFromError !== \"function\") {\n                if (!includesSomeLane(fiber.lanes, SyncLane)) {\n                  error(\"%s: Error boundaries should implement getDerivedStateFromError(). \" + \"In that method, return a state update to display an error message or fallback UI.\", getComponentNameFromFiber(fiber) || \"Unknown\");\n                }\n              }\n            }\n          };\n        }\n        return update;\n      }\n      function attachPingListener(root2, wakeable, lanes) {\n        var pingCache = root2.pingCache;\n        var threadIDs;\n        if (pingCache === null) {\n          pingCache = root2.pingCache = new PossiblyWeakMap$1;\n          threadIDs = new Set;\n          pingCache.set(wakeable, threadIDs);\n        } else {\n          threadIDs = pingCache.get(wakeable);\n          if (threadIDs === undefined) {\n            threadIDs = new Set;\n            pingCache.set(wakeable, threadIDs);\n          }\n        }\n        if (!threadIDs.has(lanes)) {\n          threadIDs.add(lanes);\n          var ping = pingSuspendedRoot.bind(null, root2, wakeable, lanes);\n          {\n            if (isDevToolsPresent) {\n              restorePendingUpdaters(root2, lanes);\n            }\n          }\n          wakeable.then(ping, ping);\n        }\n      }\n      function attachRetryListener(suspenseBoundary, root2, wakeable, lanes) {\n        var wakeables = suspenseBoundary.updateQueue;\n        if (wakeables === null) {\n          var updateQueue = new Set;\n          updateQueue.add(wakeable);\n          suspenseBoundary.updateQueue = updateQueue;\n        } else {\n          wakeables.add(wakeable);\n        }\n      }\n      function resetSuspendedComponent(sourceFiber, rootRenderLanes) {\n        var tag = sourceFiber.tag;\n        if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {\n          var currentSource = sourceFiber.alternate;\n          if (currentSource) {\n            sourceFiber.updateQueue = currentSource.updateQueue;\n            sourceFiber.memoizedState = currentSource.memoizedState;\n            sourceFiber.lanes = currentSource.lanes;\n          } else {\n            sourceFiber.updateQueue = null;\n            sourceFiber.memoizedState = null;\n          }\n        }\n      }\n      function getNearestSuspenseBoundaryToCapture(returnFiber) {\n        var node = returnFiber;\n        do {\n          if (node.tag === SuspenseComponent && shouldCaptureSuspense(node)) {\n            return node;\n          }\n          node = node.return;\n        } while (node !== null);\n        return null;\n      }\n      function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes) {\n        if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {\n          if (suspenseBoundary === returnFiber) {\n            suspenseBoundary.flags |= ShouldCapture;\n          } else {\n            suspenseBoundary.flags |= DidCapture;\n            sourceFiber.flags |= ForceUpdateForLegacySuspense;\n            sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);\n            if (sourceFiber.tag === ClassComponent) {\n              var currentSourceFiber = sourceFiber.alternate;\n              if (currentSourceFiber === null) {\n                sourceFiber.tag = IncompleteClassComponent;\n              } else {\n                var update = createUpdate(NoTimestamp, SyncLane);\n                update.tag = ForceUpdate;\n                enqueueUpdate(sourceFiber, update, SyncLane);\n              }\n            }\n            sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);\n          }\n          return suspenseBoundary;\n        }\n        suspenseBoundary.flags |= ShouldCapture;\n        suspenseBoundary.lanes = rootRenderLanes;\n        return suspenseBoundary;\n      }\n      function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {\n        sourceFiber.flags |= Incomplete;\n        {\n          if (isDevToolsPresent) {\n            restorePendingUpdaters(root2, rootRenderLanes);\n          }\n        }\n        if (value !== null && typeof value === \"object\" && typeof value.then === \"function\") {\n          var wakeable = value;\n          resetSuspendedComponent(sourceFiber);\n          {\n            if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {\n              markDidThrowWhileHydratingDEV();\n            }\n          }\n          var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);\n          if (suspenseBoundary !== null) {\n            suspenseBoundary.flags &= ~ForceClientRender;\n            markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes);\n            if (suspenseBoundary.mode & ConcurrentMode) {\n              attachPingListener(root2, wakeable, rootRenderLanes);\n            }\n            attachRetryListener(suspenseBoundary, root2, wakeable);\n            return;\n          } else {\n            if (!includesSyncLane(rootRenderLanes)) {\n              attachPingListener(root2, wakeable, rootRenderLanes);\n              renderDidSuspendDelayIfPossible();\n              return;\n            }\n            var uncaughtSuspenseError = new Error(\"A component suspended while responding to synchronous input. This \" + \"will cause the UI to be replaced with a loading indicator. To \" + \"fix, updates that suspend should be wrapped \" + \"with startTransition.\");\n            value = uncaughtSuspenseError;\n          }\n        } else {\n          if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {\n            markDidThrowWhileHydratingDEV();\n            var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);\n            if (_suspenseBoundary !== null) {\n              if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {\n                _suspenseBoundary.flags |= ForceClientRender;\n              }\n              markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes);\n              queueHydrationError(createCapturedValueAtFiber(value, sourceFiber));\n              return;\n            }\n          }\n        }\n        value = createCapturedValueAtFiber(value, sourceFiber);\n        renderDidError(value);\n        var workInProgress2 = returnFiber;\n        do {\n          switch (workInProgress2.tag) {\n            case HostRoot: {\n              var _errorInfo = value;\n              workInProgress2.flags |= ShouldCapture;\n              var lane = pickArbitraryLane(rootRenderLanes);\n              workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);\n              var update = createRootErrorUpdate(workInProgress2, _errorInfo, lane);\n              enqueueCapturedUpdate(workInProgress2, update);\n              return;\n            }\n            case ClassComponent:\n              var errorInfo = value;\n              var ctor = workInProgress2.type;\n              var instance = workInProgress2.stateNode;\n              if ((workInProgress2.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === \"function\" || instance !== null && typeof instance.componentDidCatch === \"function\" && !isAlreadyFailedLegacyErrorBoundary(instance))) {\n                workInProgress2.flags |= ShouldCapture;\n                var _lane = pickArbitraryLane(rootRenderLanes);\n                workInProgress2.lanes = mergeLanes(workInProgress2.lanes, _lane);\n                var _update = createClassErrorUpdate(workInProgress2, errorInfo, _lane);\n                enqueueCapturedUpdate(workInProgress2, _update);\n                return;\n              }\n              break;\n          }\n          workInProgress2 = workInProgress2.return;\n        } while (workInProgress2 !== null);\n      }\n      function getSuspendedCache() {\n        {\n          return null;\n        }\n      }\n      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n      var didReceiveUpdate = false;\n      var didWarnAboutBadClass;\n      var didWarnAboutModulePatternComponent;\n      var didWarnAboutContextTypeOnFunctionComponent;\n      var didWarnAboutGetDerivedStateOnFunctionComponent;\n      var didWarnAboutFunctionRefs;\n      var didWarnAboutReassigningProps;\n      var didWarnAboutRevealOrder;\n      var didWarnAboutTailOptions;\n      var didWarnAboutDefaultPropsOnFunctionComponent;\n      {\n        didWarnAboutBadClass = {};\n        didWarnAboutModulePatternComponent = {};\n        didWarnAboutContextTypeOnFunctionComponent = {};\n        didWarnAboutGetDerivedStateOnFunctionComponent = {};\n        didWarnAboutFunctionRefs = {};\n        didWarnAboutReassigningProps = false;\n        didWarnAboutRevealOrder = {};\n        didWarnAboutTailOptions = {};\n        didWarnAboutDefaultPropsOnFunctionComponent = {};\n      }\n      function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {\n        if (current2 === null) {\n          workInProgress2.child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);\n        } else {\n          workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, nextChildren, renderLanes2);\n        }\n      }\n      function forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2) {\n        workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);\n        workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);\n      }\n      function updateForwardRef(current2, workInProgress2, Component, nextProps, renderLanes2) {\n        {\n          if (workInProgress2.type !== workInProgress2.elementType) {\n            var innerPropTypes = Component.propTypes;\n            if (innerPropTypes) {\n              checkPropTypes(innerPropTypes, nextProps, \"prop\", getComponentNameFromType(Component));\n            }\n          }\n        }\n        var render2 = Component.render;\n        var ref = workInProgress2.ref;\n        var nextChildren;\n        var hasId;\n        prepareToReadContext(workInProgress2, renderLanes2);\n        {\n          markComponentRenderStarted(workInProgress2);\n        }\n        {\n          ReactCurrentOwner$1.current = workInProgress2;\n          setIsRendering(true);\n          nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);\n          hasId = checkDidRenderIdHook();\n          if (workInProgress2.mode & StrictLegacyMode) {\n            setIsStrictModeForDevtools(true);\n            try {\n              nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);\n              hasId = checkDidRenderIdHook();\n            } finally {\n              setIsStrictModeForDevtools(false);\n            }\n          }\n          setIsRendering(false);\n        }\n        {\n          markComponentRenderStopped();\n        }\n        if (current2 !== null && !didReceiveUpdate) {\n          bailoutHooks(current2, workInProgress2, renderLanes2);\n          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);\n        }\n        if (getIsHydrating() && hasId) {\n          pushMaterializedTreeId(workInProgress2);\n        }\n        workInProgress2.flags |= PerformedWork;\n        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n        return workInProgress2.child;\n      }\n      function updateMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {\n        if (current2 === null) {\n          var type = Component.type;\n          if (isSimpleFunctionComponent(type) && Component.compare === null && Component.defaultProps === undefined) {\n            var resolvedType = type;\n            {\n              resolvedType = resolveFunctionForHotReloading(type);\n            }\n            workInProgress2.tag = SimpleMemoComponent;\n            workInProgress2.type = resolvedType;\n            {\n              validateFunctionComponentInDev(workInProgress2, type);\n            }\n            return updateSimpleMemoComponent(current2, workInProgress2, resolvedType, nextProps, renderLanes2);\n          }\n          {\n            var innerPropTypes = type.propTypes;\n            if (innerPropTypes) {\n              checkPropTypes(innerPropTypes, nextProps, \"prop\", getComponentNameFromType(type));\n            }\n            if (Component.defaultProps !== undefined) {\n              var componentName = getComponentNameFromType(type) || \"Unknown\";\n              if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {\n                error(\"%s: Support for defaultProps will be removed from memo components \" + \"in a future major release. Use JavaScript default parameters instead.\", componentName);\n                didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;\n              }\n            }\n          }\n          var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);\n          child.ref = workInProgress2.ref;\n          child.return = workInProgress2;\n          workInProgress2.child = child;\n          return child;\n        }\n        {\n          var _type = Component.type;\n          var _innerPropTypes = _type.propTypes;\n          if (_innerPropTypes) {\n            checkPropTypes(_innerPropTypes, nextProps, \"prop\", getComponentNameFromType(_type));\n          }\n        }\n        var currentChild = current2.child;\n        var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);\n        if (!hasScheduledUpdateOrContext) {\n          var prevProps = currentChild.memoizedProps;\n          var compare = Component.compare;\n          compare = compare !== null ? compare : shallowEqual;\n          if (compare(prevProps, nextProps) && current2.ref === workInProgress2.ref) {\n            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);\n          }\n        }\n        workInProgress2.flags |= PerformedWork;\n        var newChild = createWorkInProgress(currentChild, nextProps);\n        newChild.ref = workInProgress2.ref;\n        newChild.return = workInProgress2;\n        workInProgress2.child = newChild;\n        return newChild;\n      }\n      function updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {\n        {\n          if (workInProgress2.type !== workInProgress2.elementType) {\n            var outerMemoType = workInProgress2.elementType;\n            if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {\n              var lazyComponent = outerMemoType;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n              try {\n                outerMemoType = init(payload);\n              } catch (x) {\n                outerMemoType = null;\n              }\n              var outerPropTypes = outerMemoType && outerMemoType.propTypes;\n              if (outerPropTypes) {\n                checkPropTypes(outerPropTypes, nextProps, \"prop\", getComponentNameFromType(outerMemoType));\n              }\n            }\n          }\n        }\n        if (current2 !== null) {\n          var prevProps = current2.memoizedProps;\n          if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && workInProgress2.type === current2.type) {\n            didReceiveUpdate = false;\n            workInProgress2.pendingProps = nextProps = prevProps;\n            if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {\n              workInProgress2.lanes = current2.lanes;\n              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);\n            } else if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n              didReceiveUpdate = true;\n            }\n          }\n        }\n        return updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2);\n      }\n      function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {\n        var nextProps = workInProgress2.pendingProps;\n        var nextChildren = nextProps.children;\n        var prevState = current2 !== null ? current2.memoizedState : null;\n        if (nextProps.mode === \"hidden\" || enableLegacyHidden) {\n          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {\n            var nextState = {\n              baseLanes: NoLanes,\n              cachePool: null,\n              transitions: null\n            };\n            workInProgress2.memoizedState = nextState;\n            pushRenderLanes(workInProgress2, renderLanes2);\n          } else if (!includesSomeLane(renderLanes2, OffscreenLane)) {\n            var spawnedCachePool = null;\n            var nextBaseLanes;\n            if (prevState !== null) {\n              var prevBaseLanes = prevState.baseLanes;\n              nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes2);\n            } else {\n              nextBaseLanes = renderLanes2;\n            }\n            workInProgress2.lanes = workInProgress2.childLanes = laneToLanes(OffscreenLane);\n            var _nextState = {\n              baseLanes: nextBaseLanes,\n              cachePool: spawnedCachePool,\n              transitions: null\n            };\n            workInProgress2.memoizedState = _nextState;\n            workInProgress2.updateQueue = null;\n            pushRenderLanes(workInProgress2, nextBaseLanes);\n            return null;\n          } else {\n            var _nextState2 = {\n              baseLanes: NoLanes,\n              cachePool: null,\n              transitions: null\n            };\n            workInProgress2.memoizedState = _nextState2;\n            var subtreeRenderLanes2 = prevState !== null ? prevState.baseLanes : renderLanes2;\n            pushRenderLanes(workInProgress2, subtreeRenderLanes2);\n          }\n        } else {\n          var _subtreeRenderLanes;\n          if (prevState !== null) {\n            _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes2);\n            workInProgress2.memoizedState = null;\n          } else {\n            _subtreeRenderLanes = renderLanes2;\n          }\n          pushRenderLanes(workInProgress2, _subtreeRenderLanes);\n        }\n        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n        return workInProgress2.child;\n      }\n      function updateFragment(current2, workInProgress2, renderLanes2) {\n        var nextChildren = workInProgress2.pendingProps;\n        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n        return workInProgress2.child;\n      }\n      function updateMode(current2, workInProgress2, renderLanes2) {\n        var nextChildren = workInProgress2.pendingProps.children;\n        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n        return workInProgress2.child;\n      }\n      function updateProfiler(current2, workInProgress2, renderLanes2) {\n        {\n          workInProgress2.flags |= Update;\n          {\n            var stateNode = workInProgress2.stateNode;\n            stateNode.effectDuration = 0;\n            stateNode.passiveEffectDuration = 0;\n          }\n        }\n        var nextProps = workInProgress2.pendingProps;\n        var nextChildren = nextProps.children;\n        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n        return workInProgress2.child;\n      }\n      function markRef(current2, workInProgress2) {\n        var ref = workInProgress2.ref;\n        if (current2 === null && ref !== null || current2 !== null && current2.ref !== ref) {\n          workInProgress2.flags |= Ref;\n          {\n            workInProgress2.flags |= RefStatic;\n          }\n        }\n      }\n      function updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {\n        {\n          if (workInProgress2.type !== workInProgress2.elementType) {\n            var innerPropTypes = Component.propTypes;\n            if (innerPropTypes) {\n              checkPropTypes(innerPropTypes, nextProps, \"prop\", getComponentNameFromType(Component));\n            }\n          }\n        }\n        var context;\n        {\n          var unmaskedContext = getUnmaskedContext(workInProgress2, Component, true);\n          context = getMaskedContext(workInProgress2, unmaskedContext);\n        }\n        var nextChildren;\n        var hasId;\n        prepareToReadContext(workInProgress2, renderLanes2);\n        {\n          markComponentRenderStarted(workInProgress2);\n        }\n        {\n          ReactCurrentOwner$1.current = workInProgress2;\n          setIsRendering(true);\n          nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2);\n          hasId = checkDidRenderIdHook();\n          if (workInProgress2.mode & StrictLegacyMode) {\n            setIsStrictModeForDevtools(true);\n            try {\n              nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2);\n              hasId = checkDidRenderIdHook();\n            } finally {\n              setIsStrictModeForDevtools(false);\n            }\n          }\n          setIsRendering(false);\n        }\n        {\n          markComponentRenderStopped();\n        }\n        if (current2 !== null && !didReceiveUpdate) {\n          bailoutHooks(current2, workInProgress2, renderLanes2);\n          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);\n        }\n        if (getIsHydrating() && hasId) {\n          pushMaterializedTreeId(workInProgress2);\n        }\n        workInProgress2.flags |= PerformedWork;\n        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n        return workInProgress2.child;\n      }\n      function updateClassComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {\n        {\n          switch (shouldError(workInProgress2)) {\n            case false: {\n              var _instance = workInProgress2.stateNode;\n              var ctor = workInProgress2.type;\n              var tempInstance = new ctor(workInProgress2.memoizedProps, _instance.context);\n              var state = tempInstance.state;\n              _instance.updater.enqueueSetState(_instance, state, null);\n              break;\n            }\n            case true: {\n              workInProgress2.flags |= DidCapture;\n              workInProgress2.flags |= ShouldCapture;\n              var error$1 = new Error(\"Simulated error coming from DevTools\");\n              var lane = pickArbitraryLane(renderLanes2);\n              workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);\n              var update = createClassErrorUpdate(workInProgress2, createCapturedValueAtFiber(error$1, workInProgress2), lane);\n              enqueueCapturedUpdate(workInProgress2, update);\n              break;\n            }\n          }\n          if (workInProgress2.type !== workInProgress2.elementType) {\n            var innerPropTypes = Component.propTypes;\n            if (innerPropTypes) {\n              checkPropTypes(innerPropTypes, nextProps, \"prop\", getComponentNameFromType(Component));\n            }\n          }\n        }\n        var hasContext;\n        if (isContextProvider(Component)) {\n          hasContext = true;\n          pushContextProvider(workInProgress2);\n        } else {\n          hasContext = false;\n        }\n        prepareToReadContext(workInProgress2, renderLanes2);\n        var instance = workInProgress2.stateNode;\n        var shouldUpdate;\n        if (instance === null) {\n          resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2);\n          constructClassInstance(workInProgress2, Component, nextProps);\n          mountClassInstance(workInProgress2, Component, nextProps, renderLanes2);\n          shouldUpdate = true;\n        } else if (current2 === null) {\n          shouldUpdate = resumeMountClassInstance(workInProgress2, Component, nextProps, renderLanes2);\n        } else {\n          shouldUpdate = updateClassInstance(current2, workInProgress2, Component, nextProps, renderLanes2);\n        }\n        var nextUnitOfWork = finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2);\n        {\n          var inst = workInProgress2.stateNode;\n          if (shouldUpdate && inst.props !== nextProps) {\n            if (!didWarnAboutReassigningProps) {\n              error(\"It looks like %s is reassigning its own `this.props` while rendering. \" + \"This is not supported and can lead to confusing bugs.\", getComponentNameFromFiber(workInProgress2) || \"a component\");\n            }\n            didWarnAboutReassigningProps = true;\n          }\n        }\n        return nextUnitOfWork;\n      }\n      function finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2) {\n        markRef(current2, workInProgress2);\n        var didCaptureError = (workInProgress2.flags & DidCapture) !== NoFlags;\n        if (!shouldUpdate && !didCaptureError) {\n          if (hasContext) {\n            invalidateContextProvider(workInProgress2, Component, false);\n          }\n          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);\n        }\n        var instance = workInProgress2.stateNode;\n        ReactCurrentOwner$1.current = workInProgress2;\n        var nextChildren;\n        if (didCaptureError && typeof Component.getDerivedStateFromError !== \"function\") {\n          nextChildren = null;\n          {\n            stopProfilerTimerIfRunning();\n          }\n        } else {\n          {\n            markComponentRenderStarted(workInProgress2);\n          }\n          {\n            setIsRendering(true);\n            nextChildren = instance.render();\n            if (workInProgress2.mode & StrictLegacyMode) {\n              setIsStrictModeForDevtools(true);\n              try {\n                instance.render();\n              } finally {\n                setIsStrictModeForDevtools(false);\n              }\n            }\n            setIsRendering(false);\n          }\n          {\n            markComponentRenderStopped();\n          }\n        }\n        workInProgress2.flags |= PerformedWork;\n        if (current2 !== null && didCaptureError) {\n          forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2);\n        } else {\n          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n        }\n        workInProgress2.memoizedState = instance.state;\n        if (hasContext) {\n          invalidateContextProvider(workInProgress2, Component, true);\n        }\n        return workInProgress2.child;\n      }\n      function pushHostRootContext(workInProgress2) {\n        var root2 = workInProgress2.stateNode;\n        if (root2.pendingContext) {\n          pushTopLevelContextObject(workInProgress2, root2.pendingContext, root2.pendingContext !== root2.context);\n        } else if (root2.context) {\n          pushTopLevelContextObject(workInProgress2, root2.context, false);\n        }\n        pushHostContainer(workInProgress2, root2.containerInfo);\n      }\n      function updateHostRoot(current2, workInProgress2, renderLanes2) {\n        pushHostRootContext(workInProgress2);\n        if (current2 === null) {\n          throw new Error(\"Should have a current fiber. This is a bug in React.\");\n        }\n        var nextProps = workInProgress2.pendingProps;\n        var prevState = workInProgress2.memoizedState;\n        var prevChildren = prevState.element;\n        cloneUpdateQueue(current2, workInProgress2);\n        processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);\n        var nextState = workInProgress2.memoizedState;\n        var root2 = workInProgress2.stateNode;\n        var nextChildren = nextState.element;\n        if (prevState.isDehydrated) {\n          var overrideState = {\n            element: nextChildren,\n            isDehydrated: false,\n            cache: nextState.cache,\n            pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,\n            transitions: nextState.transitions\n          };\n          var updateQueue = workInProgress2.updateQueue;\n          updateQueue.baseState = overrideState;\n          workInProgress2.memoizedState = overrideState;\n          if (workInProgress2.flags & ForceClientRender) {\n            var recoverableError = createCapturedValueAtFiber(new Error(\"There was an error while hydrating. Because the error happened outside \" + \"of a Suspense boundary, the entire root will switch to \" + \"client rendering.\"), workInProgress2);\n            return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError);\n          } else if (nextChildren !== prevChildren) {\n            var _recoverableError = createCapturedValueAtFiber(new Error(\"This root received an early update, before anything was able \" + \"hydrate. Switched the entire root to client rendering.\"), workInProgress2);\n            return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, _recoverableError);\n          } else {\n            enterHydrationState(workInProgress2);\n            var child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);\n            workInProgress2.child = child;\n            var node = child;\n            while (node) {\n              node.flags = node.flags & ~Placement | Hydrating;\n              node = node.sibling;\n            }\n          }\n        } else {\n          resetHydrationState();\n          if (nextChildren === prevChildren) {\n            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);\n          }\n          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n        }\n        return workInProgress2.child;\n      }\n      function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError) {\n        resetHydrationState();\n        queueHydrationError(recoverableError);\n        workInProgress2.flags |= ForceClientRender;\n        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n        return workInProgress2.child;\n      }\n      function updateHostComponent(current2, workInProgress2, renderLanes2) {\n        pushHostContext(workInProgress2);\n        if (current2 === null) {\n          tryToClaimNextHydratableInstance(workInProgress2);\n        }\n        var type = workInProgress2.type;\n        var nextProps = workInProgress2.pendingProps;\n        var prevProps = current2 !== null ? current2.memoizedProps : null;\n        var nextChildren = nextProps.children;\n        var isDirectTextChild = shouldSetTextContent(type, nextProps);\n        if (isDirectTextChild) {\n          nextChildren = null;\n        } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\n          workInProgress2.flags |= ContentReset;\n        }\n        markRef(current2, workInProgress2);\n        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n        return workInProgress2.child;\n      }\n      function updateHostText(current2, workInProgress2) {\n        if (current2 === null) {\n          tryToClaimNextHydratableInstance(workInProgress2);\n        }\n        return null;\n      }\n      function mountLazyComponent(_current, workInProgress2, elementType, renderLanes2) {\n        resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);\n        var props = workInProgress2.pendingProps;\n        var lazyComponent = elementType;\n        var payload = lazyComponent._payload;\n        var init = lazyComponent._init;\n        var Component = init(payload);\n        workInProgress2.type = Component;\n        var resolvedTag = workInProgress2.tag = resolveLazyComponentTag(Component);\n        var resolvedProps = resolveDefaultProps(Component, props);\n        var child;\n        switch (resolvedTag) {\n          case FunctionComponent: {\n            {\n              validateFunctionComponentInDev(workInProgress2, Component);\n              workInProgress2.type = Component = resolveFunctionForHotReloading(Component);\n            }\n            child = updateFunctionComponent(null, workInProgress2, Component, resolvedProps, renderLanes2);\n            return child;\n          }\n          case ClassComponent: {\n            {\n              workInProgress2.type = Component = resolveClassForHotReloading(Component);\n            }\n            child = updateClassComponent(null, workInProgress2, Component, resolvedProps, renderLanes2);\n            return child;\n          }\n          case ForwardRef: {\n            {\n              workInProgress2.type = Component = resolveForwardRefForHotReloading(Component);\n            }\n            child = updateForwardRef(null, workInProgress2, Component, resolvedProps, renderLanes2);\n            return child;\n          }\n          case MemoComponent: {\n            {\n              if (workInProgress2.type !== workInProgress2.elementType) {\n                var outerPropTypes = Component.propTypes;\n                if (outerPropTypes) {\n                  checkPropTypes(outerPropTypes, resolvedProps, \"prop\", getComponentNameFromType(Component));\n                }\n              }\n            }\n            child = updateMemoComponent(null, workInProgress2, Component, resolveDefaultProps(Component.type, resolvedProps), renderLanes2);\n            return child;\n          }\n        }\n        var hint = \"\";\n        {\n          if (Component !== null && typeof Component === \"object\" && Component.$$typeof === REACT_LAZY_TYPE) {\n            hint = \" Did you wrap a component in React.lazy() more than once?\";\n          }\n        }\n        throw new Error(\"Element type is invalid. Received a promise that resolves to: \" + Component + \". \" + (\"Lazy element type must resolve to a class or function.\" + hint));\n      }\n      function mountIncompleteClassComponent(_current, workInProgress2, Component, nextProps, renderLanes2) {\n        resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);\n        workInProgress2.tag = ClassComponent;\n        var hasContext;\n        if (isContextProvider(Component)) {\n          hasContext = true;\n          pushContextProvider(workInProgress2);\n        } else {\n          hasContext = false;\n        }\n        prepareToReadContext(workInProgress2, renderLanes2);\n        constructClassInstance(workInProgress2, Component, nextProps);\n        mountClassInstance(workInProgress2, Component, nextProps, renderLanes2);\n        return finishClassComponent(null, workInProgress2, Component, true, hasContext, renderLanes2);\n      }\n      function mountIndeterminateComponent(_current, workInProgress2, Component, renderLanes2) {\n        resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);\n        var props = workInProgress2.pendingProps;\n        var context;\n        {\n          var unmaskedContext = getUnmaskedContext(workInProgress2, Component, false);\n          context = getMaskedContext(workInProgress2, unmaskedContext);\n        }\n        prepareToReadContext(workInProgress2, renderLanes2);\n        var value;\n        var hasId;\n        {\n          markComponentRenderStarted(workInProgress2);\n        }\n        {\n          if (Component.prototype && typeof Component.prototype.render === \"function\") {\n            var componentName = getComponentNameFromType(Component) || \"Unknown\";\n            if (!didWarnAboutBadClass[componentName]) {\n              error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + \"This is likely to cause errors. Change %s to extend React.Component instead.\", componentName, componentName);\n              didWarnAboutBadClass[componentName] = true;\n            }\n          }\n          if (workInProgress2.mode & StrictLegacyMode) {\n            ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null);\n          }\n          setIsRendering(true);\n          ReactCurrentOwner$1.current = workInProgress2;\n          value = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2);\n          hasId = checkDidRenderIdHook();\n          setIsRendering(false);\n        }\n        {\n          markComponentRenderStopped();\n        }\n        workInProgress2.flags |= PerformedWork;\n        {\n          if (typeof value === \"object\" && value !== null && typeof value.render === \"function\" && value.$$typeof === undefined) {\n            var _componentName = getComponentNameFromType(Component) || \"Unknown\";\n            if (!didWarnAboutModulePatternComponent[_componentName]) {\n              error(\"The <%s /> component appears to be a function component that returns a class instance. \" + \"Change %s to a class that extends React.Component instead. \" + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + \"cannot be called with `new` by React.\", _componentName, _componentName, _componentName);\n              didWarnAboutModulePatternComponent[_componentName] = true;\n            }\n          }\n        }\n        if (typeof value === \"object\" && value !== null && typeof value.render === \"function\" && value.$$typeof === undefined) {\n          {\n            var _componentName2 = getComponentNameFromType(Component) || \"Unknown\";\n            if (!didWarnAboutModulePatternComponent[_componentName2]) {\n              error(\"The <%s /> component appears to be a function component that returns a class instance. \" + \"Change %s to a class that extends React.Component instead. \" + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + \"cannot be called with `new` by React.\", _componentName2, _componentName2, _componentName2);\n              didWarnAboutModulePatternComponent[_componentName2] = true;\n            }\n          }\n          workInProgress2.tag = ClassComponent;\n          workInProgress2.memoizedState = null;\n          workInProgress2.updateQueue = null;\n          var hasContext = false;\n          if (isContextProvider(Component)) {\n            hasContext = true;\n            pushContextProvider(workInProgress2);\n          } else {\n            hasContext = false;\n          }\n          workInProgress2.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;\n          initializeUpdateQueue(workInProgress2);\n          adoptClassInstance(workInProgress2, value);\n          mountClassInstance(workInProgress2, Component, props, renderLanes2);\n          return finishClassComponent(null, workInProgress2, Component, true, hasContext, renderLanes2);\n        } else {\n          workInProgress2.tag = FunctionComponent;\n          {\n            if (workInProgress2.mode & StrictLegacyMode) {\n              setIsStrictModeForDevtools(true);\n              try {\n                value = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2);\n                hasId = checkDidRenderIdHook();\n              } finally {\n                setIsStrictModeForDevtools(false);\n              }\n            }\n          }\n          if (getIsHydrating() && hasId) {\n            pushMaterializedTreeId(workInProgress2);\n          }\n          reconcileChildren(null, workInProgress2, value, renderLanes2);\n          {\n            validateFunctionComponentInDev(workInProgress2, Component);\n          }\n          return workInProgress2.child;\n        }\n      }\n      function validateFunctionComponentInDev(workInProgress2, Component) {\n        {\n          if (Component) {\n            if (Component.childContextTypes) {\n              error(\"%s(...): childContextTypes cannot be defined on a function component.\", Component.displayName || Component.name || \"Component\");\n            }\n          }\n          if (workInProgress2.ref !== null) {\n            var info = \"\";\n            var ownerName = getCurrentFiberOwnerNameInDevOrNull();\n            if (ownerName) {\n              info += `\n\nCheck the render method of \\`` + ownerName + \"`.\";\n            }\n            var warningKey = ownerName || \"\";\n            var debugSource = workInProgress2._debugSource;\n            if (debugSource) {\n              warningKey = debugSource.fileName + \":\" + debugSource.lineNumber;\n            }\n            if (!didWarnAboutFunctionRefs[warningKey]) {\n              didWarnAboutFunctionRefs[warningKey] = true;\n              error(\"Function components cannot be given refs. \" + \"Attempts to access this ref will fail. \" + \"Did you mean to use React.forwardRef()?%s\", info);\n            }\n          }\n          if (Component.defaultProps !== undefined) {\n            var componentName = getComponentNameFromType(Component) || \"Unknown\";\n            if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {\n              error(\"%s: Support for defaultProps will be removed from function components \" + \"in a future major release. Use JavaScript default parameters instead.\", componentName);\n              didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;\n            }\n          }\n          if (typeof Component.getDerivedStateFromProps === \"function\") {\n            var _componentName3 = getComponentNameFromType(Component) || \"Unknown\";\n            if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {\n              error(\"%s: Function components do not support getDerivedStateFromProps.\", _componentName3);\n              didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;\n            }\n          }\n          if (typeof Component.contextType === \"object\" && Component.contextType !== null) {\n            var _componentName4 = getComponentNameFromType(Component) || \"Unknown\";\n            if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {\n              error(\"%s: Function components do not support contextType.\", _componentName4);\n              didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;\n            }\n          }\n        }\n      }\n      var SUSPENDED_MARKER = {\n        dehydrated: null,\n        treeContext: null,\n        retryLane: NoLane\n      };\n      function mountSuspenseOffscreenState(renderLanes2) {\n        return {\n          baseLanes: renderLanes2,\n          cachePool: getSuspendedCache(),\n          transitions: null\n        };\n      }\n      function updateSuspenseOffscreenState(prevOffscreenState, renderLanes2) {\n        var cachePool = null;\n        return {\n          baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes2),\n          cachePool,\n          transitions: prevOffscreenState.transitions\n        };\n      }\n      function shouldRemainOnFallback(suspenseContext, current2, workInProgress2, renderLanes2) {\n        if (current2 !== null) {\n          var suspenseState = current2.memoizedState;\n          if (suspenseState === null) {\n            return false;\n          }\n        }\n        return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);\n      }\n      function getRemainingWorkInPrimaryTree(current2, renderLanes2) {\n        return removeLanes(current2.childLanes, renderLanes2);\n      }\n      function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {\n        var nextProps = workInProgress2.pendingProps;\n        {\n          if (shouldSuspend(workInProgress2)) {\n            workInProgress2.flags |= DidCapture;\n          }\n        }\n        var suspenseContext = suspenseStackCursor.current;\n        var showFallback = false;\n        var didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags;\n        if (didSuspend || shouldRemainOnFallback(suspenseContext, current2)) {\n          showFallback = true;\n          workInProgress2.flags &= ~DidCapture;\n        } else {\n          if (current2 === null || current2.memoizedState !== null) {\n            {\n              suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);\n            }\n          }\n        }\n        suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n        pushSuspenseContext(workInProgress2, suspenseContext);\n        if (current2 === null) {\n          tryToClaimNextHydratableInstance(workInProgress2);\n          var suspenseState = workInProgress2.memoizedState;\n          if (suspenseState !== null) {\n            var dehydrated = suspenseState.dehydrated;\n            if (dehydrated !== null) {\n              return mountDehydratedSuspenseComponent(workInProgress2, dehydrated);\n            }\n          }\n          var nextPrimaryChildren = nextProps.children;\n          var nextFallbackChildren = nextProps.fallback;\n          if (showFallback) {\n            var fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);\n            var primaryChildFragment = workInProgress2.child;\n            primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);\n            workInProgress2.memoizedState = SUSPENDED_MARKER;\n            return fallbackFragment;\n          } else {\n            return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);\n          }\n        } else {\n          var prevState = current2.memoizedState;\n          if (prevState !== null) {\n            var _dehydrated = prevState.dehydrated;\n            if (_dehydrated !== null) {\n              return updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, _dehydrated, prevState, renderLanes2);\n            }\n          }\n          if (showFallback) {\n            var _nextFallbackChildren = nextProps.fallback;\n            var _nextPrimaryChildren = nextProps.children;\n            var fallbackChildFragment = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren, _nextFallbackChildren, renderLanes2);\n            var _primaryChildFragment2 = workInProgress2.child;\n            var prevOffscreenState = current2.child.memoizedState;\n            _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes2);\n            _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2);\n            workInProgress2.memoizedState = SUSPENDED_MARKER;\n            return fallbackChildFragment;\n          } else {\n            var _nextPrimaryChildren2 = nextProps.children;\n            var _primaryChildFragment3 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren2, renderLanes2);\n            workInProgress2.memoizedState = null;\n            return _primaryChildFragment3;\n          }\n        }\n      }\n      function mountSuspensePrimaryChildren(workInProgress2, primaryChildren, renderLanes2) {\n        var mode = workInProgress2.mode;\n        var primaryChildProps = {\n          mode: \"visible\",\n          children: primaryChildren\n        };\n        var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);\n        primaryChildFragment.return = workInProgress2;\n        workInProgress2.child = primaryChildFragment;\n        return primaryChildFragment;\n      }\n      function mountSuspenseFallbackChildren(workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {\n        var mode = workInProgress2.mode;\n        var progressedPrimaryFragment = workInProgress2.child;\n        var primaryChildProps = {\n          mode: \"hidden\",\n          children: primaryChildren\n        };\n        var primaryChildFragment;\n        var fallbackChildFragment;\n        if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {\n          primaryChildFragment = progressedPrimaryFragment;\n          primaryChildFragment.childLanes = NoLanes;\n          primaryChildFragment.pendingProps = primaryChildProps;\n          if (workInProgress2.mode & ProfileMode) {\n            primaryChildFragment.actualDuration = 0;\n            primaryChildFragment.actualStartTime = -1;\n            primaryChildFragment.selfBaseDuration = 0;\n            primaryChildFragment.treeBaseDuration = 0;\n          }\n          fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);\n        } else {\n          primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);\n          fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);\n        }\n        primaryChildFragment.return = workInProgress2;\n        fallbackChildFragment.return = workInProgress2;\n        primaryChildFragment.sibling = fallbackChildFragment;\n        workInProgress2.child = primaryChildFragment;\n        return fallbackChildFragment;\n      }\n      function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes2) {\n        return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);\n      }\n      function updateWorkInProgressOffscreenFiber(current2, offscreenProps) {\n        return createWorkInProgress(current2, offscreenProps);\n      }\n      function updateSuspensePrimaryChildren(current2, workInProgress2, primaryChildren, renderLanes2) {\n        var currentPrimaryChildFragment = current2.child;\n        var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n        var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {\n          mode: \"visible\",\n          children: primaryChildren\n        });\n        if ((workInProgress2.mode & ConcurrentMode) === NoMode) {\n          primaryChildFragment.lanes = renderLanes2;\n        }\n        primaryChildFragment.return = workInProgress2;\n        primaryChildFragment.sibling = null;\n        if (currentFallbackChildFragment !== null) {\n          var deletions = workInProgress2.deletions;\n          if (deletions === null) {\n            workInProgress2.deletions = [currentFallbackChildFragment];\n            workInProgress2.flags |= ChildDeletion;\n          } else {\n            deletions.push(currentFallbackChildFragment);\n          }\n        }\n        workInProgress2.child = primaryChildFragment;\n        return primaryChildFragment;\n      }\n      function updateSuspenseFallbackChildren(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {\n        var mode = workInProgress2.mode;\n        var currentPrimaryChildFragment = current2.child;\n        var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n        var primaryChildProps = {\n          mode: \"hidden\",\n          children: primaryChildren\n        };\n        var primaryChildFragment;\n        if ((mode & ConcurrentMode) === NoMode && workInProgress2.child !== currentPrimaryChildFragment) {\n          var progressedPrimaryFragment = workInProgress2.child;\n          primaryChildFragment = progressedPrimaryFragment;\n          primaryChildFragment.childLanes = NoLanes;\n          primaryChildFragment.pendingProps = primaryChildProps;\n          if (workInProgress2.mode & ProfileMode) {\n            primaryChildFragment.actualDuration = 0;\n            primaryChildFragment.actualStartTime = -1;\n            primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;\n            primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;\n          }\n          workInProgress2.deletions = null;\n        } else {\n          primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);\n          primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;\n        }\n        var fallbackChildFragment;\n        if (currentFallbackChildFragment !== null) {\n          fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);\n        } else {\n          fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);\n          fallbackChildFragment.flags |= Placement;\n        }\n        fallbackChildFragment.return = workInProgress2;\n        primaryChildFragment.return = workInProgress2;\n        primaryChildFragment.sibling = fallbackChildFragment;\n        workInProgress2.child = primaryChildFragment;\n        return fallbackChildFragment;\n      }\n      function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, recoverableError) {\n        if (recoverableError !== null) {\n          queueHydrationError(recoverableError);\n        }\n        reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);\n        var nextProps = workInProgress2.pendingProps;\n        var primaryChildren = nextProps.children;\n        var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);\n        primaryChildFragment.flags |= Placement;\n        workInProgress2.memoizedState = null;\n        return primaryChildFragment;\n      }\n      function mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {\n        var fiberMode = workInProgress2.mode;\n        var primaryChildProps = {\n          mode: \"visible\",\n          children: primaryChildren\n        };\n        var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);\n        var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes2, null);\n        fallbackChildFragment.flags |= Placement;\n        primaryChildFragment.return = workInProgress2;\n        fallbackChildFragment.return = workInProgress2;\n        primaryChildFragment.sibling = fallbackChildFragment;\n        workInProgress2.child = primaryChildFragment;\n        if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {\n          reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);\n        }\n        return fallbackChildFragment;\n      }\n      function mountDehydratedSuspenseComponent(workInProgress2, suspenseInstance, renderLanes2) {\n        if ((workInProgress2.mode & ConcurrentMode) === NoMode) {\n          {\n            error(\"Cannot hydrate Suspense in legacy mode. Switch from \" + \"ReactDOM.hydrate(element, container) to \" + \"ReactDOMClient.hydrateRoot(container, <App />)\" + \".render(element) or remove the Suspense components from \" + \"the server rendered components.\");\n          }\n          workInProgress2.lanes = laneToLanes(SyncLane);\n        } else if (isSuspenseInstanceFallback(suspenseInstance)) {\n          workInProgress2.lanes = laneToLanes(DefaultHydrationLane);\n        } else {\n          workInProgress2.lanes = laneToLanes(OffscreenLane);\n        }\n        return null;\n      }\n      function updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, suspenseInstance, suspenseState, renderLanes2) {\n        if (!didSuspend) {\n          warnIfHydrating();\n          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {\n            return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, null);\n          }\n          if (isSuspenseInstanceFallback(suspenseInstance)) {\n            var digest, message, stack;\n            {\n              var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);\n              digest = _getSuspenseInstanceF.digest;\n              message = _getSuspenseInstanceF.message;\n              stack = _getSuspenseInstanceF.stack;\n            }\n            var error2;\n            if (message) {\n              error2 = new Error(message);\n            } else {\n              error2 = new Error(\"The server could not finish this Suspense boundary, likely \" + \"due to an error during server rendering. Switched to \" + \"client rendering.\");\n            }\n            var capturedValue = createCapturedValue(error2, digest, stack);\n            return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, capturedValue);\n          }\n          var hasContextChanged2 = includesSomeLane(renderLanes2, current2.childLanes);\n          if (didReceiveUpdate || hasContextChanged2) {\n            var root2 = getWorkInProgressRoot();\n            if (root2 !== null) {\n              var attemptHydrationAtLane = getBumpedLaneForHydration(root2, renderLanes2);\n              if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {\n                suspenseState.retryLane = attemptHydrationAtLane;\n                var eventTime = NoTimestamp;\n                enqueueConcurrentRenderForLane(current2, attemptHydrationAtLane);\n                scheduleUpdateOnFiber(root2, current2, attemptHydrationAtLane, eventTime);\n              }\n            }\n            renderDidSuspendDelayIfPossible();\n            var _capturedValue = createCapturedValue(new Error(\"This Suspense boundary received an update before it finished \" + \"hydrating. This caused the boundary to switch to client rendering. \" + \"The usual way to fix this is to wrap the original update \" + \"in startTransition.\"));\n            return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue);\n          } else if (isSuspenseInstancePending(suspenseInstance)) {\n            workInProgress2.flags |= DidCapture;\n            workInProgress2.child = current2.child;\n            var retry = retryDehydratedSuspenseBoundary.bind(null, current2);\n            registerSuspenseInstanceRetry(suspenseInstance, retry);\n            return null;\n          } else {\n            reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress2, suspenseInstance, suspenseState.treeContext);\n            var primaryChildren = nextProps.children;\n            var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);\n            primaryChildFragment.flags |= Hydrating;\n            return primaryChildFragment;\n          }\n        } else {\n          if (workInProgress2.flags & ForceClientRender) {\n            workInProgress2.flags &= ~ForceClientRender;\n            var _capturedValue2 = createCapturedValue(new Error(\"There was an error while hydrating this Suspense boundary. \" + \"Switched to client rendering.\"));\n            return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue2);\n          } else if (workInProgress2.memoizedState !== null) {\n            workInProgress2.child = current2.child;\n            workInProgress2.flags |= DidCapture;\n            return null;\n          } else {\n            var nextPrimaryChildren = nextProps.children;\n            var nextFallbackChildren = nextProps.fallback;\n            var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);\n            var _primaryChildFragment4 = workInProgress2.child;\n            _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes2);\n            workInProgress2.memoizedState = SUSPENDED_MARKER;\n            return fallbackChildFragment;\n          }\n        }\n      }\n      function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {\n        fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);\n        var alternate = fiber.alternate;\n        if (alternate !== null) {\n          alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);\n        }\n        scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);\n      }\n      function propagateSuspenseContextChange(workInProgress2, firstChild, renderLanes2) {\n        var node = firstChild;\n        while (node !== null) {\n          if (node.tag === SuspenseComponent) {\n            var state = node.memoizedState;\n            if (state !== null) {\n              scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);\n            }\n          } else if (node.tag === SuspenseListComponent) {\n            scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);\n          } else if (node.child !== null) {\n            node.child.return = node;\n            node = node.child;\n            continue;\n          }\n          if (node === workInProgress2) {\n            return;\n          }\n          while (node.sibling === null) {\n            if (node.return === null || node.return === workInProgress2) {\n              return;\n            }\n            node = node.return;\n          }\n          node.sibling.return = node.return;\n          node = node.sibling;\n        }\n      }\n      function findLastContentRow(firstChild) {\n        var row = firstChild;\n        var lastContentRow = null;\n        while (row !== null) {\n          var currentRow = row.alternate;\n          if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n            lastContentRow = row;\n          }\n          row = row.sibling;\n        }\n        return lastContentRow;\n      }\n      function validateRevealOrder(revealOrder) {\n        {\n          if (revealOrder !== undefined && revealOrder !== \"forwards\" && revealOrder !== \"backwards\" && revealOrder !== \"together\" && !didWarnAboutRevealOrder[revealOrder]) {\n            didWarnAboutRevealOrder[revealOrder] = true;\n            if (typeof revealOrder === \"string\") {\n              switch (revealOrder.toLowerCase()) {\n                case \"together\":\n                case \"forwards\":\n                case \"backwards\": {\n                  error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'Use lowercase \"%s\" instead.', revealOrder, revealOrder.toLowerCase());\n                  break;\n                }\n                case \"forward\":\n                case \"backward\": {\n                  error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'React uses the -s suffix in the spelling. Use \"%ss\" instead.', revealOrder, revealOrder.toLowerCase());\n                  break;\n                }\n                default:\n                  error('\"%s\" is not a supported revealOrder on <SuspenseList />. ' + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n                  break;\n              }\n            } else {\n              error(\"%s is not a supported value for revealOrder on <SuspenseList />. \" + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n            }\n          }\n        }\n      }\n      function validateTailOptions(tailMode, revealOrder) {\n        {\n          if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {\n            if (tailMode !== \"collapsed\" && tailMode !== \"hidden\") {\n              didWarnAboutTailOptions[tailMode] = true;\n              error('\"%s\" is not a supported value for tail on <SuspenseList />. ' + 'Did you mean \"collapsed\" or \"hidden\"?', tailMode);\n            } else if (revealOrder !== \"forwards\" && revealOrder !== \"backwards\") {\n              didWarnAboutTailOptions[tailMode] = true;\n              error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is ' + '\"forwards\" or \"backwards\". ' + 'Did you mean to specify revealOrder=\"forwards\"?', tailMode);\n            }\n          }\n        }\n      }\n      function validateSuspenseListNestedChild(childSlot, index2) {\n        {\n          var isAnArray = isArray(childSlot);\n          var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === \"function\";\n          if (isAnArray || isIterable) {\n            var type = isAnArray ? \"array\" : \"iterable\";\n            error(\"A nested %s was passed to row #%s in <SuspenseList />. Wrap it in \" + \"an additional SuspenseList to configure its revealOrder: \" + \"<SuspenseList revealOrder=...> ... \" + \"<SuspenseList revealOrder=...>{%s}</SuspenseList> ... \" + \"</SuspenseList>\", type, index2, type);\n            return false;\n          }\n        }\n        return true;\n      }\n      function validateSuspenseListChildren(children, revealOrder) {\n        {\n          if ((revealOrder === \"forwards\" || revealOrder === \"backwards\") && children !== undefined && children !== null && children !== false) {\n            if (isArray(children)) {\n              for (var i = 0;i < children.length; i++) {\n                if (!validateSuspenseListNestedChild(children[i], i)) {\n                  return;\n                }\n              }\n            } else {\n              var iteratorFn = getIteratorFn(children);\n              if (typeof iteratorFn === \"function\") {\n                var childrenIterator = iteratorFn.call(children);\n                if (childrenIterator) {\n                  var step = childrenIterator.next();\n                  var _i = 0;\n                  for (;!step.done; step = childrenIterator.next()) {\n                    if (!validateSuspenseListNestedChild(step.value, _i)) {\n                      return;\n                    }\n                    _i++;\n                  }\n                }\n              } else {\n                error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. ' + \"This is not useful since it needs multiple rows. \" + \"Did you mean to pass multiple children or an array?\", revealOrder);\n              }\n            }\n          }\n        }\n      }\n      function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {\n        var renderState = workInProgress2.memoizedState;\n        if (renderState === null) {\n          workInProgress2.memoizedState = {\n            isBackwards,\n            rendering: null,\n            renderingStartTime: 0,\n            last: lastContentRow,\n            tail,\n            tailMode\n          };\n        } else {\n          renderState.isBackwards = isBackwards;\n          renderState.rendering = null;\n          renderState.renderingStartTime = 0;\n          renderState.last = lastContentRow;\n          renderState.tail = tail;\n          renderState.tailMode = tailMode;\n        }\n      }\n      function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {\n        var nextProps = workInProgress2.pendingProps;\n        var revealOrder = nextProps.revealOrder;\n        var tailMode = nextProps.tail;\n        var newChildren = nextProps.children;\n        validateRevealOrder(revealOrder);\n        validateTailOptions(tailMode, revealOrder);\n        validateSuspenseListChildren(newChildren, revealOrder);\n        reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);\n        var suspenseContext = suspenseStackCursor.current;\n        var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);\n        if (shouldForceFallback) {\n          suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);\n          workInProgress2.flags |= DidCapture;\n        } else {\n          var didSuspendBefore = current2 !== null && (current2.flags & DidCapture) !== NoFlags;\n          if (didSuspendBefore) {\n            propagateSuspenseContextChange(workInProgress2, workInProgress2.child, renderLanes2);\n          }\n          suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n        }\n        pushSuspenseContext(workInProgress2, suspenseContext);\n        if ((workInProgress2.mode & ConcurrentMode) === NoMode) {\n          workInProgress2.memoizedState = null;\n        } else {\n          switch (revealOrder) {\n            case \"forwards\": {\n              var lastContentRow = findLastContentRow(workInProgress2.child);\n              var tail;\n              if (lastContentRow === null) {\n                tail = workInProgress2.child;\n                workInProgress2.child = null;\n              } else {\n                tail = lastContentRow.sibling;\n                lastContentRow.sibling = null;\n              }\n              initSuspenseListRenderState(workInProgress2, false, tail, lastContentRow, tailMode);\n              break;\n            }\n            case \"backwards\": {\n              var _tail = null;\n              var row = workInProgress2.child;\n              workInProgress2.child = null;\n              while (row !== null) {\n                var currentRow = row.alternate;\n                if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n                  workInProgress2.child = row;\n                  break;\n                }\n                var nextRow = row.sibling;\n                row.sibling = _tail;\n                _tail = row;\n                row = nextRow;\n              }\n              initSuspenseListRenderState(workInProgress2, true, _tail, null, tailMode);\n              break;\n            }\n            case \"together\": {\n              initSuspenseListRenderState(workInProgress2, false, null, null, undefined);\n              break;\n            }\n            default: {\n              workInProgress2.memoizedState = null;\n            }\n          }\n        }\n        return workInProgress2.child;\n      }\n      function updatePortalComponent(current2, workInProgress2, renderLanes2) {\n        pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);\n        var nextChildren = workInProgress2.pendingProps;\n        if (current2 === null) {\n          workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);\n        } else {\n          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n        }\n        return workInProgress2.child;\n      }\n      var hasWarnedAboutUsingNoValuePropOnContextProvider = false;\n      function updateContextProvider(current2, workInProgress2, renderLanes2) {\n        var providerType = workInProgress2.type;\n        var context = providerType._context;\n        var newProps = workInProgress2.pendingProps;\n        var oldProps = workInProgress2.memoizedProps;\n        var newValue = newProps.value;\n        {\n          if (!(\"value\" in newProps)) {\n            if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {\n              hasWarnedAboutUsingNoValuePropOnContextProvider = true;\n              error(\"The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?\");\n            }\n          }\n          var providerPropTypes = workInProgress2.type.propTypes;\n          if (providerPropTypes) {\n            checkPropTypes(providerPropTypes, newProps, \"prop\", \"Context.Provider\");\n          }\n        }\n        pushProvider(workInProgress2, context, newValue);\n        {\n          if (oldProps !== null) {\n            var oldValue = oldProps.value;\n            if (objectIs(oldValue, newValue)) {\n              if (oldProps.children === newProps.children && !hasContextChanged()) {\n                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);\n              }\n            } else {\n              propagateContextChange(workInProgress2, context, renderLanes2);\n            }\n          }\n        }\n        var newChildren = newProps.children;\n        reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);\n        return workInProgress2.child;\n      }\n      var hasWarnedAboutUsingContextAsConsumer = false;\n      function updateContextConsumer(current2, workInProgress2, renderLanes2) {\n        var context = workInProgress2.type;\n        {\n          if (context._context === undefined) {\n            if (context !== context.Consumer) {\n              if (!hasWarnedAboutUsingContextAsConsumer) {\n                hasWarnedAboutUsingContextAsConsumer = true;\n                error(\"Rendering <Context> directly is not supported and will be removed in \" + \"a future major release. Did you mean to render <Context.Consumer> instead?\");\n              }\n            }\n          } else {\n            context = context._context;\n          }\n        }\n        var newProps = workInProgress2.pendingProps;\n        var render2 = newProps.children;\n        {\n          if (typeof render2 !== \"function\") {\n            error(\"A context consumer was rendered with multiple children, or a child \" + \"that isn't a function. A context consumer expects a single child \" + \"that is a function. If you did pass a function, make sure there \" + \"is no trailing or leading whitespace around it.\");\n          }\n        }\n        prepareToReadContext(workInProgress2, renderLanes2);\n        var newValue = readContext(context);\n        {\n          markComponentRenderStarted(workInProgress2);\n        }\n        var newChildren;\n        {\n          ReactCurrentOwner$1.current = workInProgress2;\n          setIsRendering(true);\n          newChildren = render2(newValue);\n          setIsRendering(false);\n        }\n        {\n          markComponentRenderStopped();\n        }\n        workInProgress2.flags |= PerformedWork;\n        reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);\n        return workInProgress2.child;\n      }\n      function markWorkInProgressReceivedUpdate() {\n        didReceiveUpdate = true;\n      }\n      function resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2) {\n        if ((workInProgress2.mode & ConcurrentMode) === NoMode) {\n          if (current2 !== null) {\n            current2.alternate = null;\n            workInProgress2.alternate = null;\n            workInProgress2.flags |= Placement;\n          }\n        }\n      }\n      function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {\n        if (current2 !== null) {\n          workInProgress2.dependencies = current2.dependencies;\n        }\n        {\n          stopProfilerTimerIfRunning();\n        }\n        markSkippedUpdateLanes(workInProgress2.lanes);\n        if (!includesSomeLane(renderLanes2, workInProgress2.childLanes)) {\n          {\n            return null;\n          }\n        }\n        cloneChildFibers(current2, workInProgress2);\n        return workInProgress2.child;\n      }\n      function remountFiber(current2, oldWorkInProgress, newWorkInProgress) {\n        {\n          var returnFiber = oldWorkInProgress.return;\n          if (returnFiber === null) {\n            throw new Error(\"Cannot swap the root fiber.\");\n          }\n          current2.alternate = null;\n          oldWorkInProgress.alternate = null;\n          newWorkInProgress.index = oldWorkInProgress.index;\n          newWorkInProgress.sibling = oldWorkInProgress.sibling;\n          newWorkInProgress.return = oldWorkInProgress.return;\n          newWorkInProgress.ref = oldWorkInProgress.ref;\n          if (oldWorkInProgress === returnFiber.child) {\n            returnFiber.child = newWorkInProgress;\n          } else {\n            var prevSibling = returnFiber.child;\n            if (prevSibling === null) {\n              throw new Error(\"Expected parent to have a child.\");\n            }\n            while (prevSibling.sibling !== oldWorkInProgress) {\n              prevSibling = prevSibling.sibling;\n              if (prevSibling === null) {\n                throw new Error(\"Expected to find the previous sibling.\");\n              }\n            }\n            prevSibling.sibling = newWorkInProgress;\n          }\n          var deletions = returnFiber.deletions;\n          if (deletions === null) {\n            returnFiber.deletions = [current2];\n            returnFiber.flags |= ChildDeletion;\n          } else {\n            deletions.push(current2);\n          }\n          newWorkInProgress.flags |= Placement;\n          return newWorkInProgress;\n        }\n      }\n      function checkScheduledUpdateOrContext(current2, renderLanes2) {\n        var updateLanes = current2.lanes;\n        if (includesSomeLane(updateLanes, renderLanes2)) {\n          return true;\n        }\n        return false;\n      }\n      function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {\n        switch (workInProgress2.tag) {\n          case HostRoot:\n            pushHostRootContext(workInProgress2);\n            var root2 = workInProgress2.stateNode;\n            resetHydrationState();\n            break;\n          case HostComponent:\n            pushHostContext(workInProgress2);\n            break;\n          case ClassComponent: {\n            var Component = workInProgress2.type;\n            if (isContextProvider(Component)) {\n              pushContextProvider(workInProgress2);\n            }\n            break;\n          }\n          case HostPortal:\n            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);\n            break;\n          case ContextProvider: {\n            var newValue = workInProgress2.memoizedProps.value;\n            var context = workInProgress2.type._context;\n            pushProvider(workInProgress2, context, newValue);\n            break;\n          }\n          case Profiler:\n            {\n              var hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);\n              if (hasChildWork) {\n                workInProgress2.flags |= Update;\n              }\n              {\n                var stateNode = workInProgress2.stateNode;\n                stateNode.effectDuration = 0;\n                stateNode.passiveEffectDuration = 0;\n              }\n            }\n            break;\n          case SuspenseComponent: {\n            var state = workInProgress2.memoizedState;\n            if (state !== null) {\n              if (state.dehydrated !== null) {\n                pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));\n                workInProgress2.flags |= DidCapture;\n                return null;\n              }\n              var primaryChildFragment = workInProgress2.child;\n              var primaryChildLanes = primaryChildFragment.childLanes;\n              if (includesSomeLane(renderLanes2, primaryChildLanes)) {\n                return updateSuspenseComponent(current2, workInProgress2, renderLanes2);\n              } else {\n                pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));\n                var child = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);\n                if (child !== null) {\n                  return child.sibling;\n                } else {\n                  return null;\n                }\n              }\n            } else {\n              pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));\n            }\n            break;\n          }\n          case SuspenseListComponent: {\n            var didSuspendBefore = (current2.flags & DidCapture) !== NoFlags;\n            var _hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);\n            if (didSuspendBefore) {\n              if (_hasChildWork) {\n                return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);\n              }\n              workInProgress2.flags |= DidCapture;\n            }\n            var renderState = workInProgress2.memoizedState;\n            if (renderState !== null) {\n              renderState.rendering = null;\n              renderState.tail = null;\n              renderState.lastEffect = null;\n            }\n            pushSuspenseContext(workInProgress2, suspenseStackCursor.current);\n            if (_hasChildWork) {\n              break;\n            } else {\n              return null;\n            }\n          }\n          case OffscreenComponent:\n          case LegacyHiddenComponent: {\n            workInProgress2.lanes = NoLanes;\n            return updateOffscreenComponent(current2, workInProgress2, renderLanes2);\n          }\n        }\n        return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);\n      }\n      function beginWork(current2, workInProgress2, renderLanes2) {\n        {\n          if (workInProgress2._debugNeedsRemount && current2 !== null) {\n            return remountFiber(current2, workInProgress2, createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes));\n          }\n        }\n        if (current2 !== null) {\n          var oldProps = current2.memoizedProps;\n          var newProps = workInProgress2.pendingProps;\n          if (oldProps !== newProps || hasContextChanged() || workInProgress2.type !== current2.type) {\n            didReceiveUpdate = true;\n          } else {\n            var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);\n            if (!hasScheduledUpdateOrContext && (workInProgress2.flags & DidCapture) === NoFlags) {\n              didReceiveUpdate = false;\n              return attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2);\n            }\n            if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n              didReceiveUpdate = true;\n            } else {\n              didReceiveUpdate = false;\n            }\n          }\n        } else {\n          didReceiveUpdate = false;\n          if (getIsHydrating() && isForkedChild(workInProgress2)) {\n            var slotIndex = workInProgress2.index;\n            var numberOfForks = getForksAtLevel();\n            pushTreeId(workInProgress2, numberOfForks, slotIndex);\n          }\n        }\n        workInProgress2.lanes = NoLanes;\n        switch (workInProgress2.tag) {\n          case IndeterminateComponent: {\n            return mountIndeterminateComponent(current2, workInProgress2, workInProgress2.type, renderLanes2);\n          }\n          case LazyComponent: {\n            var elementType = workInProgress2.elementType;\n            return mountLazyComponent(current2, workInProgress2, elementType, renderLanes2);\n          }\n          case FunctionComponent: {\n            var Component = workInProgress2.type;\n            var unresolvedProps = workInProgress2.pendingProps;\n            var resolvedProps = workInProgress2.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);\n            return updateFunctionComponent(current2, workInProgress2, Component, resolvedProps, renderLanes2);\n          }\n          case ClassComponent: {\n            var _Component = workInProgress2.type;\n            var _unresolvedProps = workInProgress2.pendingProps;\n            var _resolvedProps = workInProgress2.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);\n            return updateClassComponent(current2, workInProgress2, _Component, _resolvedProps, renderLanes2);\n          }\n          case HostRoot:\n            return updateHostRoot(current2, workInProgress2, renderLanes2);\n          case HostComponent:\n            return updateHostComponent(current2, workInProgress2, renderLanes2);\n          case HostText:\n            return updateHostText(current2, workInProgress2);\n          case SuspenseComponent:\n            return updateSuspenseComponent(current2, workInProgress2, renderLanes2);\n          case HostPortal:\n            return updatePortalComponent(current2, workInProgress2, renderLanes2);\n          case ForwardRef: {\n            var type = workInProgress2.type;\n            var _unresolvedProps2 = workInProgress2.pendingProps;\n            var _resolvedProps2 = workInProgress2.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);\n            return updateForwardRef(current2, workInProgress2, type, _resolvedProps2, renderLanes2);\n          }\n          case Fragment:\n            return updateFragment(current2, workInProgress2, renderLanes2);\n          case Mode:\n            return updateMode(current2, workInProgress2, renderLanes2);\n          case Profiler:\n            return updateProfiler(current2, workInProgress2, renderLanes2);\n          case ContextProvider:\n            return updateContextProvider(current2, workInProgress2, renderLanes2);\n          case ContextConsumer:\n            return updateContextConsumer(current2, workInProgress2, renderLanes2);\n          case MemoComponent: {\n            var _type2 = workInProgress2.type;\n            var _unresolvedProps3 = workInProgress2.pendingProps;\n            var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);\n            {\n              if (workInProgress2.type !== workInProgress2.elementType) {\n                var outerPropTypes = _type2.propTypes;\n                if (outerPropTypes) {\n                  checkPropTypes(outerPropTypes, _resolvedProps3, \"prop\", getComponentNameFromType(_type2));\n                }\n              }\n            }\n            _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);\n            return updateMemoComponent(current2, workInProgress2, _type2, _resolvedProps3, renderLanes2);\n          }\n          case SimpleMemoComponent: {\n            return updateSimpleMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);\n          }\n          case IncompleteClassComponent: {\n            var _Component2 = workInProgress2.type;\n            var _unresolvedProps4 = workInProgress2.pendingProps;\n            var _resolvedProps4 = workInProgress2.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);\n            return mountIncompleteClassComponent(current2, workInProgress2, _Component2, _resolvedProps4, renderLanes2);\n          }\n          case SuspenseListComponent: {\n            return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);\n          }\n          case ScopeComponent: {\n            break;\n          }\n          case OffscreenComponent: {\n            return updateOffscreenComponent(current2, workInProgress2, renderLanes2);\n          }\n        }\n        throw new Error(\"Unknown unit of work tag (\" + workInProgress2.tag + \"). This error is likely caused by a bug in \" + \"React. Please file an issue.\");\n      }\n      function markUpdate(workInProgress2) {\n        workInProgress2.flags |= Update;\n      }\n      function markRef$1(workInProgress2) {\n        workInProgress2.flags |= Ref;\n        {\n          workInProgress2.flags |= RefStatic;\n        }\n      }\n      var appendAllChildren;\n      var updateHostContainer;\n      var updateHostComponent$1;\n      var updateHostText$1;\n      {\n        appendAllChildren = function(parent, workInProgress2, needsVisibilityToggle, isHidden) {\n          var node = workInProgress2.child;\n          while (node !== null) {\n            if (node.tag === HostComponent || node.tag === HostText) {\n              appendInitialChild(parent, node.stateNode);\n            } else if (node.tag === HostPortal)\n              ;\n            else if (node.child !== null) {\n              node.child.return = node;\n              node = node.child;\n              continue;\n            }\n            if (node === workInProgress2) {\n              return;\n            }\n            while (node.sibling === null) {\n              if (node.return === null || node.return === workInProgress2) {\n                return;\n              }\n              node = node.return;\n            }\n            node.sibling.return = node.return;\n            node = node.sibling;\n          }\n        };\n        updateHostContainer = function(current2, workInProgress2) {};\n        updateHostComponent$1 = function(current2, workInProgress2, type, newProps, rootContainerInstance) {\n          var oldProps = current2.memoizedProps;\n          if (oldProps === newProps) {\n            return;\n          }\n          var instance = workInProgress2.stateNode;\n          var currentHostContext = getHostContext();\n          var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n          workInProgress2.updateQueue = updatePayload;\n          if (updatePayload) {\n            markUpdate(workInProgress2);\n          }\n        };\n        updateHostText$1 = function(current2, workInProgress2, oldText, newText) {\n          if (oldText !== newText) {\n            markUpdate(workInProgress2);\n          }\n        };\n      }\n      function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\n        if (getIsHydrating()) {\n          return;\n        }\n        switch (renderState.tailMode) {\n          case \"hidden\": {\n            var tailNode = renderState.tail;\n            var lastTailNode = null;\n            while (tailNode !== null) {\n              if (tailNode.alternate !== null) {\n                lastTailNode = tailNode;\n              }\n              tailNode = tailNode.sibling;\n            }\n            if (lastTailNode === null) {\n              renderState.tail = null;\n            } else {\n              lastTailNode.sibling = null;\n            }\n            break;\n          }\n          case \"collapsed\": {\n            var _tailNode = renderState.tail;\n            var _lastTailNode = null;\n            while (_tailNode !== null) {\n              if (_tailNode.alternate !== null) {\n                _lastTailNode = _tailNode;\n              }\n              _tailNode = _tailNode.sibling;\n            }\n            if (_lastTailNode === null) {\n              if (!hasRenderedATailFallback && renderState.tail !== null) {\n                renderState.tail.sibling = null;\n              } else {\n                renderState.tail = null;\n              }\n            } else {\n              _lastTailNode.sibling = null;\n            }\n            break;\n          }\n        }\n      }\n      function bubbleProperties(completedWork) {\n        var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;\n        var newChildLanes = NoLanes;\n        var subtreeFlags = NoFlags;\n        if (!didBailout) {\n          if ((completedWork.mode & ProfileMode) !== NoMode) {\n            var actualDuration = completedWork.actualDuration;\n            var treeBaseDuration = completedWork.selfBaseDuration;\n            var child = completedWork.child;\n            while (child !== null) {\n              newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));\n              subtreeFlags |= child.subtreeFlags;\n              subtreeFlags |= child.flags;\n              actualDuration += child.actualDuration;\n              treeBaseDuration += child.treeBaseDuration;\n              child = child.sibling;\n            }\n            completedWork.actualDuration = actualDuration;\n            completedWork.treeBaseDuration = treeBaseDuration;\n          } else {\n            var _child = completedWork.child;\n            while (_child !== null) {\n              newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));\n              subtreeFlags |= _child.subtreeFlags;\n              subtreeFlags |= _child.flags;\n              _child.return = completedWork;\n              _child = _child.sibling;\n            }\n          }\n          completedWork.subtreeFlags |= subtreeFlags;\n        } else {\n          if ((completedWork.mode & ProfileMode) !== NoMode) {\n            var _treeBaseDuration = completedWork.selfBaseDuration;\n            var _child2 = completedWork.child;\n            while (_child2 !== null) {\n              newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes));\n              subtreeFlags |= _child2.subtreeFlags & StaticMask;\n              subtreeFlags |= _child2.flags & StaticMask;\n              _treeBaseDuration += _child2.treeBaseDuration;\n              _child2 = _child2.sibling;\n            }\n            completedWork.treeBaseDuration = _treeBaseDuration;\n          } else {\n            var _child3 = completedWork.child;\n            while (_child3 !== null) {\n              newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes));\n              subtreeFlags |= _child3.subtreeFlags & StaticMask;\n              subtreeFlags |= _child3.flags & StaticMask;\n              _child3.return = completedWork;\n              _child3 = _child3.sibling;\n            }\n          }\n          completedWork.subtreeFlags |= subtreeFlags;\n        }\n        completedWork.childLanes = newChildLanes;\n        return didBailout;\n      }\n      function completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState) {\n        if (hasUnhydratedTailNodes() && (workInProgress2.mode & ConcurrentMode) !== NoMode && (workInProgress2.flags & DidCapture) === NoFlags) {\n          warnIfUnhydratedTailNodes(workInProgress2);\n          resetHydrationState();\n          workInProgress2.flags |= ForceClientRender | Incomplete | ShouldCapture;\n          return false;\n        }\n        var wasHydrated = popHydrationState(workInProgress2);\n        if (nextState !== null && nextState.dehydrated !== null) {\n          if (current2 === null) {\n            if (!wasHydrated) {\n              throw new Error(\"A dehydrated suspense component was completed without a hydrated node. \" + \"This is probably a bug in React.\");\n            }\n            prepareToHydrateHostSuspenseInstance(workInProgress2);\n            bubbleProperties(workInProgress2);\n            {\n              if ((workInProgress2.mode & ProfileMode) !== NoMode) {\n                var isTimedOutSuspense = nextState !== null;\n                if (isTimedOutSuspense) {\n                  var primaryChildFragment = workInProgress2.child;\n                  if (primaryChildFragment !== null) {\n                    workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n                  }\n                }\n              }\n            }\n            return false;\n          } else {\n            resetHydrationState();\n            if ((workInProgress2.flags & DidCapture) === NoFlags) {\n              workInProgress2.memoizedState = null;\n            }\n            workInProgress2.flags |= Update;\n            bubbleProperties(workInProgress2);\n            {\n              if ((workInProgress2.mode & ProfileMode) !== NoMode) {\n                var _isTimedOutSuspense = nextState !== null;\n                if (_isTimedOutSuspense) {\n                  var _primaryChildFragment = workInProgress2.child;\n                  if (_primaryChildFragment !== null) {\n                    workInProgress2.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;\n                  }\n                }\n              }\n            }\n            return false;\n          }\n        } else {\n          upgradeHydrationErrorsToRecoverable();\n          return true;\n        }\n      }\n      function completeWork(current2, workInProgress2, renderLanes2) {\n        var newProps = workInProgress2.pendingProps;\n        popTreeContext(workInProgress2);\n        switch (workInProgress2.tag) {\n          case IndeterminateComponent:\n          case LazyComponent:\n          case SimpleMemoComponent:\n          case FunctionComponent:\n          case ForwardRef:\n          case Fragment:\n          case Mode:\n          case Profiler:\n          case ContextConsumer:\n          case MemoComponent:\n            bubbleProperties(workInProgress2);\n            return null;\n          case ClassComponent: {\n            var Component = workInProgress2.type;\n            if (isContextProvider(Component)) {\n              popContext(workInProgress2);\n            }\n            bubbleProperties(workInProgress2);\n            return null;\n          }\n          case HostRoot: {\n            var fiberRoot = workInProgress2.stateNode;\n            popHostContainer(workInProgress2);\n            popTopLevelContextObject(workInProgress2);\n            resetWorkInProgressVersions();\n            if (fiberRoot.pendingContext) {\n              fiberRoot.context = fiberRoot.pendingContext;\n              fiberRoot.pendingContext = null;\n            }\n            if (current2 === null || current2.child === null) {\n              var wasHydrated = popHydrationState(workInProgress2);\n              if (wasHydrated) {\n                markUpdate(workInProgress2);\n              } else {\n                if (current2 !== null) {\n                  var prevState = current2.memoizedState;\n                  if (!prevState.isDehydrated || (workInProgress2.flags & ForceClientRender) !== NoFlags) {\n                    workInProgress2.flags |= Snapshot;\n                    upgradeHydrationErrorsToRecoverable();\n                  }\n                }\n              }\n            }\n            updateHostContainer(current2, workInProgress2);\n            bubbleProperties(workInProgress2);\n            return null;\n          }\n          case HostComponent: {\n            popHostContext(workInProgress2);\n            var rootContainerInstance = getRootHostContainer();\n            var type = workInProgress2.type;\n            if (current2 !== null && workInProgress2.stateNode != null) {\n              updateHostComponent$1(current2, workInProgress2, type, newProps, rootContainerInstance);\n              if (current2.ref !== workInProgress2.ref) {\n                markRef$1(workInProgress2);\n              }\n            } else {\n              if (!newProps) {\n                if (workInProgress2.stateNode === null) {\n                  throw new Error(\"We must have new props for new mounts. This error is likely \" + \"caused by a bug in React. Please file an issue.\");\n                }\n                bubbleProperties(workInProgress2);\n                return null;\n              }\n              var currentHostContext = getHostContext();\n              var _wasHydrated = popHydrationState(workInProgress2);\n              if (_wasHydrated) {\n                if (prepareToHydrateHostInstance(workInProgress2, rootContainerInstance, currentHostContext)) {\n                  markUpdate(workInProgress2);\n                }\n              } else {\n                var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress2);\n                appendAllChildren(instance, workInProgress2, false, false);\n                workInProgress2.stateNode = instance;\n                if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) {\n                  markUpdate(workInProgress2);\n                }\n              }\n              if (workInProgress2.ref !== null) {\n                markRef$1(workInProgress2);\n              }\n            }\n            bubbleProperties(workInProgress2);\n            return null;\n          }\n          case HostText: {\n            var newText = newProps;\n            if (current2 && workInProgress2.stateNode != null) {\n              var oldText = current2.memoizedProps;\n              updateHostText$1(current2, workInProgress2, oldText, newText);\n            } else {\n              if (typeof newText !== \"string\") {\n                if (workInProgress2.stateNode === null) {\n                  throw new Error(\"We must have new props for new mounts. This error is likely \" + \"caused by a bug in React. Please file an issue.\");\n                }\n              }\n              var _rootContainerInstance = getRootHostContainer();\n              var _currentHostContext = getHostContext();\n              var _wasHydrated2 = popHydrationState(workInProgress2);\n              if (_wasHydrated2) {\n                if (prepareToHydrateHostTextInstance(workInProgress2)) {\n                  markUpdate(workInProgress2);\n                }\n              } else {\n                workInProgress2.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress2);\n              }\n            }\n            bubbleProperties(workInProgress2);\n            return null;\n          }\n          case SuspenseComponent: {\n            popSuspenseContext(workInProgress2);\n            var nextState = workInProgress2.memoizedState;\n            if (current2 === null || current2.memoizedState !== null && current2.memoizedState.dehydrated !== null) {\n              var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState);\n              if (!fallthroughToNormalSuspensePath) {\n                if (workInProgress2.flags & ShouldCapture) {\n                  return workInProgress2;\n                } else {\n                  return null;\n                }\n              }\n            }\n            if ((workInProgress2.flags & DidCapture) !== NoFlags) {\n              workInProgress2.lanes = renderLanes2;\n              if ((workInProgress2.mode & ProfileMode) !== NoMode) {\n                transferActualDuration(workInProgress2);\n              }\n              return workInProgress2;\n            }\n            var nextDidTimeout = nextState !== null;\n            var prevDidTimeout = current2 !== null && current2.memoizedState !== null;\n            if (nextDidTimeout !== prevDidTimeout) {\n              if (nextDidTimeout) {\n                var _offscreenFiber2 = workInProgress2.child;\n                _offscreenFiber2.flags |= Visibility;\n                if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {\n                  var hasInvisibleChildContext = current2 === null && (workInProgress2.memoizedProps.unstable_avoidThisFallback !== true || !enableSuspenseAvoidThisFallback);\n                  if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {\n                    renderDidSuspend();\n                  } else {\n                    renderDidSuspendDelayIfPossible();\n                  }\n                }\n              }\n            }\n            var wakeables = workInProgress2.updateQueue;\n            if (wakeables !== null) {\n              workInProgress2.flags |= Update;\n            }\n            bubbleProperties(workInProgress2);\n            {\n              if ((workInProgress2.mode & ProfileMode) !== NoMode) {\n                if (nextDidTimeout) {\n                  var primaryChildFragment = workInProgress2.child;\n                  if (primaryChildFragment !== null) {\n                    workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n                  }\n                }\n              }\n            }\n            return null;\n          }\n          case HostPortal:\n            popHostContainer(workInProgress2);\n            updateHostContainer(current2, workInProgress2);\n            if (current2 === null) {\n              preparePortalMount(workInProgress2.stateNode.containerInfo);\n            }\n            bubbleProperties(workInProgress2);\n            return null;\n          case ContextProvider:\n            var context = workInProgress2.type._context;\n            popProvider(context, workInProgress2);\n            bubbleProperties(workInProgress2);\n            return null;\n          case IncompleteClassComponent: {\n            var _Component = workInProgress2.type;\n            if (isContextProvider(_Component)) {\n              popContext(workInProgress2);\n            }\n            bubbleProperties(workInProgress2);\n            return null;\n          }\n          case SuspenseListComponent: {\n            popSuspenseContext(workInProgress2);\n            var renderState = workInProgress2.memoizedState;\n            if (renderState === null) {\n              bubbleProperties(workInProgress2);\n              return null;\n            }\n            var didSuspendAlready = (workInProgress2.flags & DidCapture) !== NoFlags;\n            var renderedTail = renderState.rendering;\n            if (renderedTail === null) {\n              if (!didSuspendAlready) {\n                var cannotBeSuspended = renderHasNotSuspendedYet() && (current2 === null || (current2.flags & DidCapture) === NoFlags);\n                if (!cannotBeSuspended) {\n                  var row = workInProgress2.child;\n                  while (row !== null) {\n                    var suspended = findFirstSuspended(row);\n                    if (suspended !== null) {\n                      didSuspendAlready = true;\n                      workInProgress2.flags |= DidCapture;\n                      cutOffTailIfNeeded(renderState, false);\n                      var newThenables = suspended.updateQueue;\n                      if (newThenables !== null) {\n                        workInProgress2.updateQueue = newThenables;\n                        workInProgress2.flags |= Update;\n                      }\n                      workInProgress2.subtreeFlags = NoFlags;\n                      resetChildFibers(workInProgress2, renderLanes2);\n                      pushSuspenseContext(workInProgress2, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));\n                      return workInProgress2.child;\n                    }\n                    row = row.sibling;\n                  }\n                }\n                if (renderState.tail !== null && now() > getRenderTargetTime()) {\n                  workInProgress2.flags |= DidCapture;\n                  didSuspendAlready = true;\n                  cutOffTailIfNeeded(renderState, false);\n                  workInProgress2.lanes = SomeRetryLane;\n                }\n              } else {\n                cutOffTailIfNeeded(renderState, false);\n              }\n            } else {\n              if (!didSuspendAlready) {\n                var _suspended = findFirstSuspended(renderedTail);\n                if (_suspended !== null) {\n                  workInProgress2.flags |= DidCapture;\n                  didSuspendAlready = true;\n                  var _newThenables = _suspended.updateQueue;\n                  if (_newThenables !== null) {\n                    workInProgress2.updateQueue = _newThenables;\n                    workInProgress2.flags |= Update;\n                  }\n                  cutOffTailIfNeeded(renderState, true);\n                  if (renderState.tail === null && renderState.tailMode === \"hidden\" && !renderedTail.alternate && !getIsHydrating()) {\n                    bubbleProperties(workInProgress2);\n                    return null;\n                  }\n                } else if (now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes2 !== OffscreenLane) {\n                  workInProgress2.flags |= DidCapture;\n                  didSuspendAlready = true;\n                  cutOffTailIfNeeded(renderState, false);\n                  workInProgress2.lanes = SomeRetryLane;\n                }\n              }\n              if (renderState.isBackwards) {\n                renderedTail.sibling = workInProgress2.child;\n                workInProgress2.child = renderedTail;\n              } else {\n                var previousSibling = renderState.last;\n                if (previousSibling !== null) {\n                  previousSibling.sibling = renderedTail;\n                } else {\n                  workInProgress2.child = renderedTail;\n                }\n                renderState.last = renderedTail;\n              }\n            }\n            if (renderState.tail !== null) {\n              var next = renderState.tail;\n              renderState.rendering = next;\n              renderState.tail = next.sibling;\n              renderState.renderingStartTime = now();\n              next.sibling = null;\n              var suspenseContext = suspenseStackCursor.current;\n              if (didSuspendAlready) {\n                suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);\n              } else {\n                suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n              }\n              pushSuspenseContext(workInProgress2, suspenseContext);\n              return next;\n            }\n            bubbleProperties(workInProgress2);\n            return null;\n          }\n          case ScopeComponent: {\n            break;\n          }\n          case OffscreenComponent:\n          case LegacyHiddenComponent: {\n            popRenderLanes(workInProgress2);\n            var _nextState = workInProgress2.memoizedState;\n            var nextIsHidden = _nextState !== null;\n            if (current2 !== null) {\n              var _prevState = current2.memoizedState;\n              var prevIsHidden = _prevState !== null;\n              if (prevIsHidden !== nextIsHidden && !enableLegacyHidden) {\n                workInProgress2.flags |= Visibility;\n              }\n            }\n            if (!nextIsHidden || (workInProgress2.mode & ConcurrentMode) === NoMode) {\n              bubbleProperties(workInProgress2);\n            } else {\n              if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {\n                bubbleProperties(workInProgress2);\n                {\n                  if (workInProgress2.subtreeFlags & (Placement | Update)) {\n                    workInProgress2.flags |= Visibility;\n                  }\n                }\n              }\n            }\n            return null;\n          }\n          case CacheComponent: {\n            return null;\n          }\n          case TracingMarkerComponent: {\n            return null;\n          }\n        }\n        throw new Error(\"Unknown unit of work tag (\" + workInProgress2.tag + \"). This error is likely caused by a bug in \" + \"React. Please file an issue.\");\n      }\n      function unwindWork(current2, workInProgress2, renderLanes2) {\n        popTreeContext(workInProgress2);\n        switch (workInProgress2.tag) {\n          case ClassComponent: {\n            var Component = workInProgress2.type;\n            if (isContextProvider(Component)) {\n              popContext(workInProgress2);\n            }\n            var flags = workInProgress2.flags;\n            if (flags & ShouldCapture) {\n              workInProgress2.flags = flags & ~ShouldCapture | DidCapture;\n              if ((workInProgress2.mode & ProfileMode) !== NoMode) {\n                transferActualDuration(workInProgress2);\n              }\n              return workInProgress2;\n            }\n            return null;\n          }\n          case HostRoot: {\n            var root2 = workInProgress2.stateNode;\n            popHostContainer(workInProgress2);\n            popTopLevelContextObject(workInProgress2);\n            resetWorkInProgressVersions();\n            var _flags = workInProgress2.flags;\n            if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {\n              workInProgress2.flags = _flags & ~ShouldCapture | DidCapture;\n              return workInProgress2;\n            }\n            return null;\n          }\n          case HostComponent: {\n            popHostContext(workInProgress2);\n            return null;\n          }\n          case SuspenseComponent: {\n            popSuspenseContext(workInProgress2);\n            var suspenseState = workInProgress2.memoizedState;\n            if (suspenseState !== null && suspenseState.dehydrated !== null) {\n              if (workInProgress2.alternate === null) {\n                throw new Error(\"Threw in newly mounted dehydrated component. This is likely a bug in \" + \"React. Please file an issue.\");\n              }\n              resetHydrationState();\n            }\n            var _flags2 = workInProgress2.flags;\n            if (_flags2 & ShouldCapture) {\n              workInProgress2.flags = _flags2 & ~ShouldCapture | DidCapture;\n              if ((workInProgress2.mode & ProfileMode) !== NoMode) {\n                transferActualDuration(workInProgress2);\n              }\n              return workInProgress2;\n            }\n            return null;\n          }\n          case SuspenseListComponent: {\n            popSuspenseContext(workInProgress2);\n            return null;\n          }\n          case HostPortal:\n            popHostContainer(workInProgress2);\n            return null;\n          case ContextProvider:\n            var context = workInProgress2.type._context;\n            popProvider(context, workInProgress2);\n            return null;\n          case OffscreenComponent:\n          case LegacyHiddenComponent:\n            popRenderLanes(workInProgress2);\n            return null;\n          case CacheComponent:\n            return null;\n          default:\n            return null;\n        }\n      }\n      function unwindInterruptedWork(current2, interruptedWork, renderLanes2) {\n        popTreeContext(interruptedWork);\n        switch (interruptedWork.tag) {\n          case ClassComponent: {\n            var childContextTypes = interruptedWork.type.childContextTypes;\n            if (childContextTypes !== null && childContextTypes !== undefined) {\n              popContext(interruptedWork);\n            }\n            break;\n          }\n          case HostRoot: {\n            var root2 = interruptedWork.stateNode;\n            popHostContainer(interruptedWork);\n            popTopLevelContextObject(interruptedWork);\n            resetWorkInProgressVersions();\n            break;\n          }\n          case HostComponent: {\n            popHostContext(interruptedWork);\n            break;\n          }\n          case HostPortal:\n            popHostContainer(interruptedWork);\n            break;\n          case SuspenseComponent:\n            popSuspenseContext(interruptedWork);\n            break;\n          case SuspenseListComponent:\n            popSuspenseContext(interruptedWork);\n            break;\n          case ContextProvider:\n            var context = interruptedWork.type._context;\n            popProvider(context, interruptedWork);\n            break;\n          case OffscreenComponent:\n          case LegacyHiddenComponent:\n            popRenderLanes(interruptedWork);\n            break;\n        }\n      }\n      var didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n      {\n        didWarnAboutUndefinedSnapshotBeforeUpdate = new Set;\n      }\n      var offscreenSubtreeIsHidden = false;\n      var offscreenSubtreeWasHidden = false;\n      var PossiblyWeakSet = typeof WeakSet === \"function\" ? WeakSet : Set;\n      var nextEffect = null;\n      var inProgressLanes = null;\n      var inProgressRoot = null;\n      function reportUncaughtErrorInDEV(error2) {\n        {\n          invokeGuardedCallback(null, function() {\n            throw error2;\n          });\n          clearCaughtError();\n        }\n      }\n      var callComponentWillUnmountWithTimer = function(current2, instance) {\n        instance.props = current2.memoizedProps;\n        instance.state = current2.memoizedState;\n        if (current2.mode & ProfileMode) {\n          try {\n            startLayoutEffectTimer();\n            instance.componentWillUnmount();\n          } finally {\n            recordLayoutEffectDuration(current2);\n          }\n        } else {\n          instance.componentWillUnmount();\n        }\n      };\n      function safelyCallCommitHookLayoutEffectListMount(current2, nearestMountedAncestor) {\n        try {\n          commitHookEffectListMount(Layout, current2);\n        } catch (error2) {\n          captureCommitPhaseError(current2, nearestMountedAncestor, error2);\n        }\n      }\n      function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {\n        try {\n          callComponentWillUnmountWithTimer(current2, instance);\n        } catch (error2) {\n          captureCommitPhaseError(current2, nearestMountedAncestor, error2);\n        }\n      }\n      function safelyCallComponentDidMount(current2, nearestMountedAncestor, instance) {\n        try {\n          instance.componentDidMount();\n        } catch (error2) {\n          captureCommitPhaseError(current2, nearestMountedAncestor, error2);\n        }\n      }\n      function safelyAttachRef(current2, nearestMountedAncestor) {\n        try {\n          commitAttachRef(current2);\n        } catch (error2) {\n          captureCommitPhaseError(current2, nearestMountedAncestor, error2);\n        }\n      }\n      function safelyDetachRef(current2, nearestMountedAncestor) {\n        var ref = current2.ref;\n        if (ref !== null) {\n          if (typeof ref === \"function\") {\n            var retVal;\n            try {\n              if (enableProfilerTimer && enableProfilerCommitHooks && current2.mode & ProfileMode) {\n                try {\n                  startLayoutEffectTimer();\n                  retVal = ref(null);\n                } finally {\n                  recordLayoutEffectDuration(current2);\n                }\n              } else {\n                retVal = ref(null);\n              }\n            } catch (error2) {\n              captureCommitPhaseError(current2, nearestMountedAncestor, error2);\n            }\n            {\n              if (typeof retVal === \"function\") {\n                error(\"Unexpected return value from a callback ref in %s. \" + \"A callback ref should not return a function.\", getComponentNameFromFiber(current2));\n              }\n            }\n          } else {\n            ref.current = null;\n          }\n        }\n      }\n      function safelyCallDestroy(current2, nearestMountedAncestor, destroy) {\n        try {\n          destroy();\n        } catch (error2) {\n          captureCommitPhaseError(current2, nearestMountedAncestor, error2);\n        }\n      }\n      var focusedInstanceHandle = null;\n      var shouldFireAfterActiveInstanceBlur = false;\n      function commitBeforeMutationEffects(root2, firstChild) {\n        focusedInstanceHandle = prepareForCommit(root2.containerInfo);\n        nextEffect = firstChild;\n        commitBeforeMutationEffects_begin();\n        var shouldFire = shouldFireAfterActiveInstanceBlur;\n        shouldFireAfterActiveInstanceBlur = false;\n        focusedInstanceHandle = null;\n        return shouldFire;\n      }\n      function commitBeforeMutationEffects_begin() {\n        while (nextEffect !== null) {\n          var fiber = nextEffect;\n          var child = fiber.child;\n          if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {\n            child.return = fiber;\n            nextEffect = child;\n          } else {\n            commitBeforeMutationEffects_complete();\n          }\n        }\n      }\n      function commitBeforeMutationEffects_complete() {\n        while (nextEffect !== null) {\n          var fiber = nextEffect;\n          setCurrentFiber(fiber);\n          try {\n            commitBeforeMutationEffectsOnFiber(fiber);\n          } catch (error2) {\n            captureCommitPhaseError(fiber, fiber.return, error2);\n          }\n          resetCurrentFiber();\n          var sibling = fiber.sibling;\n          if (sibling !== null) {\n            sibling.return = fiber.return;\n            nextEffect = sibling;\n            return;\n          }\n          nextEffect = fiber.return;\n        }\n      }\n      function commitBeforeMutationEffectsOnFiber(finishedWork) {\n        var current2 = finishedWork.alternate;\n        var flags = finishedWork.flags;\n        if ((flags & Snapshot) !== NoFlags) {\n          setCurrentFiber(finishedWork);\n          switch (finishedWork.tag) {\n            case FunctionComponent:\n            case ForwardRef:\n            case SimpleMemoComponent: {\n              break;\n            }\n            case ClassComponent: {\n              if (current2 !== null) {\n                var prevProps = current2.memoizedProps;\n                var prevState = current2.memoizedState;\n                var instance = finishedWork.stateNode;\n                {\n                  if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                    if (instance.props !== finishedWork.memoizedProps) {\n                      error(\"Expected %s props to match memoized props before \" + \"getSnapshotBeforeUpdate. \" + \"This might either be because of a bug in React, or because \" + \"a component reassigns its own `this.props`. \" + \"Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                    }\n                    if (instance.state !== finishedWork.memoizedState) {\n                      error(\"Expected %s state to match memoized state before \" + \"getSnapshotBeforeUpdate. \" + \"This might either be because of a bug in React, or because \" + \"a component reassigns its own `this.state`. \" + \"Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                    }\n                  }\n                }\n                var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);\n                {\n                  var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;\n                  if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\n                    didWarnSet.add(finishedWork.type);\n                    error(\"%s.getSnapshotBeforeUpdate(): A snapshot value (or null) \" + \"must be returned. You have returned undefined.\", getComponentNameFromFiber(finishedWork));\n                  }\n                }\n                instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n              }\n              break;\n            }\n            case HostRoot: {\n              {\n                var root2 = finishedWork.stateNode;\n                clearContainer(root2.containerInfo);\n              }\n              break;\n            }\n            case HostComponent:\n            case HostText:\n            case HostPortal:\n            case IncompleteClassComponent:\n              break;\n            default: {\n              throw new Error(\"This unit of work tag should not have side-effects. This error is \" + \"likely caused by a bug in React. Please file an issue.\");\n            }\n          }\n          resetCurrentFiber();\n        }\n      }\n      function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {\n        var updateQueue = finishedWork.updateQueue;\n        var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n        if (lastEffect !== null) {\n          var firstEffect = lastEffect.next;\n          var effect = firstEffect;\n          do {\n            if ((effect.tag & flags) === flags) {\n              var destroy = effect.destroy;\n              effect.destroy = undefined;\n              if (destroy !== undefined) {\n                {\n                  if ((flags & Passive$1) !== NoFlags$1) {\n                    markComponentPassiveEffectUnmountStarted(finishedWork);\n                  } else if ((flags & Layout) !== NoFlags$1) {\n                    markComponentLayoutEffectUnmountStarted(finishedWork);\n                  }\n                }\n                {\n                  if ((flags & Insertion) !== NoFlags$1) {\n                    setIsRunningInsertionEffect(true);\n                  }\n                }\n                safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);\n                {\n                  if ((flags & Insertion) !== NoFlags$1) {\n                    setIsRunningInsertionEffect(false);\n                  }\n                }\n                {\n                  if ((flags & Passive$1) !== NoFlags$1) {\n                    markComponentPassiveEffectUnmountStopped();\n                  } else if ((flags & Layout) !== NoFlags$1) {\n                    markComponentLayoutEffectUnmountStopped();\n                  }\n                }\n              }\n            }\n            effect = effect.next;\n          } while (effect !== firstEffect);\n        }\n      }\n      function commitHookEffectListMount(flags, finishedWork) {\n        var updateQueue = finishedWork.updateQueue;\n        var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n        if (lastEffect !== null) {\n          var firstEffect = lastEffect.next;\n          var effect = firstEffect;\n          do {\n            if ((effect.tag & flags) === flags) {\n              {\n                if ((flags & Passive$1) !== NoFlags$1) {\n                  markComponentPassiveEffectMountStarted(finishedWork);\n                } else if ((flags & Layout) !== NoFlags$1) {\n                  markComponentLayoutEffectMountStarted(finishedWork);\n                }\n              }\n              var create = effect.create;\n              {\n                if ((flags & Insertion) !== NoFlags$1) {\n                  setIsRunningInsertionEffect(true);\n                }\n              }\n              effect.destroy = create();\n              {\n                if ((flags & Insertion) !== NoFlags$1) {\n                  setIsRunningInsertionEffect(false);\n                }\n              }\n              {\n                if ((flags & Passive$1) !== NoFlags$1) {\n                  markComponentPassiveEffectMountStopped();\n                } else if ((flags & Layout) !== NoFlags$1) {\n                  markComponentLayoutEffectMountStopped();\n                }\n              }\n              {\n                var destroy = effect.destroy;\n                if (destroy !== undefined && typeof destroy !== \"function\") {\n                  var hookName = undefined;\n                  if ((effect.tag & Layout) !== NoFlags) {\n                    hookName = \"useLayoutEffect\";\n                  } else if ((effect.tag & Insertion) !== NoFlags) {\n                    hookName = \"useInsertionEffect\";\n                  } else {\n                    hookName = \"useEffect\";\n                  }\n                  var addendum = undefined;\n                  if (destroy === null) {\n                    addendum = \" You returned null. If your effect does not require clean \" + \"up, return undefined (or nothing).\";\n                  } else if (typeof destroy.then === \"function\") {\n                    addendum = `\n\nIt looks like you wrote ` + hookName + \"(async () => ...) or returned a Promise. \" + \"Instead, write the async function inside your effect \" + `and call it immediately:\n\n` + hookName + `(() => {\n` + `  async function fetchData() {\n` + `    // You can await here\n` + `    const response = await MyAPI.getData(someId);\n` + `    // ...\n` + `  }\n` + `  fetchData();\n` + `}, [someId]); // Or [] if effect doesn't need props or state\n\n` + \"Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching\";\n                  } else {\n                    addendum = \" You returned: \" + destroy;\n                  }\n                  error(\"%s must not return anything besides a function, \" + \"which is used for clean-up.%s\", hookName, addendum);\n                }\n              }\n            }\n            effect = effect.next;\n          } while (effect !== firstEffect);\n        }\n      }\n      function commitPassiveEffectDurations(finishedRoot, finishedWork) {\n        {\n          if ((finishedWork.flags & Update) !== NoFlags) {\n            switch (finishedWork.tag) {\n              case Profiler: {\n                var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;\n                var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit;\n                var commitTime2 = getCommitTime();\n                var phase = finishedWork.alternate === null ? \"mount\" : \"update\";\n                {\n                  if (isCurrentUpdateNested()) {\n                    phase = \"nested-update\";\n                  }\n                }\n                if (typeof onPostCommit === \"function\") {\n                  onPostCommit(id, phase, passiveEffectDuration, commitTime2);\n                }\n                var parentFiber = finishedWork.return;\n                outer:\n                  while (parentFiber !== null) {\n                    switch (parentFiber.tag) {\n                      case HostRoot:\n                        var root2 = parentFiber.stateNode;\n                        root2.passiveEffectDuration += passiveEffectDuration;\n                        break outer;\n                      case Profiler:\n                        var parentStateNode = parentFiber.stateNode;\n                        parentStateNode.passiveEffectDuration += passiveEffectDuration;\n                        break outer;\n                    }\n                    parentFiber = parentFiber.return;\n                  }\n                break;\n              }\n            }\n          }\n        }\n      }\n      function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork, committedLanes) {\n        if ((finishedWork.flags & LayoutMask) !== NoFlags) {\n          switch (finishedWork.tag) {\n            case FunctionComponent:\n            case ForwardRef:\n            case SimpleMemoComponent: {\n              if (!offscreenSubtreeWasHidden) {\n                if (finishedWork.mode & ProfileMode) {\n                  try {\n                    startLayoutEffectTimer();\n                    commitHookEffectListMount(Layout | HasEffect, finishedWork);\n                  } finally {\n                    recordLayoutEffectDuration(finishedWork);\n                  }\n                } else {\n                  commitHookEffectListMount(Layout | HasEffect, finishedWork);\n                }\n              }\n              break;\n            }\n            case ClassComponent: {\n              var instance = finishedWork.stateNode;\n              if (finishedWork.flags & Update) {\n                if (!offscreenSubtreeWasHidden) {\n                  if (current2 === null) {\n                    {\n                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                        if (instance.props !== finishedWork.memoizedProps) {\n                          error(\"Expected %s props to match memoized props before \" + \"componentDidMount. \" + \"This might either be because of a bug in React, or because \" + \"a component reassigns its own `this.props`. \" + \"Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                        }\n                        if (instance.state !== finishedWork.memoizedState) {\n                          error(\"Expected %s state to match memoized state before \" + \"componentDidMount. \" + \"This might either be because of a bug in React, or because \" + \"a component reassigns its own `this.state`. \" + \"Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                        }\n                      }\n                    }\n                    if (finishedWork.mode & ProfileMode) {\n                      try {\n                        startLayoutEffectTimer();\n                        instance.componentDidMount();\n                      } finally {\n                        recordLayoutEffectDuration(finishedWork);\n                      }\n                    } else {\n                      instance.componentDidMount();\n                    }\n                  } else {\n                    var prevProps = finishedWork.elementType === finishedWork.type ? current2.memoizedProps : resolveDefaultProps(finishedWork.type, current2.memoizedProps);\n                    var prevState = current2.memoizedState;\n                    {\n                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                        if (instance.props !== finishedWork.memoizedProps) {\n                          error(\"Expected %s props to match memoized props before \" + \"componentDidUpdate. \" + \"This might either be because of a bug in React, or because \" + \"a component reassigns its own `this.props`. \" + \"Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                        }\n                        if (instance.state !== finishedWork.memoizedState) {\n                          error(\"Expected %s state to match memoized state before \" + \"componentDidUpdate. \" + \"This might either be because of a bug in React, or because \" + \"a component reassigns its own `this.state`. \" + \"Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                        }\n                      }\n                    }\n                    if (finishedWork.mode & ProfileMode) {\n                      try {\n                        startLayoutEffectTimer();\n                        instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n                      } finally {\n                        recordLayoutEffectDuration(finishedWork);\n                      }\n                    } else {\n                      instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n                    }\n                  }\n                }\n              }\n              var updateQueue = finishedWork.updateQueue;\n              if (updateQueue !== null) {\n                {\n                  if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                    if (instance.props !== finishedWork.memoizedProps) {\n                      error(\"Expected %s props to match memoized props before \" + \"processing the update queue. \" + \"This might either be because of a bug in React, or because \" + \"a component reassigns its own `this.props`. \" + \"Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                    }\n                    if (instance.state !== finishedWork.memoizedState) {\n                      error(\"Expected %s state to match memoized state before \" + \"processing the update queue. \" + \"This might either be because of a bug in React, or because \" + \"a component reassigns its own `this.state`. \" + \"Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                    }\n                  }\n                }\n                commitUpdateQueue(finishedWork, updateQueue, instance);\n              }\n              break;\n            }\n            case HostRoot: {\n              var _updateQueue = finishedWork.updateQueue;\n              if (_updateQueue !== null) {\n                var _instance = null;\n                if (finishedWork.child !== null) {\n                  switch (finishedWork.child.tag) {\n                    case HostComponent:\n                      _instance = getPublicInstance(finishedWork.child.stateNode);\n                      break;\n                    case ClassComponent:\n                      _instance = finishedWork.child.stateNode;\n                      break;\n                  }\n                }\n                commitUpdateQueue(finishedWork, _updateQueue, _instance);\n              }\n              break;\n            }\n            case HostComponent: {\n              var _instance2 = finishedWork.stateNode;\n              if (current2 === null && finishedWork.flags & Update) {\n                var type = finishedWork.type;\n                var props = finishedWork.memoizedProps;\n                commitMount(_instance2, type, props);\n              }\n              break;\n            }\n            case HostText: {\n              break;\n            }\n            case HostPortal: {\n              break;\n            }\n            case Profiler: {\n              {\n                var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;\n                var effectDuration = finishedWork.stateNode.effectDuration;\n                var commitTime2 = getCommitTime();\n                var phase = current2 === null ? \"mount\" : \"update\";\n                {\n                  if (isCurrentUpdateNested()) {\n                    phase = \"nested-update\";\n                  }\n                }\n                if (typeof onRender === \"function\") {\n                  onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime2);\n                }\n                {\n                  if (typeof onCommit === \"function\") {\n                    onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime2);\n                  }\n                  enqueuePendingPassiveProfilerEffect(finishedWork);\n                  var parentFiber = finishedWork.return;\n                  outer:\n                    while (parentFiber !== null) {\n                      switch (parentFiber.tag) {\n                        case HostRoot:\n                          var root2 = parentFiber.stateNode;\n                          root2.effectDuration += effectDuration;\n                          break outer;\n                        case Profiler:\n                          var parentStateNode = parentFiber.stateNode;\n                          parentStateNode.effectDuration += effectDuration;\n                          break outer;\n                      }\n                      parentFiber = parentFiber.return;\n                    }\n                }\n              }\n              break;\n            }\n            case SuspenseComponent: {\n              commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n              break;\n            }\n            case SuspenseListComponent:\n            case IncompleteClassComponent:\n            case ScopeComponent:\n            case OffscreenComponent:\n            case LegacyHiddenComponent:\n            case TracingMarkerComponent: {\n              break;\n            }\n            default:\n              throw new Error(\"This unit of work tag should not have side-effects. This error is \" + \"likely caused by a bug in React. Please file an issue.\");\n          }\n        }\n        if (!offscreenSubtreeWasHidden) {\n          {\n            if (finishedWork.flags & Ref) {\n              commitAttachRef(finishedWork);\n            }\n          }\n        }\n      }\n      function reappearLayoutEffectsOnFiber(node) {\n        switch (node.tag) {\n          case FunctionComponent:\n          case ForwardRef:\n          case SimpleMemoComponent: {\n            if (node.mode & ProfileMode) {\n              try {\n                startLayoutEffectTimer();\n                safelyCallCommitHookLayoutEffectListMount(node, node.return);\n              } finally {\n                recordLayoutEffectDuration(node);\n              }\n            } else {\n              safelyCallCommitHookLayoutEffectListMount(node, node.return);\n            }\n            break;\n          }\n          case ClassComponent: {\n            var instance = node.stateNode;\n            if (typeof instance.componentDidMount === \"function\") {\n              safelyCallComponentDidMount(node, node.return, instance);\n            }\n            safelyAttachRef(node, node.return);\n            break;\n          }\n          case HostComponent: {\n            safelyAttachRef(node, node.return);\n            break;\n          }\n        }\n      }\n      function hideOrUnhideAllChildren(finishedWork, isHidden) {\n        var hostSubtreeRoot = null;\n        {\n          var node = finishedWork;\n          while (true) {\n            if (node.tag === HostComponent) {\n              if (hostSubtreeRoot === null) {\n                hostSubtreeRoot = node;\n                try {\n                  var instance = node.stateNode;\n                  if (isHidden) {\n                    hideInstance(instance);\n                  } else {\n                    unhideInstance(node.stateNode, node.memoizedProps);\n                  }\n                } catch (error2) {\n                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n                }\n              }\n            } else if (node.tag === HostText) {\n              if (hostSubtreeRoot === null) {\n                try {\n                  var _instance3 = node.stateNode;\n                  if (isHidden) {\n                    hideTextInstance(_instance3);\n                  } else {\n                    unhideTextInstance(_instance3, node.memoizedProps);\n                  }\n                } catch (error2) {\n                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n                }\n              }\n            } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork)\n              ;\n            else if (node.child !== null) {\n              node.child.return = node;\n              node = node.child;\n              continue;\n            }\n            if (node === finishedWork) {\n              return;\n            }\n            while (node.sibling === null) {\n              if (node.return === null || node.return === finishedWork) {\n                return;\n              }\n              if (hostSubtreeRoot === node) {\n                hostSubtreeRoot = null;\n              }\n              node = node.return;\n            }\n            if (hostSubtreeRoot === node) {\n              hostSubtreeRoot = null;\n            }\n            node.sibling.return = node.return;\n            node = node.sibling;\n          }\n        }\n      }\n      function commitAttachRef(finishedWork) {\n        var ref = finishedWork.ref;\n        if (ref !== null) {\n          var instance = finishedWork.stateNode;\n          var instanceToUse;\n          switch (finishedWork.tag) {\n            case HostComponent:\n              instanceToUse = getPublicInstance(instance);\n              break;\n            default:\n              instanceToUse = instance;\n          }\n          if (typeof ref === \"function\") {\n            var retVal;\n            if (finishedWork.mode & ProfileMode) {\n              try {\n                startLayoutEffectTimer();\n                retVal = ref(instanceToUse);\n              } finally {\n                recordLayoutEffectDuration(finishedWork);\n              }\n            } else {\n              retVal = ref(instanceToUse);\n            }\n            {\n              if (typeof retVal === \"function\") {\n                error(\"Unexpected return value from a callback ref in %s. \" + \"A callback ref should not return a function.\", getComponentNameFromFiber(finishedWork));\n              }\n            }\n          } else {\n            {\n              if (!ref.hasOwnProperty(\"current\")) {\n                error(\"Unexpected ref object provided for %s. \" + \"Use either a ref-setter function or React.createRef().\", getComponentNameFromFiber(finishedWork));\n              }\n            }\n            ref.current = instanceToUse;\n          }\n        }\n      }\n      function detachFiberMutation(fiber) {\n        var alternate = fiber.alternate;\n        if (alternate !== null) {\n          alternate.return = null;\n        }\n        fiber.return = null;\n      }\n      function detachFiberAfterEffects(fiber) {\n        var alternate = fiber.alternate;\n        if (alternate !== null) {\n          fiber.alternate = null;\n          detachFiberAfterEffects(alternate);\n        }\n        {\n          fiber.child = null;\n          fiber.deletions = null;\n          fiber.sibling = null;\n          if (fiber.tag === HostComponent) {\n            var hostInstance = fiber.stateNode;\n            if (hostInstance !== null) {\n              detachDeletedInstance(hostInstance);\n            }\n          }\n          fiber.stateNode = null;\n          {\n            fiber._debugOwner = null;\n          }\n          {\n            fiber.return = null;\n            fiber.dependencies = null;\n            fiber.memoizedProps = null;\n            fiber.memoizedState = null;\n            fiber.pendingProps = null;\n            fiber.stateNode = null;\n            fiber.updateQueue = null;\n          }\n        }\n      }\n      function getHostParentFiber(fiber) {\n        var parent = fiber.return;\n        while (parent !== null) {\n          if (isHostParent(parent)) {\n            return parent;\n          }\n          parent = parent.return;\n        }\n        throw new Error(\"Expected to find a host parent. This error is likely caused by a bug \" + \"in React. Please file an issue.\");\n      }\n      function isHostParent(fiber) {\n        return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;\n      }\n      function getHostSibling(fiber) {\n        var node = fiber;\n        siblings:\n          while (true) {\n            while (node.sibling === null) {\n              if (node.return === null || isHostParent(node.return)) {\n                return null;\n              }\n              node = node.return;\n            }\n            node.sibling.return = node.return;\n            node = node.sibling;\n            while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {\n              if (node.flags & Placement) {\n                continue siblings;\n              }\n              if (node.child === null || node.tag === HostPortal) {\n                continue siblings;\n              } else {\n                node.child.return = node;\n                node = node.child;\n              }\n            }\n            if (!(node.flags & Placement)) {\n              return node.stateNode;\n            }\n          }\n      }\n      function commitPlacement(finishedWork) {\n        var parentFiber = getHostParentFiber(finishedWork);\n        switch (parentFiber.tag) {\n          case HostComponent: {\n            var parent = parentFiber.stateNode;\n            if (parentFiber.flags & ContentReset) {\n              resetTextContent(parent);\n              parentFiber.flags &= ~ContentReset;\n            }\n            var before = getHostSibling(finishedWork);\n            insertOrAppendPlacementNode(finishedWork, before, parent);\n            break;\n          }\n          case HostRoot:\n          case HostPortal: {\n            var _parent = parentFiber.stateNode.containerInfo;\n            var _before = getHostSibling(finishedWork);\n            insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);\n            break;\n          }\n          default:\n            throw new Error(\"Invalid host parent fiber. This error is likely caused by a bug \" + \"in React. Please file an issue.\");\n        }\n      }\n      function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\n        var tag = node.tag;\n        var isHost = tag === HostComponent || tag === HostText;\n        if (isHost) {\n          var stateNode = node.stateNode;\n          if (before) {\n            insertInContainerBefore(parent, stateNode, before);\n          } else {\n            appendChildToContainer(parent, stateNode);\n          }\n        } else if (tag === HostPortal)\n          ;\n        else {\n          var child = node.child;\n          if (child !== null) {\n            insertOrAppendPlacementNodeIntoContainer(child, before, parent);\n            var sibling = child.sibling;\n            while (sibling !== null) {\n              insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);\n              sibling = sibling.sibling;\n            }\n          }\n        }\n      }\n      function insertOrAppendPlacementNode(node, before, parent) {\n        var tag = node.tag;\n        var isHost = tag === HostComponent || tag === HostText;\n        if (isHost) {\n          var stateNode = node.stateNode;\n          if (before) {\n            insertBefore(parent, stateNode, before);\n          } else {\n            appendChild(parent, stateNode);\n          }\n        } else if (tag === HostPortal)\n          ;\n        else {\n          var child = node.child;\n          if (child !== null) {\n            insertOrAppendPlacementNode(child, before, parent);\n            var sibling = child.sibling;\n            while (sibling !== null) {\n              insertOrAppendPlacementNode(sibling, before, parent);\n              sibling = sibling.sibling;\n            }\n          }\n        }\n      }\n      var hostParent = null;\n      var hostParentIsContainer = false;\n      function commitDeletionEffects(root2, returnFiber, deletedFiber) {\n        {\n          var parent = returnFiber;\n          findParent:\n            while (parent !== null) {\n              switch (parent.tag) {\n                case HostComponent: {\n                  hostParent = parent.stateNode;\n                  hostParentIsContainer = false;\n                  break findParent;\n                }\n                case HostRoot: {\n                  hostParent = parent.stateNode.containerInfo;\n                  hostParentIsContainer = true;\n                  break findParent;\n                }\n                case HostPortal: {\n                  hostParent = parent.stateNode.containerInfo;\n                  hostParentIsContainer = true;\n                  break findParent;\n                }\n              }\n              parent = parent.return;\n            }\n          if (hostParent === null) {\n            throw new Error(\"Expected to find a host parent. This error is likely caused by \" + \"a bug in React. Please file an issue.\");\n          }\n          commitDeletionEffectsOnFiber(root2, returnFiber, deletedFiber);\n          hostParent = null;\n          hostParentIsContainer = false;\n        }\n        detachFiberMutation(deletedFiber);\n      }\n      function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {\n        var child = parent.child;\n        while (child !== null) {\n          commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);\n          child = child.sibling;\n        }\n      }\n      function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {\n        onCommitUnmount(deletedFiber);\n        switch (deletedFiber.tag) {\n          case HostComponent: {\n            if (!offscreenSubtreeWasHidden) {\n              safelyDetachRef(deletedFiber, nearestMountedAncestor);\n            }\n          }\n          case HostText: {\n            {\n              var prevHostParent = hostParent;\n              var prevHostParentIsContainer = hostParentIsContainer;\n              hostParent = null;\n              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n              hostParent = prevHostParent;\n              hostParentIsContainer = prevHostParentIsContainer;\n              if (hostParent !== null) {\n                if (hostParentIsContainer) {\n                  removeChildFromContainer(hostParent, deletedFiber.stateNode);\n                } else {\n                  removeChild(hostParent, deletedFiber.stateNode);\n                }\n              }\n            }\n            return;\n          }\n          case DehydratedFragment: {\n            {\n              if (hostParent !== null) {\n                if (hostParentIsContainer) {\n                  clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);\n                } else {\n                  clearSuspenseBoundary(hostParent, deletedFiber.stateNode);\n                }\n              }\n            }\n            return;\n          }\n          case HostPortal: {\n            {\n              var _prevHostParent = hostParent;\n              var _prevHostParentIsContainer = hostParentIsContainer;\n              hostParent = deletedFiber.stateNode.containerInfo;\n              hostParentIsContainer = true;\n              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n              hostParent = _prevHostParent;\n              hostParentIsContainer = _prevHostParentIsContainer;\n            }\n            return;\n          }\n          case FunctionComponent:\n          case ForwardRef:\n          case MemoComponent:\n          case SimpleMemoComponent: {\n            if (!offscreenSubtreeWasHidden) {\n              var updateQueue = deletedFiber.updateQueue;\n              if (updateQueue !== null) {\n                var lastEffect = updateQueue.lastEffect;\n                if (lastEffect !== null) {\n                  var firstEffect = lastEffect.next;\n                  var effect = firstEffect;\n                  do {\n                    var _effect = effect, destroy = _effect.destroy, tag = _effect.tag;\n                    if (destroy !== undefined) {\n                      if ((tag & Insertion) !== NoFlags$1) {\n                        safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                      } else if ((tag & Layout) !== NoFlags$1) {\n                        {\n                          markComponentLayoutEffectUnmountStarted(deletedFiber);\n                        }\n                        if (deletedFiber.mode & ProfileMode) {\n                          startLayoutEffectTimer();\n                          safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                          recordLayoutEffectDuration(deletedFiber);\n                        } else {\n                          safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                        }\n                        {\n                          markComponentLayoutEffectUnmountStopped();\n                        }\n                      }\n                    }\n                    effect = effect.next;\n                  } while (effect !== firstEffect);\n                }\n              }\n            }\n            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n            return;\n          }\n          case ClassComponent: {\n            if (!offscreenSubtreeWasHidden) {\n              safelyDetachRef(deletedFiber, nearestMountedAncestor);\n              var instance = deletedFiber.stateNode;\n              if (typeof instance.componentWillUnmount === \"function\") {\n                safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);\n              }\n            }\n            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n            return;\n          }\n          case ScopeComponent: {\n            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n            return;\n          }\n          case OffscreenComponent: {\n            if (deletedFiber.mode & ConcurrentMode) {\n              var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;\n              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n            } else {\n              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n            }\n            break;\n          }\n          default: {\n            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n            return;\n          }\n        }\n      }\n      function commitSuspenseCallback(finishedWork) {\n        var newState = finishedWork.memoizedState;\n      }\n      function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\n        var newState = finishedWork.memoizedState;\n        if (newState === null) {\n          var current2 = finishedWork.alternate;\n          if (current2 !== null) {\n            var prevState = current2.memoizedState;\n            if (prevState !== null) {\n              var suspenseInstance = prevState.dehydrated;\n              if (suspenseInstance !== null) {\n                commitHydratedSuspenseInstance(suspenseInstance);\n              }\n            }\n          }\n        }\n      }\n      function attachSuspenseRetryListeners(finishedWork) {\n        var wakeables = finishedWork.updateQueue;\n        if (wakeables !== null) {\n          finishedWork.updateQueue = null;\n          var retryCache = finishedWork.stateNode;\n          if (retryCache === null) {\n            retryCache = finishedWork.stateNode = new PossiblyWeakSet;\n          }\n          wakeables.forEach(function(wakeable) {\n            var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\n            if (!retryCache.has(wakeable)) {\n              retryCache.add(wakeable);\n              {\n                if (isDevToolsPresent) {\n                  if (inProgressLanes !== null && inProgressRoot !== null) {\n                    restorePendingUpdaters(inProgressRoot, inProgressLanes);\n                  } else {\n                    throw Error(\"Expected finished root and lanes to be set. This is a bug in React.\");\n                  }\n                }\n              }\n              wakeable.then(retry, retry);\n            }\n          });\n        }\n      }\n      function commitMutationEffects(root2, finishedWork, committedLanes) {\n        inProgressLanes = committedLanes;\n        inProgressRoot = root2;\n        setCurrentFiber(finishedWork);\n        commitMutationEffectsOnFiber(finishedWork, root2);\n        setCurrentFiber(finishedWork);\n        inProgressLanes = null;\n        inProgressRoot = null;\n      }\n      function recursivelyTraverseMutationEffects(root2, parentFiber, lanes) {\n        var deletions = parentFiber.deletions;\n        if (deletions !== null) {\n          for (var i = 0;i < deletions.length; i++) {\n            var childToDelete = deletions[i];\n            try {\n              commitDeletionEffects(root2, parentFiber, childToDelete);\n            } catch (error2) {\n              captureCommitPhaseError(childToDelete, parentFiber, error2);\n            }\n          }\n        }\n        var prevDebugFiber = getCurrentFiber();\n        if (parentFiber.subtreeFlags & MutationMask) {\n          var child = parentFiber.child;\n          while (child !== null) {\n            setCurrentFiber(child);\n            commitMutationEffectsOnFiber(child, root2);\n            child = child.sibling;\n          }\n        }\n        setCurrentFiber(prevDebugFiber);\n      }\n      function commitMutationEffectsOnFiber(finishedWork, root2, lanes) {\n        var current2 = finishedWork.alternate;\n        var flags = finishedWork.flags;\n        switch (finishedWork.tag) {\n          case FunctionComponent:\n          case ForwardRef:\n          case MemoComponent:\n          case SimpleMemoComponent: {\n            recursivelyTraverseMutationEffects(root2, finishedWork);\n            commitReconciliationEffects(finishedWork);\n            if (flags & Update) {\n              try {\n                commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);\n                commitHookEffectListMount(Insertion | HasEffect, finishedWork);\n              } catch (error2) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n              }\n              if (finishedWork.mode & ProfileMode) {\n                try {\n                  startLayoutEffectTimer();\n                  commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n                } catch (error2) {\n                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n                }\n                recordLayoutEffectDuration(finishedWork);\n              } else {\n                try {\n                  commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n                } catch (error2) {\n                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n                }\n              }\n            }\n            return;\n          }\n          case ClassComponent: {\n            recursivelyTraverseMutationEffects(root2, finishedWork);\n            commitReconciliationEffects(finishedWork);\n            if (flags & Ref) {\n              if (current2 !== null) {\n                safelyDetachRef(current2, current2.return);\n              }\n            }\n            return;\n          }\n          case HostComponent: {\n            recursivelyTraverseMutationEffects(root2, finishedWork);\n            commitReconciliationEffects(finishedWork);\n            if (flags & Ref) {\n              if (current2 !== null) {\n                safelyDetachRef(current2, current2.return);\n              }\n            }\n            {\n              if (finishedWork.flags & ContentReset) {\n                var instance = finishedWork.stateNode;\n                try {\n                  resetTextContent(instance);\n                } catch (error2) {\n                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n                }\n              }\n              if (flags & Update) {\n                var _instance4 = finishedWork.stateNode;\n                if (_instance4 != null) {\n                  var newProps = finishedWork.memoizedProps;\n                  var oldProps = current2 !== null ? current2.memoizedProps : newProps;\n                  var type = finishedWork.type;\n                  var updatePayload = finishedWork.updateQueue;\n                  finishedWork.updateQueue = null;\n                  if (updatePayload !== null) {\n                    try {\n                      commitUpdate(_instance4, updatePayload, type, oldProps, newProps, finishedWork);\n                    } catch (error2) {\n                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n                    }\n                  }\n                }\n              }\n            }\n            return;\n          }\n          case HostText: {\n            recursivelyTraverseMutationEffects(root2, finishedWork);\n            commitReconciliationEffects(finishedWork);\n            if (flags & Update) {\n              {\n                if (finishedWork.stateNode === null) {\n                  throw new Error(\"This should have a text node initialized. This error is likely \" + \"caused by a bug in React. Please file an issue.\");\n                }\n                var textInstance = finishedWork.stateNode;\n                var newText = finishedWork.memoizedProps;\n                var oldText = current2 !== null ? current2.memoizedProps : newText;\n                try {\n                  commitTextUpdate(textInstance, oldText, newText);\n                } catch (error2) {\n                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n                }\n              }\n            }\n            return;\n          }\n          case HostRoot: {\n            recursivelyTraverseMutationEffects(root2, finishedWork);\n            commitReconciliationEffects(finishedWork);\n            if (flags & Update) {\n              {\n                if (current2 !== null) {\n                  var prevRootState = current2.memoizedState;\n                  if (prevRootState.isDehydrated) {\n                    try {\n                      commitHydratedContainer(root2.containerInfo);\n                    } catch (error2) {\n                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n                    }\n                  }\n                }\n              }\n            }\n            return;\n          }\n          case HostPortal: {\n            recursivelyTraverseMutationEffects(root2, finishedWork);\n            commitReconciliationEffects(finishedWork);\n            return;\n          }\n          case SuspenseComponent: {\n            recursivelyTraverseMutationEffects(root2, finishedWork);\n            commitReconciliationEffects(finishedWork);\n            var offscreenFiber = finishedWork.child;\n            if (offscreenFiber.flags & Visibility) {\n              var offscreenInstance = offscreenFiber.stateNode;\n              var newState = offscreenFiber.memoizedState;\n              var isHidden = newState !== null;\n              offscreenInstance.isHidden = isHidden;\n              if (isHidden) {\n                var wasHidden = offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null;\n                if (!wasHidden) {\n                  markCommitTimeOfFallback();\n                }\n              }\n            }\n            if (flags & Update) {\n              try {\n                commitSuspenseCallback(finishedWork);\n              } catch (error2) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n              }\n              attachSuspenseRetryListeners(finishedWork);\n            }\n            return;\n          }\n          case OffscreenComponent: {\n            var _wasHidden = current2 !== null && current2.memoizedState !== null;\n            if (finishedWork.mode & ConcurrentMode) {\n              var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || _wasHidden;\n              recursivelyTraverseMutationEffects(root2, finishedWork);\n              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n            } else {\n              recursivelyTraverseMutationEffects(root2, finishedWork);\n            }\n            commitReconciliationEffects(finishedWork);\n            if (flags & Visibility) {\n              var _offscreenInstance = finishedWork.stateNode;\n              var _newState = finishedWork.memoizedState;\n              var _isHidden = _newState !== null;\n              var offscreenBoundary = finishedWork;\n              _offscreenInstance.isHidden = _isHidden;\n              {\n                if (_isHidden) {\n                  if (!_wasHidden) {\n                    if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {\n                      nextEffect = offscreenBoundary;\n                      var offscreenChild = offscreenBoundary.child;\n                      while (offscreenChild !== null) {\n                        nextEffect = offscreenChild;\n                        disappearLayoutEffects_begin(offscreenChild);\n                        offscreenChild = offscreenChild.sibling;\n                      }\n                    }\n                  }\n                }\n              }\n              {\n                hideOrUnhideAllChildren(offscreenBoundary, _isHidden);\n              }\n            }\n            return;\n          }\n          case SuspenseListComponent: {\n            recursivelyTraverseMutationEffects(root2, finishedWork);\n            commitReconciliationEffects(finishedWork);\n            if (flags & Update) {\n              attachSuspenseRetryListeners(finishedWork);\n            }\n            return;\n          }\n          case ScopeComponent: {\n            return;\n          }\n          default: {\n            recursivelyTraverseMutationEffects(root2, finishedWork);\n            commitReconciliationEffects(finishedWork);\n            return;\n          }\n        }\n      }\n      function commitReconciliationEffects(finishedWork) {\n        var flags = finishedWork.flags;\n        if (flags & Placement) {\n          try {\n            commitPlacement(finishedWork);\n          } catch (error2) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n          }\n          finishedWork.flags &= ~Placement;\n        }\n        if (flags & Hydrating) {\n          finishedWork.flags &= ~Hydrating;\n        }\n      }\n      function commitLayoutEffects(finishedWork, root2, committedLanes) {\n        inProgressLanes = committedLanes;\n        inProgressRoot = root2;\n        nextEffect = finishedWork;\n        commitLayoutEffects_begin(finishedWork, root2, committedLanes);\n        inProgressLanes = null;\n        inProgressRoot = null;\n      }\n      function commitLayoutEffects_begin(subtreeRoot, root2, committedLanes) {\n        var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;\n        while (nextEffect !== null) {\n          var fiber = nextEffect;\n          var firstChild = fiber.child;\n          if (fiber.tag === OffscreenComponent && isModernRoot) {\n            var isHidden = fiber.memoizedState !== null;\n            var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;\n            if (newOffscreenSubtreeIsHidden) {\n              commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);\n              continue;\n            } else {\n              var current2 = fiber.alternate;\n              var wasHidden = current2 !== null && current2.memoizedState !== null;\n              var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;\n              var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;\n              var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n              offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;\n              offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;\n              if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {\n                nextEffect = fiber;\n                reappearLayoutEffects_begin(fiber);\n              }\n              var child = firstChild;\n              while (child !== null) {\n                nextEffect = child;\n                commitLayoutEffects_begin(child, root2, committedLanes);\n                child = child.sibling;\n              }\n              nextEffect = fiber;\n              offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n              commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);\n              continue;\n            }\n          }\n          if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {\n            firstChild.return = fiber;\n            nextEffect = firstChild;\n          } else {\n            commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);\n          }\n        }\n      }\n      function commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes) {\n        while (nextEffect !== null) {\n          var fiber = nextEffect;\n          if ((fiber.flags & LayoutMask) !== NoFlags) {\n            var current2 = fiber.alternate;\n            setCurrentFiber(fiber);\n            try {\n              commitLayoutEffectOnFiber(root2, current2, fiber, committedLanes);\n            } catch (error2) {\n              captureCommitPhaseError(fiber, fiber.return, error2);\n            }\n            resetCurrentFiber();\n          }\n          if (fiber === subtreeRoot) {\n            nextEffect = null;\n            return;\n          }\n          var sibling = fiber.sibling;\n          if (sibling !== null) {\n            sibling.return = fiber.return;\n            nextEffect = sibling;\n            return;\n          }\n          nextEffect = fiber.return;\n        }\n      }\n      function disappearLayoutEffects_begin(subtreeRoot) {\n        while (nextEffect !== null) {\n          var fiber = nextEffect;\n          var firstChild = fiber.child;\n          switch (fiber.tag) {\n            case FunctionComponent:\n            case ForwardRef:\n            case MemoComponent:\n            case SimpleMemoComponent: {\n              if (fiber.mode & ProfileMode) {\n                try {\n                  startLayoutEffectTimer();\n                  commitHookEffectListUnmount(Layout, fiber, fiber.return);\n                } finally {\n                  recordLayoutEffectDuration(fiber);\n                }\n              } else {\n                commitHookEffectListUnmount(Layout, fiber, fiber.return);\n              }\n              break;\n            }\n            case ClassComponent: {\n              safelyDetachRef(fiber, fiber.return);\n              var instance = fiber.stateNode;\n              if (typeof instance.componentWillUnmount === \"function\") {\n                safelyCallComponentWillUnmount(fiber, fiber.return, instance);\n              }\n              break;\n            }\n            case HostComponent: {\n              safelyDetachRef(fiber, fiber.return);\n              break;\n            }\n            case OffscreenComponent: {\n              var isHidden = fiber.memoizedState !== null;\n              if (isHidden) {\n                disappearLayoutEffects_complete(subtreeRoot);\n                continue;\n              }\n              break;\n            }\n          }\n          if (firstChild !== null) {\n            firstChild.return = fiber;\n            nextEffect = firstChild;\n          } else {\n            disappearLayoutEffects_complete(subtreeRoot);\n          }\n        }\n      }\n      function disappearLayoutEffects_complete(subtreeRoot) {\n        while (nextEffect !== null) {\n          var fiber = nextEffect;\n          if (fiber === subtreeRoot) {\n            nextEffect = null;\n            return;\n          }\n          var sibling = fiber.sibling;\n          if (sibling !== null) {\n            sibling.return = fiber.return;\n            nextEffect = sibling;\n            return;\n          }\n          nextEffect = fiber.return;\n        }\n      }\n      function reappearLayoutEffects_begin(subtreeRoot) {\n        while (nextEffect !== null) {\n          var fiber = nextEffect;\n          var firstChild = fiber.child;\n          if (fiber.tag === OffscreenComponent) {\n            var isHidden = fiber.memoizedState !== null;\n            if (isHidden) {\n              reappearLayoutEffects_complete(subtreeRoot);\n              continue;\n            }\n          }\n          if (firstChild !== null) {\n            firstChild.return = fiber;\n            nextEffect = firstChild;\n          } else {\n            reappearLayoutEffects_complete(subtreeRoot);\n          }\n        }\n      }\n      function reappearLayoutEffects_complete(subtreeRoot) {\n        while (nextEffect !== null) {\n          var fiber = nextEffect;\n          setCurrentFiber(fiber);\n          try {\n            reappearLayoutEffectsOnFiber(fiber);\n          } catch (error2) {\n            captureCommitPhaseError(fiber, fiber.return, error2);\n          }\n          resetCurrentFiber();\n          if (fiber === subtreeRoot) {\n            nextEffect = null;\n            return;\n          }\n          var sibling = fiber.sibling;\n          if (sibling !== null) {\n            sibling.return = fiber.return;\n            nextEffect = sibling;\n            return;\n          }\n          nextEffect = fiber.return;\n        }\n      }\n      function commitPassiveMountEffects(root2, finishedWork, committedLanes, committedTransitions) {\n        nextEffect = finishedWork;\n        commitPassiveMountEffects_begin(finishedWork, root2, committedLanes, committedTransitions);\n      }\n      function commitPassiveMountEffects_begin(subtreeRoot, root2, committedLanes, committedTransitions) {\n        while (nextEffect !== null) {\n          var fiber = nextEffect;\n          var firstChild = fiber.child;\n          if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {\n            firstChild.return = fiber;\n            nextEffect = firstChild;\n          } else {\n            commitPassiveMountEffects_complete(subtreeRoot, root2, committedLanes, committedTransitions);\n          }\n        }\n      }\n      function commitPassiveMountEffects_complete(subtreeRoot, root2, committedLanes, committedTransitions) {\n        while (nextEffect !== null) {\n          var fiber = nextEffect;\n          if ((fiber.flags & Passive) !== NoFlags) {\n            setCurrentFiber(fiber);\n            try {\n              commitPassiveMountOnFiber(root2, fiber, committedLanes, committedTransitions);\n            } catch (error2) {\n              captureCommitPhaseError(fiber, fiber.return, error2);\n            }\n            resetCurrentFiber();\n          }\n          if (fiber === subtreeRoot) {\n            nextEffect = null;\n            return;\n          }\n          var sibling = fiber.sibling;\n          if (sibling !== null) {\n            sibling.return = fiber.return;\n            nextEffect = sibling;\n            return;\n          }\n          nextEffect = fiber.return;\n        }\n      }\n      function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {\n        switch (finishedWork.tag) {\n          case FunctionComponent:\n          case ForwardRef:\n          case SimpleMemoComponent: {\n            if (finishedWork.mode & ProfileMode) {\n              startPassiveEffectTimer();\n              try {\n                commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);\n              } finally {\n                recordPassiveEffectDuration(finishedWork);\n              }\n            } else {\n              commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);\n            }\n            break;\n          }\n        }\n      }\n      function commitPassiveUnmountEffects(firstChild) {\n        nextEffect = firstChild;\n        commitPassiveUnmountEffects_begin();\n      }\n      function commitPassiveUnmountEffects_begin() {\n        while (nextEffect !== null) {\n          var fiber = nextEffect;\n          var child = fiber.child;\n          if ((nextEffect.flags & ChildDeletion) !== NoFlags) {\n            var deletions = fiber.deletions;\n            if (deletions !== null) {\n              for (var i = 0;i < deletions.length; i++) {\n                var fiberToDelete = deletions[i];\n                nextEffect = fiberToDelete;\n                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);\n              }\n              {\n                var previousFiber = fiber.alternate;\n                if (previousFiber !== null) {\n                  var detachedChild = previousFiber.child;\n                  if (detachedChild !== null) {\n                    previousFiber.child = null;\n                    do {\n                      var detachedSibling = detachedChild.sibling;\n                      detachedChild.sibling = null;\n                      detachedChild = detachedSibling;\n                    } while (detachedChild !== null);\n                  }\n                }\n              }\n              nextEffect = fiber;\n            }\n          }\n          if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {\n            child.return = fiber;\n            nextEffect = child;\n          } else {\n            commitPassiveUnmountEffects_complete();\n          }\n        }\n      }\n      function commitPassiveUnmountEffects_complete() {\n        while (nextEffect !== null) {\n          var fiber = nextEffect;\n          if ((fiber.flags & Passive) !== NoFlags) {\n            setCurrentFiber(fiber);\n            commitPassiveUnmountOnFiber(fiber);\n            resetCurrentFiber();\n          }\n          var sibling = fiber.sibling;\n          if (sibling !== null) {\n            sibling.return = fiber.return;\n            nextEffect = sibling;\n            return;\n          }\n          nextEffect = fiber.return;\n        }\n      }\n      function commitPassiveUnmountOnFiber(finishedWork) {\n        switch (finishedWork.tag) {\n          case FunctionComponent:\n          case ForwardRef:\n          case SimpleMemoComponent: {\n            if (finishedWork.mode & ProfileMode) {\n              startPassiveEffectTimer();\n              commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);\n              recordPassiveEffectDuration(finishedWork);\n            } else {\n              commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);\n            }\n            break;\n          }\n        }\n      }\n      function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {\n        while (nextEffect !== null) {\n          var fiber = nextEffect;\n          setCurrentFiber(fiber);\n          commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);\n          resetCurrentFiber();\n          var child = fiber.child;\n          if (child !== null) {\n            child.return = fiber;\n            nextEffect = child;\n          } else {\n            commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);\n          }\n        }\n      }\n      function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {\n        while (nextEffect !== null) {\n          var fiber = nextEffect;\n          var sibling = fiber.sibling;\n          var returnFiber = fiber.return;\n          {\n            detachFiberAfterEffects(fiber);\n            if (fiber === deletedSubtreeRoot) {\n              nextEffect = null;\n              return;\n            }\n          }\n          if (sibling !== null) {\n            sibling.return = returnFiber;\n            nextEffect = sibling;\n            return;\n          }\n          nextEffect = returnFiber;\n        }\n      }\n      function commitPassiveUnmountInsideDeletedTreeOnFiber(current2, nearestMountedAncestor) {\n        switch (current2.tag) {\n          case FunctionComponent:\n          case ForwardRef:\n          case SimpleMemoComponent: {\n            if (current2.mode & ProfileMode) {\n              startPassiveEffectTimer();\n              commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);\n              recordPassiveEffectDuration(current2);\n            } else {\n              commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);\n            }\n            break;\n          }\n        }\n      }\n      function invokeLayoutEffectMountInDEV(fiber) {\n        {\n          switch (fiber.tag) {\n            case FunctionComponent:\n            case ForwardRef:\n            case SimpleMemoComponent: {\n              try {\n                commitHookEffectListMount(Layout | HasEffect, fiber);\n              } catch (error2) {\n                captureCommitPhaseError(fiber, fiber.return, error2);\n              }\n              break;\n            }\n            case ClassComponent: {\n              var instance = fiber.stateNode;\n              try {\n                instance.componentDidMount();\n              } catch (error2) {\n                captureCommitPhaseError(fiber, fiber.return, error2);\n              }\n              break;\n            }\n          }\n        }\n      }\n      function invokePassiveEffectMountInDEV(fiber) {\n        {\n          switch (fiber.tag) {\n            case FunctionComponent:\n            case ForwardRef:\n            case SimpleMemoComponent: {\n              try {\n                commitHookEffectListMount(Passive$1 | HasEffect, fiber);\n              } catch (error2) {\n                captureCommitPhaseError(fiber, fiber.return, error2);\n              }\n              break;\n            }\n          }\n        }\n      }\n      function invokeLayoutEffectUnmountInDEV(fiber) {\n        {\n          switch (fiber.tag) {\n            case FunctionComponent:\n            case ForwardRef:\n            case SimpleMemoComponent: {\n              try {\n                commitHookEffectListUnmount(Layout | HasEffect, fiber, fiber.return);\n              } catch (error2) {\n                captureCommitPhaseError(fiber, fiber.return, error2);\n              }\n              break;\n            }\n            case ClassComponent: {\n              var instance = fiber.stateNode;\n              if (typeof instance.componentWillUnmount === \"function\") {\n                safelyCallComponentWillUnmount(fiber, fiber.return, instance);\n              }\n              break;\n            }\n          }\n        }\n      }\n      function invokePassiveEffectUnmountInDEV(fiber) {\n        {\n          switch (fiber.tag) {\n            case FunctionComponent:\n            case ForwardRef:\n            case SimpleMemoComponent: {\n              try {\n                commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);\n              } catch (error2) {\n                captureCommitPhaseError(fiber, fiber.return, error2);\n              }\n            }\n          }\n        }\n      }\n      var COMPONENT_TYPE = 0;\n      var HAS_PSEUDO_CLASS_TYPE = 1;\n      var ROLE_TYPE = 2;\n      var TEST_NAME_TYPE = 3;\n      var TEXT_TYPE = 4;\n      if (typeof Symbol === \"function\" && Symbol.for) {\n        var symbolFor = Symbol.for;\n        COMPONENT_TYPE = symbolFor(\"selector.component\");\n        HAS_PSEUDO_CLASS_TYPE = symbolFor(\"selector.has_pseudo_class\");\n        ROLE_TYPE = symbolFor(\"selector.role\");\n        TEST_NAME_TYPE = symbolFor(\"selector.test_id\");\n        TEXT_TYPE = symbolFor(\"selector.text\");\n      }\n      var commitHooks = [];\n      function onCommitRoot$1() {\n        {\n          commitHooks.forEach(function(commitHook) {\n            return commitHook();\n          });\n        }\n      }\n      var ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;\n      function isLegacyActEnvironment(fiber) {\n        {\n          var isReactActEnvironmentGlobal = typeof IS_REACT_ACT_ENVIRONMENT !== \"undefined\" ? IS_REACT_ACT_ENVIRONMENT : undefined;\n          var jestIsDefined = typeof jest !== \"undefined\";\n          return jestIsDefined && isReactActEnvironmentGlobal !== false;\n        }\n      }\n      function isConcurrentActEnvironment() {\n        {\n          var isReactActEnvironmentGlobal = typeof IS_REACT_ACT_ENVIRONMENT !== \"undefined\" ? IS_REACT_ACT_ENVIRONMENT : undefined;\n          if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {\n            error(\"The current testing environment is not configured to support \" + \"act(...)\");\n          }\n          return isReactActEnvironmentGlobal;\n        }\n      }\n      var ceil = Math.ceil;\n      var { ReactCurrentDispatcher: ReactCurrentDispatcher$2, ReactCurrentOwner: ReactCurrentOwner$2, ReactCurrentBatchConfig: ReactCurrentBatchConfig$3, ReactCurrentActQueue: ReactCurrentActQueue$1 } = ReactSharedInternals;\n      var NoContext = 0;\n      var BatchedContext = 1;\n      var RenderContext = 2;\n      var CommitContext = 4;\n      var RootInProgress = 0;\n      var RootFatalErrored = 1;\n      var RootErrored = 2;\n      var RootSuspended = 3;\n      var RootSuspendedWithDelay = 4;\n      var RootCompleted = 5;\n      var RootDidNotComplete = 6;\n      var executionContext = NoContext;\n      var workInProgressRoot = null;\n      var workInProgress = null;\n      var workInProgressRootRenderLanes = NoLanes;\n      var subtreeRenderLanes = NoLanes;\n      var subtreeRenderLanesCursor = createCursor(NoLanes);\n      var workInProgressRootExitStatus = RootInProgress;\n      var workInProgressRootFatalError = null;\n      var workInProgressRootIncludedLanes = NoLanes;\n      var workInProgressRootSkippedLanes = NoLanes;\n      var workInProgressRootInterleavedUpdatedLanes = NoLanes;\n      var workInProgressRootPingedLanes = NoLanes;\n      var workInProgressRootConcurrentErrors = null;\n      var workInProgressRootRecoverableErrors = null;\n      var globalMostRecentFallbackTime = 0;\n      var FALLBACK_THROTTLE_MS = 500;\n      var workInProgressRootRenderTargetTime = Infinity;\n      var RENDER_TIMEOUT_MS = 500;\n      var workInProgressTransitions = null;\n      function resetRenderTimer() {\n        workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;\n      }\n      function getRenderTargetTime() {\n        return workInProgressRootRenderTargetTime;\n      }\n      var hasUncaughtError = false;\n      var firstUncaughtError = null;\n      var legacyErrorBoundariesThatAlreadyFailed = null;\n      var rootDoesHavePassiveEffects = false;\n      var rootWithPendingPassiveEffects = null;\n      var pendingPassiveEffectsLanes = NoLanes;\n      var pendingPassiveProfilerEffects = [];\n      var pendingPassiveTransitions = null;\n      var NESTED_UPDATE_LIMIT = 50;\n      var nestedUpdateCount = 0;\n      var rootWithNestedUpdates = null;\n      var isFlushingPassiveEffects = false;\n      var didScheduleUpdateDuringPassiveEffects = false;\n      var NESTED_PASSIVE_UPDATE_LIMIT = 50;\n      var nestedPassiveUpdateCount = 0;\n      var rootWithPassiveNestedUpdates = null;\n      var currentEventTime = NoTimestamp;\n      var currentEventTransitionLane = NoLanes;\n      var isRunningInsertionEffect = false;\n      function getWorkInProgressRoot() {\n        return workInProgressRoot;\n      }\n      function requestEventTime() {\n        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n          return now();\n        }\n        if (currentEventTime !== NoTimestamp) {\n          return currentEventTime;\n        }\n        currentEventTime = now();\n        return currentEventTime;\n      }\n      function requestUpdateLane(fiber) {\n        var mode = fiber.mode;\n        if ((mode & ConcurrentMode) === NoMode) {\n          return SyncLane;\n        } else if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {\n          return pickArbitraryLane(workInProgressRootRenderLanes);\n        }\n        var isTransition = requestCurrentTransition() !== NoTransition;\n        if (isTransition) {\n          if (ReactCurrentBatchConfig$3.transition !== null) {\n            var transition = ReactCurrentBatchConfig$3.transition;\n            if (!transition._updatedFibers) {\n              transition._updatedFibers = new Set;\n            }\n            transition._updatedFibers.add(fiber);\n          }\n          if (currentEventTransitionLane === NoLane) {\n            currentEventTransitionLane = claimNextTransitionLane();\n          }\n          return currentEventTransitionLane;\n        }\n        var updateLane = getCurrentUpdatePriority();\n        if (updateLane !== NoLane) {\n          return updateLane;\n        }\n        var eventLane = getCurrentEventPriority();\n        return eventLane;\n      }\n      function requestRetryLane(fiber) {\n        var mode = fiber.mode;\n        if ((mode & ConcurrentMode) === NoMode) {\n          return SyncLane;\n        }\n        return claimNextRetryLane();\n      }\n      function scheduleUpdateOnFiber(root2, fiber, lane, eventTime) {\n        checkForNestedUpdates();\n        {\n          if (isRunningInsertionEffect) {\n            error(\"useInsertionEffect must not schedule updates.\");\n          }\n        }\n        {\n          if (isFlushingPassiveEffects) {\n            didScheduleUpdateDuringPassiveEffects = true;\n          }\n        }\n        markRootUpdated(root2, lane, eventTime);\n        if ((executionContext & RenderContext) !== NoLanes && root2 === workInProgressRoot) {\n          warnAboutRenderPhaseUpdatesInDEV(fiber);\n        } else {\n          {\n            if (isDevToolsPresent) {\n              addFiberToLanesMap(root2, fiber, lane);\n            }\n          }\n          warnIfUpdatesNotWrappedWithActDEV(fiber);\n          if (root2 === workInProgressRoot) {\n            if ((executionContext & RenderContext) === NoContext) {\n              workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);\n            }\n            if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\n              markRootSuspended$1(root2, workInProgressRootRenderLanes);\n            }\n          }\n          ensureRootIsScheduled(root2, eventTime);\n          if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && !ReactCurrentActQueue$1.isBatchingLegacy) {\n            resetRenderTimer();\n            flushSyncCallbacksOnlyInLegacyMode();\n          }\n        }\n      }\n      function scheduleInitialHydrationOnRoot(root2, lane, eventTime) {\n        var current2 = root2.current;\n        current2.lanes = lane;\n        markRootUpdated(root2, lane, eventTime);\n        ensureRootIsScheduled(root2, eventTime);\n      }\n      function isUnsafeClassRenderPhaseUpdate(fiber) {\n        return (executionContext & RenderContext) !== NoContext;\n      }\n      function ensureRootIsScheduled(root2, currentTime) {\n        var existingCallbackNode = root2.callbackNode;\n        markStarvedLanesAsExpired(root2, currentTime);\n        var nextLanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n        if (nextLanes === NoLanes) {\n          if (existingCallbackNode !== null) {\n            cancelCallback$1(existingCallbackNode);\n          }\n          root2.callbackNode = null;\n          root2.callbackPriority = NoLane;\n          return;\n        }\n        var newCallbackPriority = getHighestPriorityLane(nextLanes);\n        var existingCallbackPriority = root2.callbackPriority;\n        if (existingCallbackPriority === newCallbackPriority && !(ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {\n          {\n            if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {\n              error(\"Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n          }\n          return;\n        }\n        if (existingCallbackNode != null) {\n          cancelCallback$1(existingCallbackNode);\n        }\n        var newCallbackNode;\n        if (newCallbackPriority === SyncLane) {\n          if (root2.tag === LegacyRoot) {\n            if (ReactCurrentActQueue$1.isBatchingLegacy !== null) {\n              ReactCurrentActQueue$1.didScheduleLegacyUpdate = true;\n            }\n            scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root2));\n          } else {\n            scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root2));\n          }\n          {\n            if (ReactCurrentActQueue$1.current !== null) {\n              ReactCurrentActQueue$1.current.push(flushSyncCallbacks);\n            } else {\n              scheduleMicrotask(function() {\n                if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n                  flushSyncCallbacks();\n                }\n              });\n            }\n          }\n          newCallbackNode = null;\n        } else {\n          var schedulerPriorityLevel;\n          switch (lanesToEventPriority(nextLanes)) {\n            case DiscreteEventPriority:\n              schedulerPriorityLevel = ImmediatePriority;\n              break;\n            case ContinuousEventPriority:\n              schedulerPriorityLevel = UserBlockingPriority;\n              break;\n            case DefaultEventPriority:\n              schedulerPriorityLevel = NormalPriority;\n              break;\n            case IdleEventPriority:\n              schedulerPriorityLevel = IdlePriority;\n              break;\n            default:\n              schedulerPriorityLevel = NormalPriority;\n              break;\n          }\n          newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root2));\n        }\n        root2.callbackPriority = newCallbackPriority;\n        root2.callbackNode = newCallbackNode;\n      }\n      function performConcurrentWorkOnRoot(root2, didTimeout) {\n        {\n          resetNestedUpdateFlag();\n        }\n        currentEventTime = NoTimestamp;\n        currentEventTransitionLane = NoLanes;\n        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n          throw new Error(\"Should not already be working.\");\n        }\n        var originalCallbackNode = root2.callbackNode;\n        var didFlushPassiveEffects = flushPassiveEffects();\n        if (didFlushPassiveEffects) {\n          if (root2.callbackNode !== originalCallbackNode) {\n            return null;\n          }\n        }\n        var lanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n        if (lanes === NoLanes) {\n          return null;\n        }\n        var shouldTimeSlice = !includesBlockingLane(root2, lanes) && !includesExpiredLane(root2, lanes) && !didTimeout;\n        var exitStatus = shouldTimeSlice ? renderRootConcurrent(root2, lanes) : renderRootSync(root2, lanes);\n        if (exitStatus !== RootInProgress) {\n          if (exitStatus === RootErrored) {\n            var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);\n            if (errorRetryLanes !== NoLanes) {\n              lanes = errorRetryLanes;\n              exitStatus = recoverFromConcurrentError(root2, errorRetryLanes);\n            }\n          }\n          if (exitStatus === RootFatalErrored) {\n            var fatalError = workInProgressRootFatalError;\n            prepareFreshStack(root2, NoLanes);\n            markRootSuspended$1(root2, lanes);\n            ensureRootIsScheduled(root2, now());\n            throw fatalError;\n          }\n          if (exitStatus === RootDidNotComplete) {\n            markRootSuspended$1(root2, lanes);\n          } else {\n            var renderWasConcurrent = !includesBlockingLane(root2, lanes);\n            var finishedWork = root2.current.alternate;\n            if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {\n              exitStatus = renderRootSync(root2, lanes);\n              if (exitStatus === RootErrored) {\n                var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);\n                if (_errorRetryLanes !== NoLanes) {\n                  lanes = _errorRetryLanes;\n                  exitStatus = recoverFromConcurrentError(root2, _errorRetryLanes);\n                }\n              }\n              if (exitStatus === RootFatalErrored) {\n                var _fatalError = workInProgressRootFatalError;\n                prepareFreshStack(root2, NoLanes);\n                markRootSuspended$1(root2, lanes);\n                ensureRootIsScheduled(root2, now());\n                throw _fatalError;\n              }\n            }\n            root2.finishedWork = finishedWork;\n            root2.finishedLanes = lanes;\n            finishConcurrentRender(root2, exitStatus, lanes);\n          }\n        }\n        ensureRootIsScheduled(root2, now());\n        if (root2.callbackNode === originalCallbackNode) {\n          return performConcurrentWorkOnRoot.bind(null, root2);\n        }\n        return null;\n      }\n      function recoverFromConcurrentError(root2, errorRetryLanes) {\n        var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;\n        if (isRootDehydrated(root2)) {\n          var rootWorkInProgress = prepareFreshStack(root2, errorRetryLanes);\n          rootWorkInProgress.flags |= ForceClientRender;\n          {\n            errorHydratingContainer(root2.containerInfo);\n          }\n        }\n        var exitStatus = renderRootSync(root2, errorRetryLanes);\n        if (exitStatus !== RootErrored) {\n          var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;\n          workInProgressRootRecoverableErrors = errorsFromFirstAttempt;\n          if (errorsFromSecondAttempt !== null) {\n            queueRecoverableErrors(errorsFromSecondAttempt);\n          }\n        }\n        return exitStatus;\n      }\n      function queueRecoverableErrors(errors) {\n        if (workInProgressRootRecoverableErrors === null) {\n          workInProgressRootRecoverableErrors = errors;\n        } else {\n          workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);\n        }\n      }\n      function finishConcurrentRender(root2, exitStatus, lanes) {\n        switch (exitStatus) {\n          case RootInProgress:\n          case RootFatalErrored: {\n            throw new Error(\"Root did not complete. This is a bug in React.\");\n          }\n          case RootErrored: {\n            commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);\n            break;\n          }\n          case RootSuspended: {\n            markRootSuspended$1(root2, lanes);\n            if (includesOnlyRetries(lanes) && !shouldForceFlushFallbacksInDEV()) {\n              var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();\n              if (msUntilTimeout > 10) {\n                var nextLanes = getNextLanes(root2, NoLanes);\n                if (nextLanes !== NoLanes) {\n                  break;\n                }\n                var suspendedLanes = root2.suspendedLanes;\n                if (!isSubsetOfLanes(suspendedLanes, lanes)) {\n                  var eventTime = requestEventTime();\n                  markRootPinged(root2, suspendedLanes);\n                  break;\n                }\n                root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);\n                break;\n              }\n            }\n            commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);\n            break;\n          }\n          case RootSuspendedWithDelay: {\n            markRootSuspended$1(root2, lanes);\n            if (includesOnlyTransitions(lanes)) {\n              break;\n            }\n            if (!shouldForceFlushFallbacksInDEV()) {\n              var mostRecentEventTime = getMostRecentEventTime(root2, lanes);\n              var eventTimeMs = mostRecentEventTime;\n              var timeElapsedMs = now() - eventTimeMs;\n              var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;\n              if (_msUntilTimeout > 10) {\n                root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2, workInProgressRootRecoverableErrors, workInProgressTransitions), _msUntilTimeout);\n                break;\n              }\n            }\n            commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);\n            break;\n          }\n          case RootCompleted: {\n            commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);\n            break;\n          }\n          default: {\n            throw new Error(\"Unknown root exit status.\");\n          }\n        }\n      }\n      function isRenderConsistentWithExternalStores(finishedWork) {\n        var node = finishedWork;\n        while (true) {\n          if (node.flags & StoreConsistency) {\n            var updateQueue = node.updateQueue;\n            if (updateQueue !== null) {\n              var checks = updateQueue.stores;\n              if (checks !== null) {\n                for (var i = 0;i < checks.length; i++) {\n                  var check = checks[i];\n                  var getSnapshot = check.getSnapshot;\n                  var renderedValue = check.value;\n                  try {\n                    if (!objectIs(getSnapshot(), renderedValue)) {\n                      return false;\n                    }\n                  } catch (error2) {\n                    return false;\n                  }\n                }\n              }\n            }\n          }\n          var child = node.child;\n          if (node.subtreeFlags & StoreConsistency && child !== null) {\n            child.return = node;\n            node = child;\n            continue;\n          }\n          if (node === finishedWork) {\n            return true;\n          }\n          while (node.sibling === null) {\n            if (node.return === null || node.return === finishedWork) {\n              return true;\n            }\n            node = node.return;\n          }\n          node.sibling.return = node.return;\n          node = node.sibling;\n        }\n        return true;\n      }\n      function markRootSuspended$1(root2, suspendedLanes) {\n        suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\n        suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);\n        markRootSuspended(root2, suspendedLanes);\n      }\n      function performSyncWorkOnRoot(root2) {\n        {\n          syncNestedUpdateFlag();\n        }\n        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n          throw new Error(\"Should not already be working.\");\n        }\n        flushPassiveEffects();\n        var lanes = getNextLanes(root2, NoLanes);\n        if (!includesSomeLane(lanes, SyncLane)) {\n          ensureRootIsScheduled(root2, now());\n          return null;\n        }\n        var exitStatus = renderRootSync(root2, lanes);\n        if (root2.tag !== LegacyRoot && exitStatus === RootErrored) {\n          var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);\n          if (errorRetryLanes !== NoLanes) {\n            lanes = errorRetryLanes;\n            exitStatus = recoverFromConcurrentError(root2, errorRetryLanes);\n          }\n        }\n        if (exitStatus === RootFatalErrored) {\n          var fatalError = workInProgressRootFatalError;\n          prepareFreshStack(root2, NoLanes);\n          markRootSuspended$1(root2, lanes);\n          ensureRootIsScheduled(root2, now());\n          throw fatalError;\n        }\n        if (exitStatus === RootDidNotComplete) {\n          throw new Error(\"Root did not complete. This is a bug in React.\");\n        }\n        var finishedWork = root2.current.alternate;\n        root2.finishedWork = finishedWork;\n        root2.finishedLanes = lanes;\n        commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);\n        ensureRootIsScheduled(root2, now());\n        return null;\n      }\n      function flushRoot(root2, lanes) {\n        if (lanes !== NoLanes) {\n          markRootEntangled(root2, mergeLanes(lanes, SyncLane));\n          ensureRootIsScheduled(root2, now());\n          if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n            resetRenderTimer();\n            flushSyncCallbacks();\n          }\n        }\n      }\n      function batchedUpdates$1(fn, a) {\n        var prevExecutionContext = executionContext;\n        executionContext |= BatchedContext;\n        try {\n          return fn(a);\n        } finally {\n          executionContext = prevExecutionContext;\n          if (executionContext === NoContext && !ReactCurrentActQueue$1.isBatchingLegacy) {\n            resetRenderTimer();\n            flushSyncCallbacksOnlyInLegacyMode();\n          }\n        }\n      }\n      function discreteUpdates(fn, a, b, c, d) {\n        var previousPriority = getCurrentUpdatePriority();\n        var prevTransition = ReactCurrentBatchConfig$3.transition;\n        try {\n          ReactCurrentBatchConfig$3.transition = null;\n          setCurrentUpdatePriority(DiscreteEventPriority);\n          return fn(a, b, c, d);\n        } finally {\n          setCurrentUpdatePriority(previousPriority);\n          ReactCurrentBatchConfig$3.transition = prevTransition;\n          if (executionContext === NoContext) {\n            resetRenderTimer();\n          }\n        }\n      }\n      function flushSync(fn) {\n        if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {\n          flushPassiveEffects();\n        }\n        var prevExecutionContext = executionContext;\n        executionContext |= BatchedContext;\n        var prevTransition = ReactCurrentBatchConfig$3.transition;\n        var previousPriority = getCurrentUpdatePriority();\n        try {\n          ReactCurrentBatchConfig$3.transition = null;\n          setCurrentUpdatePriority(DiscreteEventPriority);\n          if (fn) {\n            return fn();\n          } else {\n            return;\n          }\n        } finally {\n          setCurrentUpdatePriority(previousPriority);\n          ReactCurrentBatchConfig$3.transition = prevTransition;\n          executionContext = prevExecutionContext;\n          if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n            flushSyncCallbacks();\n          }\n        }\n      }\n      function isAlreadyRendering() {\n        return (executionContext & (RenderContext | CommitContext)) !== NoContext;\n      }\n      function pushRenderLanes(fiber, lanes) {\n        push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);\n        subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);\n        workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);\n      }\n      function popRenderLanes(fiber) {\n        subtreeRenderLanes = subtreeRenderLanesCursor.current;\n        pop(subtreeRenderLanesCursor, fiber);\n      }\n      function prepareFreshStack(root2, lanes) {\n        root2.finishedWork = null;\n        root2.finishedLanes = NoLanes;\n        var timeoutHandle = root2.timeoutHandle;\n        if (timeoutHandle !== noTimeout) {\n          root2.timeoutHandle = noTimeout;\n          cancelTimeout(timeoutHandle);\n        }\n        if (workInProgress !== null) {\n          var interruptedWork = workInProgress.return;\n          while (interruptedWork !== null) {\n            var current2 = interruptedWork.alternate;\n            unwindInterruptedWork(current2, interruptedWork);\n            interruptedWork = interruptedWork.return;\n          }\n        }\n        workInProgressRoot = root2;\n        var rootWorkInProgress = createWorkInProgress(root2.current, null);\n        workInProgress = rootWorkInProgress;\n        workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;\n        workInProgressRootExitStatus = RootInProgress;\n        workInProgressRootFatalError = null;\n        workInProgressRootSkippedLanes = NoLanes;\n        workInProgressRootInterleavedUpdatedLanes = NoLanes;\n        workInProgressRootPingedLanes = NoLanes;\n        workInProgressRootConcurrentErrors = null;\n        workInProgressRootRecoverableErrors = null;\n        finishQueueingConcurrentUpdates();\n        {\n          ReactStrictModeWarnings.discardPendingWarnings();\n        }\n        return rootWorkInProgress;\n      }\n      function handleError(root2, thrownValue) {\n        do {\n          var erroredWork = workInProgress;\n          try {\n            resetContextDependencies();\n            resetHooksAfterThrow();\n            resetCurrentFiber();\n            ReactCurrentOwner$2.current = null;\n            if (erroredWork === null || erroredWork.return === null) {\n              workInProgressRootExitStatus = RootFatalErrored;\n              workInProgressRootFatalError = thrownValue;\n              workInProgress = null;\n              return;\n            }\n            if (enableProfilerTimer && erroredWork.mode & ProfileMode) {\n              stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\n            }\n            if (enableSchedulingProfiler) {\n              markComponentRenderStopped();\n              if (thrownValue !== null && typeof thrownValue === \"object\" && typeof thrownValue.then === \"function\") {\n                var wakeable = thrownValue;\n                markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);\n              } else {\n                markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);\n              }\n            }\n            throwException(root2, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);\n            completeUnitOfWork(erroredWork);\n          } catch (yetAnotherThrownValue) {\n            thrownValue = yetAnotherThrownValue;\n            if (workInProgress === erroredWork && erroredWork !== null) {\n              erroredWork = erroredWork.return;\n              workInProgress = erroredWork;\n            } else {\n              erroredWork = workInProgress;\n            }\n            continue;\n          }\n          return;\n        } while (true);\n      }\n      function pushDispatcher() {\n        var prevDispatcher = ReactCurrentDispatcher$2.current;\n        ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;\n        if (prevDispatcher === null) {\n          return ContextOnlyDispatcher;\n        } else {\n          return prevDispatcher;\n        }\n      }\n      function popDispatcher(prevDispatcher) {\n        ReactCurrentDispatcher$2.current = prevDispatcher;\n      }\n      function markCommitTimeOfFallback() {\n        globalMostRecentFallbackTime = now();\n      }\n      function markSkippedUpdateLanes(lane) {\n        workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);\n      }\n      function renderDidSuspend() {\n        if (workInProgressRootExitStatus === RootInProgress) {\n          workInProgressRootExitStatus = RootSuspended;\n        }\n      }\n      function renderDidSuspendDelayIfPossible() {\n        if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {\n          workInProgressRootExitStatus = RootSuspendedWithDelay;\n        }\n        if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {\n          markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);\n        }\n      }\n      function renderDidError(error2) {\n        if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {\n          workInProgressRootExitStatus = RootErrored;\n        }\n        if (workInProgressRootConcurrentErrors === null) {\n          workInProgressRootConcurrentErrors = [error2];\n        } else {\n          workInProgressRootConcurrentErrors.push(error2);\n        }\n      }\n      function renderHasNotSuspendedYet() {\n        return workInProgressRootExitStatus === RootInProgress;\n      }\n      function renderRootSync(root2, lanes) {\n        var prevExecutionContext = executionContext;\n        executionContext |= RenderContext;\n        var prevDispatcher = pushDispatcher();\n        if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {\n          {\n            if (isDevToolsPresent) {\n              var memoizedUpdaters = root2.memoizedUpdaters;\n              if (memoizedUpdaters.size > 0) {\n                restorePendingUpdaters(root2, workInProgressRootRenderLanes);\n                memoizedUpdaters.clear();\n              }\n              movePendingFibersToMemoized(root2, lanes);\n            }\n          }\n          workInProgressTransitions = getTransitionsForLanes();\n          prepareFreshStack(root2, lanes);\n        }\n        {\n          markRenderStarted(lanes);\n        }\n        do {\n          try {\n            workLoopSync();\n            break;\n          } catch (thrownValue) {\n            handleError(root2, thrownValue);\n          }\n        } while (true);\n        resetContextDependencies();\n        executionContext = prevExecutionContext;\n        popDispatcher(prevDispatcher);\n        if (workInProgress !== null) {\n          throw new Error(\"Cannot commit an incomplete root. This error is likely caused by a \" + \"bug in React. Please file an issue.\");\n        }\n        {\n          markRenderStopped();\n        }\n        workInProgressRoot = null;\n        workInProgressRootRenderLanes = NoLanes;\n        return workInProgressRootExitStatus;\n      }\n      function workLoopSync() {\n        while (workInProgress !== null) {\n          performUnitOfWork(workInProgress);\n        }\n      }\n      function renderRootConcurrent(root2, lanes) {\n        var prevExecutionContext = executionContext;\n        executionContext |= RenderContext;\n        var prevDispatcher = pushDispatcher();\n        if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {\n          {\n            if (isDevToolsPresent) {\n              var memoizedUpdaters = root2.memoizedUpdaters;\n              if (memoizedUpdaters.size > 0) {\n                restorePendingUpdaters(root2, workInProgressRootRenderLanes);\n                memoizedUpdaters.clear();\n              }\n              movePendingFibersToMemoized(root2, lanes);\n            }\n          }\n          workInProgressTransitions = getTransitionsForLanes();\n          resetRenderTimer();\n          prepareFreshStack(root2, lanes);\n        }\n        {\n          markRenderStarted(lanes);\n        }\n        do {\n          try {\n            workLoopConcurrent();\n            break;\n          } catch (thrownValue) {\n            handleError(root2, thrownValue);\n          }\n        } while (true);\n        resetContextDependencies();\n        popDispatcher(prevDispatcher);\n        executionContext = prevExecutionContext;\n        if (workInProgress !== null) {\n          {\n            markRenderYielded();\n          }\n          return RootInProgress;\n        } else {\n          {\n            markRenderStopped();\n          }\n          workInProgressRoot = null;\n          workInProgressRootRenderLanes = NoLanes;\n          return workInProgressRootExitStatus;\n        }\n      }\n      function workLoopConcurrent() {\n        while (workInProgress !== null && !shouldYield()) {\n          performUnitOfWork(workInProgress);\n        }\n      }\n      function performUnitOfWork(unitOfWork) {\n        var current2 = unitOfWork.alternate;\n        setCurrentFiber(unitOfWork);\n        var next;\n        if ((unitOfWork.mode & ProfileMode) !== NoMode) {\n          startProfilerTimer(unitOfWork);\n          next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);\n          stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n        } else {\n          next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);\n        }\n        resetCurrentFiber();\n        unitOfWork.memoizedProps = unitOfWork.pendingProps;\n        if (next === null) {\n          completeUnitOfWork(unitOfWork);\n        } else {\n          workInProgress = next;\n        }\n        ReactCurrentOwner$2.current = null;\n      }\n      function completeUnitOfWork(unitOfWork) {\n        var completedWork = unitOfWork;\n        do {\n          var current2 = completedWork.alternate;\n          var returnFiber = completedWork.return;\n          if ((completedWork.flags & Incomplete) === NoFlags) {\n            setCurrentFiber(completedWork);\n            var next = undefined;\n            if ((completedWork.mode & ProfileMode) === NoMode) {\n              next = completeWork(current2, completedWork, subtreeRenderLanes);\n            } else {\n              startProfilerTimer(completedWork);\n              next = completeWork(current2, completedWork, subtreeRenderLanes);\n              stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\n            }\n            resetCurrentFiber();\n            if (next !== null) {\n              workInProgress = next;\n              return;\n            }\n          } else {\n            var _next = unwindWork(current2, completedWork);\n            if (_next !== null) {\n              _next.flags &= HostEffectMask;\n              workInProgress = _next;\n              return;\n            }\n            if ((completedWork.mode & ProfileMode) !== NoMode) {\n              stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\n              var actualDuration = completedWork.actualDuration;\n              var child = completedWork.child;\n              while (child !== null) {\n                actualDuration += child.actualDuration;\n                child = child.sibling;\n              }\n              completedWork.actualDuration = actualDuration;\n            }\n            if (returnFiber !== null) {\n              returnFiber.flags |= Incomplete;\n              returnFiber.subtreeFlags = NoFlags;\n              returnFiber.deletions = null;\n            } else {\n              workInProgressRootExitStatus = RootDidNotComplete;\n              workInProgress = null;\n              return;\n            }\n          }\n          var siblingFiber = completedWork.sibling;\n          if (siblingFiber !== null) {\n            workInProgress = siblingFiber;\n            return;\n          }\n          completedWork = returnFiber;\n          workInProgress = completedWork;\n        } while (completedWork !== null);\n        if (workInProgressRootExitStatus === RootInProgress) {\n          workInProgressRootExitStatus = RootCompleted;\n        }\n      }\n      function commitRoot(root2, recoverableErrors, transitions) {\n        var previousUpdateLanePriority = getCurrentUpdatePriority();\n        var prevTransition = ReactCurrentBatchConfig$3.transition;\n        try {\n          ReactCurrentBatchConfig$3.transition = null;\n          setCurrentUpdatePriority(DiscreteEventPriority);\n          commitRootImpl(root2, recoverableErrors, transitions, previousUpdateLanePriority);\n        } finally {\n          ReactCurrentBatchConfig$3.transition = prevTransition;\n          setCurrentUpdatePriority(previousUpdateLanePriority);\n        }\n        return null;\n      }\n      function commitRootImpl(root2, recoverableErrors, transitions, renderPriorityLevel) {\n        do {\n          flushPassiveEffects();\n        } while (rootWithPendingPassiveEffects !== null);\n        flushRenderPhaseStrictModeWarningsInDEV();\n        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n          throw new Error(\"Should not already be working.\");\n        }\n        var finishedWork = root2.finishedWork;\n        var lanes = root2.finishedLanes;\n        {\n          markCommitStarted(lanes);\n        }\n        if (finishedWork === null) {\n          {\n            markCommitStopped();\n          }\n          return null;\n        } else {\n          {\n            if (lanes === NoLanes) {\n              error(\"root.finishedLanes should not be empty during a commit. This is a \" + \"bug in React.\");\n            }\n          }\n        }\n        root2.finishedWork = null;\n        root2.finishedLanes = NoLanes;\n        if (finishedWork === root2.current) {\n          throw new Error(\"Cannot commit the same tree as before. This error is likely caused by \" + \"a bug in React. Please file an issue.\");\n        }\n        root2.callbackNode = null;\n        root2.callbackPriority = NoLane;\n        var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\n        markRootFinished(root2, remainingLanes);\n        if (root2 === workInProgressRoot) {\n          workInProgressRoot = null;\n          workInProgress = null;\n          workInProgressRootRenderLanes = NoLanes;\n        }\n        if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {\n          if (!rootDoesHavePassiveEffects) {\n            rootDoesHavePassiveEffects = true;\n            pendingPassiveTransitions = transitions;\n            scheduleCallback$1(NormalPriority, function() {\n              flushPassiveEffects();\n              return null;\n            });\n          }\n        }\n        var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;\n        var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;\n        if (subtreeHasEffects || rootHasEffect) {\n          var prevTransition = ReactCurrentBatchConfig$3.transition;\n          ReactCurrentBatchConfig$3.transition = null;\n          var previousPriority = getCurrentUpdatePriority();\n          setCurrentUpdatePriority(DiscreteEventPriority);\n          var prevExecutionContext = executionContext;\n          executionContext |= CommitContext;\n          ReactCurrentOwner$2.current = null;\n          var shouldFireAfterActiveInstanceBlur2 = commitBeforeMutationEffects(root2, finishedWork);\n          {\n            recordCommitTime();\n          }\n          commitMutationEffects(root2, finishedWork, lanes);\n          resetAfterCommit(root2.containerInfo);\n          root2.current = finishedWork;\n          {\n            markLayoutEffectsStarted(lanes);\n          }\n          commitLayoutEffects(finishedWork, root2, lanes);\n          {\n            markLayoutEffectsStopped();\n          }\n          requestPaint();\n          executionContext = prevExecutionContext;\n          setCurrentUpdatePriority(previousPriority);\n          ReactCurrentBatchConfig$3.transition = prevTransition;\n        } else {\n          root2.current = finishedWork;\n          {\n            recordCommitTime();\n          }\n        }\n        var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\n        if (rootDoesHavePassiveEffects) {\n          rootDoesHavePassiveEffects = false;\n          rootWithPendingPassiveEffects = root2;\n          pendingPassiveEffectsLanes = lanes;\n        } else {\n          {\n            nestedPassiveUpdateCount = 0;\n            rootWithPassiveNestedUpdates = null;\n          }\n        }\n        remainingLanes = root2.pendingLanes;\n        if (remainingLanes === NoLanes) {\n          legacyErrorBoundariesThatAlreadyFailed = null;\n        }\n        {\n          if (!rootDidHavePassiveEffects) {\n            commitDoubleInvokeEffectsInDEV(root2.current, false);\n          }\n        }\n        onCommitRoot(finishedWork.stateNode, renderPriorityLevel);\n        {\n          if (isDevToolsPresent) {\n            root2.memoizedUpdaters.clear();\n          }\n        }\n        {\n          onCommitRoot$1();\n        }\n        ensureRootIsScheduled(root2, now());\n        if (recoverableErrors !== null) {\n          var onRecoverableError = root2.onRecoverableError;\n          for (var i = 0;i < recoverableErrors.length; i++) {\n            var recoverableError = recoverableErrors[i];\n            var componentStack = recoverableError.stack;\n            var digest = recoverableError.digest;\n            onRecoverableError(recoverableError.value, {\n              componentStack,\n              digest\n            });\n          }\n        }\n        if (hasUncaughtError) {\n          hasUncaughtError = false;\n          var error$1 = firstUncaughtError;\n          firstUncaughtError = null;\n          throw error$1;\n        }\n        if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root2.tag !== LegacyRoot) {\n          flushPassiveEffects();\n        }\n        remainingLanes = root2.pendingLanes;\n        if (includesSomeLane(remainingLanes, SyncLane)) {\n          {\n            markNestedUpdateScheduled();\n          }\n          if (root2 === rootWithNestedUpdates) {\n            nestedUpdateCount++;\n          } else {\n            nestedUpdateCount = 0;\n            rootWithNestedUpdates = root2;\n          }\n        } else {\n          nestedUpdateCount = 0;\n        }\n        flushSyncCallbacks();\n        {\n          markCommitStopped();\n        }\n        return null;\n      }\n      function flushPassiveEffects() {\n        if (rootWithPendingPassiveEffects !== null) {\n          var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);\n          var priority = lowerEventPriority(DefaultEventPriority, renderPriority);\n          var prevTransition = ReactCurrentBatchConfig$3.transition;\n          var previousPriority = getCurrentUpdatePriority();\n          try {\n            ReactCurrentBatchConfig$3.transition = null;\n            setCurrentUpdatePriority(priority);\n            return flushPassiveEffectsImpl();\n          } finally {\n            setCurrentUpdatePriority(previousPriority);\n            ReactCurrentBatchConfig$3.transition = prevTransition;\n          }\n        }\n        return false;\n      }\n      function enqueuePendingPassiveProfilerEffect(fiber) {\n        {\n          pendingPassiveProfilerEffects.push(fiber);\n          if (!rootDoesHavePassiveEffects) {\n            rootDoesHavePassiveEffects = true;\n            scheduleCallback$1(NormalPriority, function() {\n              flushPassiveEffects();\n              return null;\n            });\n          }\n        }\n      }\n      function flushPassiveEffectsImpl() {\n        if (rootWithPendingPassiveEffects === null) {\n          return false;\n        }\n        var transitions = pendingPassiveTransitions;\n        pendingPassiveTransitions = null;\n        var root2 = rootWithPendingPassiveEffects;\n        var lanes = pendingPassiveEffectsLanes;\n        rootWithPendingPassiveEffects = null;\n        pendingPassiveEffectsLanes = NoLanes;\n        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n          throw new Error(\"Cannot flush passive effects while already rendering.\");\n        }\n        {\n          isFlushingPassiveEffects = true;\n          didScheduleUpdateDuringPassiveEffects = false;\n        }\n        {\n          markPassiveEffectsStarted(lanes);\n        }\n        var prevExecutionContext = executionContext;\n        executionContext |= CommitContext;\n        commitPassiveUnmountEffects(root2.current);\n        commitPassiveMountEffects(root2, root2.current, lanes, transitions);\n        {\n          var profilerEffects = pendingPassiveProfilerEffects;\n          pendingPassiveProfilerEffects = [];\n          for (var i = 0;i < profilerEffects.length; i++) {\n            var _fiber = profilerEffects[i];\n            commitPassiveEffectDurations(root2, _fiber);\n          }\n        }\n        {\n          markPassiveEffectsStopped();\n        }\n        {\n          commitDoubleInvokeEffectsInDEV(root2.current, true);\n        }\n        executionContext = prevExecutionContext;\n        flushSyncCallbacks();\n        {\n          if (didScheduleUpdateDuringPassiveEffects) {\n            if (root2 === rootWithPassiveNestedUpdates) {\n              nestedPassiveUpdateCount++;\n            } else {\n              nestedPassiveUpdateCount = 0;\n              rootWithPassiveNestedUpdates = root2;\n            }\n          } else {\n            nestedPassiveUpdateCount = 0;\n          }\n          isFlushingPassiveEffects = false;\n          didScheduleUpdateDuringPassiveEffects = false;\n        }\n        onPostCommitRoot(root2);\n        {\n          var stateNode = root2.current.stateNode;\n          stateNode.effectDuration = 0;\n          stateNode.passiveEffectDuration = 0;\n        }\n        return true;\n      }\n      function isAlreadyFailedLegacyErrorBoundary(instance) {\n        return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);\n      }\n      function markLegacyErrorBoundaryAsFailed(instance) {\n        if (legacyErrorBoundariesThatAlreadyFailed === null) {\n          legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\n        } else {\n          legacyErrorBoundariesThatAlreadyFailed.add(instance);\n        }\n      }\n      function prepareToThrowUncaughtError(error2) {\n        if (!hasUncaughtError) {\n          hasUncaughtError = true;\n          firstUncaughtError = error2;\n        }\n      }\n      var onUncaughtError = prepareToThrowUncaughtError;\n      function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error2) {\n        var errorInfo = createCapturedValueAtFiber(error2, sourceFiber);\n        var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);\n        var root2 = enqueueUpdate(rootFiber, update, SyncLane);\n        var eventTime = requestEventTime();\n        if (root2 !== null) {\n          markRootUpdated(root2, SyncLane, eventTime);\n          ensureRootIsScheduled(root2, eventTime);\n        }\n      }\n      function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {\n        {\n          reportUncaughtErrorInDEV(error$1);\n          setIsRunningInsertionEffect(false);\n        }\n        if (sourceFiber.tag === HostRoot) {\n          captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);\n          return;\n        }\n        var fiber = null;\n        {\n          fiber = nearestMountedAncestor;\n        }\n        while (fiber !== null) {\n          if (fiber.tag === HostRoot) {\n            captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);\n            return;\n          } else if (fiber.tag === ClassComponent) {\n            var ctor = fiber.type;\n            var instance = fiber.stateNode;\n            if (typeof ctor.getDerivedStateFromError === \"function\" || typeof instance.componentDidCatch === \"function\" && !isAlreadyFailedLegacyErrorBoundary(instance)) {\n              var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);\n              var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);\n              var root2 = enqueueUpdate(fiber, update, SyncLane);\n              var eventTime = requestEventTime();\n              if (root2 !== null) {\n                markRootUpdated(root2, SyncLane, eventTime);\n                ensureRootIsScheduled(root2, eventTime);\n              }\n              return;\n            }\n          }\n          fiber = fiber.return;\n        }\n        {\n          error(\"Internal React error: Attempted to capture a commit phase error \" + \"inside a detached tree. This indicates a bug in React. Likely \" + \"causes include deleting the same fiber more than once, committing an \" + `already-finished tree, or an inconsistent return pointer.\n\n` + `Error message:\n\n%s`, error$1);\n        }\n      }\n      function pingSuspendedRoot(root2, wakeable, pingedLanes) {\n        var pingCache = root2.pingCache;\n        if (pingCache !== null) {\n          pingCache.delete(wakeable);\n        }\n        var eventTime = requestEventTime();\n        markRootPinged(root2, pingedLanes);\n        warnIfSuspenseResolutionNotWrappedWithActDEV(root2);\n        if (workInProgressRoot === root2 && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {\n          if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {\n            prepareFreshStack(root2, NoLanes);\n          } else {\n            workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);\n          }\n        }\n        ensureRootIsScheduled(root2, eventTime);\n      }\n      function retryTimedOutBoundary(boundaryFiber, retryLane) {\n        if (retryLane === NoLane) {\n          retryLane = requestRetryLane(boundaryFiber);\n        }\n        var eventTime = requestEventTime();\n        var root2 = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);\n        if (root2 !== null) {\n          markRootUpdated(root2, retryLane, eventTime);\n          ensureRootIsScheduled(root2, eventTime);\n        }\n      }\n      function retryDehydratedSuspenseBoundary(boundaryFiber) {\n        var suspenseState = boundaryFiber.memoizedState;\n        var retryLane = NoLane;\n        if (suspenseState !== null) {\n          retryLane = suspenseState.retryLane;\n        }\n        retryTimedOutBoundary(boundaryFiber, retryLane);\n      }\n      function resolveRetryWakeable(boundaryFiber, wakeable) {\n        var retryLane = NoLane;\n        var retryCache;\n        switch (boundaryFiber.tag) {\n          case SuspenseComponent:\n            retryCache = boundaryFiber.stateNode;\n            var suspenseState = boundaryFiber.memoizedState;\n            if (suspenseState !== null) {\n              retryLane = suspenseState.retryLane;\n            }\n            break;\n          case SuspenseListComponent:\n            retryCache = boundaryFiber.stateNode;\n            break;\n          default:\n            throw new Error(\"Pinged unknown suspense boundary type. \" + \"This is probably a bug in React.\");\n        }\n        if (retryCache !== null) {\n          retryCache.delete(wakeable);\n        }\n        retryTimedOutBoundary(boundaryFiber, retryLane);\n      }\n      function jnd(timeElapsed) {\n        return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3000 ? 3000 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;\n      }\n      function checkForNestedUpdates() {\n        if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n          nestedUpdateCount = 0;\n          rootWithNestedUpdates = null;\n          throw new Error(\"Maximum update depth exceeded. This can happen when a component \" + \"repeatedly calls setState inside componentWillUpdate or \" + \"componentDidUpdate. React limits the number of nested updates to \" + \"prevent infinite loops.\");\n        }\n        {\n          if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\n            nestedPassiveUpdateCount = 0;\n            rootWithPassiveNestedUpdates = null;\n            error(\"Maximum update depth exceeded. This can happen when a component \" + \"calls setState inside useEffect, but useEffect either doesn't \" + \"have a dependency array, or one of the dependencies changes on \" + \"every render.\");\n          }\n        }\n      }\n      function flushRenderPhaseStrictModeWarningsInDEV() {\n        {\n          ReactStrictModeWarnings.flushLegacyContextWarning();\n          {\n            ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n          }\n        }\n      }\n      function commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {\n        {\n          setCurrentFiber(fiber);\n          invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);\n          if (hasPassiveEffects) {\n            invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);\n          }\n          invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);\n          if (hasPassiveEffects) {\n            invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);\n          }\n          resetCurrentFiber();\n        }\n      }\n      function invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {\n        {\n          var current2 = firstChild;\n          var subtreeRoot = null;\n          while (current2 !== null) {\n            var primarySubtreeFlag = current2.subtreeFlags & fiberFlags;\n            if (current2 !== subtreeRoot && current2.child !== null && primarySubtreeFlag !== NoFlags) {\n              current2 = current2.child;\n            } else {\n              if ((current2.flags & fiberFlags) !== NoFlags) {\n                invokeEffectFn(current2);\n              }\n              if (current2.sibling !== null) {\n                current2 = current2.sibling;\n              } else {\n                current2 = subtreeRoot = current2.return;\n              }\n            }\n          }\n        }\n      }\n      var didWarnStateUpdateForNotYetMountedComponent = null;\n      function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\n        {\n          if ((executionContext & RenderContext) !== NoContext) {\n            return;\n          }\n          if (!(fiber.mode & ConcurrentMode)) {\n            return;\n          }\n          var tag = fiber.tag;\n          if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {\n            return;\n          }\n          var componentName = getComponentNameFromFiber(fiber) || \"ReactComponent\";\n          if (didWarnStateUpdateForNotYetMountedComponent !== null) {\n            if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\n              return;\n            }\n            didWarnStateUpdateForNotYetMountedComponent.add(componentName);\n          } else {\n            didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);\n          }\n          var previousFiber = current;\n          try {\n            setCurrentFiber(fiber);\n            error(\"Can't perform a React state update on a component that hasn't mounted yet. \" + \"This indicates that you have a side-effect in your render function that \" + \"asynchronously later calls tries to update the component. Move this work to \" + \"useEffect instead.\");\n          } finally {\n            if (previousFiber) {\n              setCurrentFiber(fiber);\n            } else {\n              resetCurrentFiber();\n            }\n          }\n        }\n      }\n      var beginWork$1;\n      {\n        var dummyFiber = null;\n        beginWork$1 = function(current2, unitOfWork, lanes) {\n          var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);\n          try {\n            return beginWork(current2, unitOfWork, lanes);\n          } catch (originalError) {\n            if (didSuspendOrErrorWhileHydratingDEV() || originalError !== null && typeof originalError === \"object\" && typeof originalError.then === \"function\") {\n              throw originalError;\n            }\n            resetContextDependencies();\n            resetHooksAfterThrow();\n            unwindInterruptedWork(current2, unitOfWork);\n            assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\n            if (unitOfWork.mode & ProfileMode) {\n              startProfilerTimer(unitOfWork);\n            }\n            invokeGuardedCallback(null, beginWork, null, current2, unitOfWork, lanes);\n            if (hasCaughtError()) {\n              var replayError = clearCaughtError();\n              if (typeof replayError === \"object\" && replayError !== null && replayError._suppressLogging && typeof originalError === \"object\" && originalError !== null && !originalError._suppressLogging) {\n                originalError._suppressLogging = true;\n              }\n            }\n            throw originalError;\n          }\n        };\n      }\n      var didWarnAboutUpdateInRender = false;\n      var didWarnAboutUpdateInRenderForAnotherComponent;\n      {\n        didWarnAboutUpdateInRenderForAnotherComponent = new Set;\n      }\n      function warnAboutRenderPhaseUpdatesInDEV(fiber) {\n        {\n          if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {\n            switch (fiber.tag) {\n              case FunctionComponent:\n              case ForwardRef:\n              case SimpleMemoComponent: {\n                var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || \"Unknown\";\n                var dedupeKey = renderingComponentName;\n                if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\n                  didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\n                  var setStateComponentName = getComponentNameFromFiber(fiber) || \"Unknown\";\n                  error(\"Cannot update a component (`%s`) while rendering a \" + \"different component (`%s`). To locate the bad setState() call inside `%s`, \" + \"follow the stack trace as described in https://reactjs.org/link/setstate-in-render\", setStateComponentName, renderingComponentName, renderingComponentName);\n                }\n                break;\n              }\n              case ClassComponent: {\n                if (!didWarnAboutUpdateInRender) {\n                  error(\"Cannot update during an existing state transition (such as \" + \"within `render`). Render methods should be a pure \" + \"function of props and state.\");\n                  didWarnAboutUpdateInRender = true;\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n      function restorePendingUpdaters(root2, lanes) {\n        {\n          if (isDevToolsPresent) {\n            var memoizedUpdaters = root2.memoizedUpdaters;\n            memoizedUpdaters.forEach(function(schedulingFiber) {\n              addFiberToLanesMap(root2, schedulingFiber, lanes);\n            });\n          }\n        }\n      }\n      var fakeActCallbackNode = {};\n      function scheduleCallback$1(priorityLevel, callback) {\n        {\n          var actQueue = ReactCurrentActQueue$1.current;\n          if (actQueue !== null) {\n            actQueue.push(callback);\n            return fakeActCallbackNode;\n          } else {\n            return scheduleCallback(priorityLevel, callback);\n          }\n        }\n      }\n      function cancelCallback$1(callbackNode) {\n        if (callbackNode === fakeActCallbackNode) {\n          return;\n        }\n        return cancelCallback(callbackNode);\n      }\n      function shouldForceFlushFallbacksInDEV() {\n        return ReactCurrentActQueue$1.current !== null;\n      }\n      function warnIfUpdatesNotWrappedWithActDEV(fiber) {\n        {\n          if (fiber.mode & ConcurrentMode) {\n            if (!isConcurrentActEnvironment()) {\n              return;\n            }\n          } else {\n            if (!isLegacyActEnvironment()) {\n              return;\n            }\n            if (executionContext !== NoContext) {\n              return;\n            }\n            if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {\n              return;\n            }\n          }\n          if (ReactCurrentActQueue$1.current === null) {\n            var previousFiber = current;\n            try {\n              setCurrentFiber(fiber);\n              error(`An update to %s inside a test was not wrapped in act(...).\n\n` + \"When testing, code that causes React state updates should be \" + `wrapped into act(...):\n\n` + `act(() => {\n` + `  /* fire events that update state */\n` + `});\n` + `/* assert on the output */\n\n` + \"This ensures that you're testing the behavior the user would see \" + \"in the browser.\" + \" Learn more at https://reactjs.org/link/wrap-tests-with-act\", getComponentNameFromFiber(fiber));\n            } finally {\n              if (previousFiber) {\n                setCurrentFiber(fiber);\n              } else {\n                resetCurrentFiber();\n              }\n            }\n          }\n        }\n      }\n      function warnIfSuspenseResolutionNotWrappedWithActDEV(root2) {\n        {\n          if (root2.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null) {\n            error(\"A suspended resource finished loading inside a test, but the event \" + `was not wrapped in act(...).\n\n` + \"When testing, code that resolves suspended data should be wrapped \" + `into act(...):\n\n` + `act(() => {\n` + `  /* finish loading suspended data */\n` + `});\n` + `/* assert on the output */\n\n` + \"This ensures that you're testing the behavior the user would see \" + \"in the browser.\" + \" Learn more at https://reactjs.org/link/wrap-tests-with-act\");\n          }\n        }\n      }\n      function setIsRunningInsertionEffect(isRunning) {\n        {\n          isRunningInsertionEffect = isRunning;\n        }\n      }\n      var resolveFamily = null;\n      var failedBoundaries = null;\n      var setRefreshHandler = function(handler) {\n        {\n          resolveFamily = handler;\n        }\n      };\n      function resolveFunctionForHotReloading(type) {\n        {\n          if (resolveFamily === null) {\n            return type;\n          }\n          var family = resolveFamily(type);\n          if (family === undefined) {\n            return type;\n          }\n          return family.current;\n        }\n      }\n      function resolveClassForHotReloading(type) {\n        return resolveFunctionForHotReloading(type);\n      }\n      function resolveForwardRefForHotReloading(type) {\n        {\n          if (resolveFamily === null) {\n            return type;\n          }\n          var family = resolveFamily(type);\n          if (family === undefined) {\n            if (type !== null && type !== undefined && typeof type.render === \"function\") {\n              var currentRender = resolveFunctionForHotReloading(type.render);\n              if (type.render !== currentRender) {\n                var syntheticType = {\n                  $$typeof: REACT_FORWARD_REF_TYPE,\n                  render: currentRender\n                };\n                if (type.displayName !== undefined) {\n                  syntheticType.displayName = type.displayName;\n                }\n                return syntheticType;\n              }\n            }\n            return type;\n          }\n          return family.current;\n        }\n      }\n      function isCompatibleFamilyForHotReloading(fiber, element) {\n        {\n          if (resolveFamily === null) {\n            return false;\n          }\n          var prevType = fiber.elementType;\n          var nextType = element.type;\n          var needsCompareFamilies = false;\n          var $$typeofNextType = typeof nextType === \"object\" && nextType !== null ? nextType.$$typeof : null;\n          switch (fiber.tag) {\n            case ClassComponent: {\n              if (typeof nextType === \"function\") {\n                needsCompareFamilies = true;\n              }\n              break;\n            }\n            case FunctionComponent: {\n              if (typeof nextType === \"function\") {\n                needsCompareFamilies = true;\n              } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n                needsCompareFamilies = true;\n              }\n              break;\n            }\n            case ForwardRef: {\n              if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {\n                needsCompareFamilies = true;\n              } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n                needsCompareFamilies = true;\n              }\n              break;\n            }\n            case MemoComponent:\n            case SimpleMemoComponent: {\n              if ($$typeofNextType === REACT_MEMO_TYPE) {\n                needsCompareFamilies = true;\n              } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n                needsCompareFamilies = true;\n              }\n              break;\n            }\n            default:\n              return false;\n          }\n          if (needsCompareFamilies) {\n            var prevFamily = resolveFamily(prevType);\n            if (prevFamily !== undefined && prevFamily === resolveFamily(nextType)) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }\n      function markFailedErrorBoundaryForHotReloading(fiber) {\n        {\n          if (resolveFamily === null) {\n            return;\n          }\n          if (typeof WeakSet !== \"function\") {\n            return;\n          }\n          if (failedBoundaries === null) {\n            failedBoundaries = new WeakSet;\n          }\n          failedBoundaries.add(fiber);\n        }\n      }\n      var scheduleRefresh = function(root2, update) {\n        {\n          if (resolveFamily === null) {\n            return;\n          }\n          var { staleFamilies, updatedFamilies } = update;\n          flushPassiveEffects();\n          flushSync(function() {\n            scheduleFibersWithFamiliesRecursively(root2.current, updatedFamilies, staleFamilies);\n          });\n        }\n      };\n      var scheduleRoot = function(root2, element) {\n        {\n          if (root2.context !== emptyContextObject) {\n            return;\n          }\n          flushPassiveEffects();\n          flushSync(function() {\n            updateContainer(element, root2, null, null);\n          });\n        }\n      };\n      function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {\n        {\n          var { alternate, child, sibling, tag, type } = fiber;\n          var candidateType = null;\n          switch (tag) {\n            case FunctionComponent:\n            case SimpleMemoComponent:\n            case ClassComponent:\n              candidateType = type;\n              break;\n            case ForwardRef:\n              candidateType = type.render;\n              break;\n          }\n          if (resolveFamily === null) {\n            throw new Error(\"Expected resolveFamily to be set during hot reload.\");\n          }\n          var needsRender = false;\n          var needsRemount = false;\n          if (candidateType !== null) {\n            var family = resolveFamily(candidateType);\n            if (family !== undefined) {\n              if (staleFamilies.has(family)) {\n                needsRemount = true;\n              } else if (updatedFamilies.has(family)) {\n                if (tag === ClassComponent) {\n                  needsRemount = true;\n                } else {\n                  needsRender = true;\n                }\n              }\n            }\n          }\n          if (failedBoundaries !== null) {\n            if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {\n              needsRemount = true;\n            }\n          }\n          if (needsRemount) {\n            fiber._debugNeedsRemount = true;\n          }\n          if (needsRemount || needsRender) {\n            var _root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n            if (_root !== null) {\n              scheduleUpdateOnFiber(_root, fiber, SyncLane, NoTimestamp);\n            }\n          }\n          if (child !== null && !needsRemount) {\n            scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);\n          }\n          if (sibling !== null) {\n            scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);\n          }\n        }\n      }\n      var findHostInstancesForRefresh = function(root2, families) {\n        {\n          var hostInstances = new Set;\n          var types = new Set(families.map(function(family) {\n            return family.current;\n          }));\n          findHostInstancesForMatchingFibersRecursively(root2.current, types, hostInstances);\n          return hostInstances;\n        }\n      };\n      function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {\n        {\n          var { child, sibling, tag, type } = fiber;\n          var candidateType = null;\n          switch (tag) {\n            case FunctionComponent:\n            case SimpleMemoComponent:\n            case ClassComponent:\n              candidateType = type;\n              break;\n            case ForwardRef:\n              candidateType = type.render;\n              break;\n          }\n          var didMatch = false;\n          if (candidateType !== null) {\n            if (types.has(candidateType)) {\n              didMatch = true;\n            }\n          }\n          if (didMatch) {\n            findHostInstancesForFiberShallowly(fiber, hostInstances);\n          } else {\n            if (child !== null) {\n              findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);\n            }\n          }\n          if (sibling !== null) {\n            findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);\n          }\n        }\n      }\n      function findHostInstancesForFiberShallowly(fiber, hostInstances) {\n        {\n          var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);\n          if (foundHostInstances) {\n            return;\n          }\n          var node = fiber;\n          while (true) {\n            switch (node.tag) {\n              case HostComponent:\n                hostInstances.add(node.stateNode);\n                return;\n              case HostPortal:\n                hostInstances.add(node.stateNode.containerInfo);\n                return;\n              case HostRoot:\n                hostInstances.add(node.stateNode.containerInfo);\n                return;\n            }\n            if (node.return === null) {\n              throw new Error(\"Expected to reach root first.\");\n            }\n            node = node.return;\n          }\n        }\n      }\n      function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {\n        {\n          var node = fiber;\n          var foundHostInstances = false;\n          while (true) {\n            if (node.tag === HostComponent) {\n              foundHostInstances = true;\n              hostInstances.add(node.stateNode);\n            } else if (node.child !== null) {\n              node.child.return = node;\n              node = node.child;\n              continue;\n            }\n            if (node === fiber) {\n              return foundHostInstances;\n            }\n            while (node.sibling === null) {\n              if (node.return === null || node.return === fiber) {\n                return foundHostInstances;\n              }\n              node = node.return;\n            }\n            node.sibling.return = node.return;\n            node = node.sibling;\n          }\n        }\n        return false;\n      }\n      var hasBadMapPolyfill;\n      {\n        hasBadMapPolyfill = false;\n        try {\n          var nonExtensibleObject = Object.preventExtensions({});\n          new Map([[nonExtensibleObject, null]]);\n          new Set([nonExtensibleObject]);\n        } catch (e) {\n          hasBadMapPolyfill = true;\n        }\n      }\n      function FiberNode(tag, pendingProps, key, mode) {\n        this.tag = tag;\n        this.key = key;\n        this.elementType = null;\n        this.type = null;\n        this.stateNode = null;\n        this.return = null;\n        this.child = null;\n        this.sibling = null;\n        this.index = 0;\n        this.ref = null;\n        this.pendingProps = pendingProps;\n        this.memoizedProps = null;\n        this.updateQueue = null;\n        this.memoizedState = null;\n        this.dependencies = null;\n        this.mode = mode;\n        this.flags = NoFlags;\n        this.subtreeFlags = NoFlags;\n        this.deletions = null;\n        this.lanes = NoLanes;\n        this.childLanes = NoLanes;\n        this.alternate = null;\n        {\n          this.actualDuration = Number.NaN;\n          this.actualStartTime = Number.NaN;\n          this.selfBaseDuration = Number.NaN;\n          this.treeBaseDuration = Number.NaN;\n          this.actualDuration = 0;\n          this.actualStartTime = -1;\n          this.selfBaseDuration = 0;\n          this.treeBaseDuration = 0;\n        }\n        {\n          this._debugSource = null;\n          this._debugOwner = null;\n          this._debugNeedsRemount = false;\n          this._debugHookTypes = null;\n          if (!hasBadMapPolyfill && typeof Object.preventExtensions === \"function\") {\n            Object.preventExtensions(this);\n          }\n        }\n      }\n      var createFiber = function(tag, pendingProps, key, mode) {\n        return new FiberNode(tag, pendingProps, key, mode);\n      };\n      function shouldConstruct$1(Component) {\n        var prototype = Component.prototype;\n        return !!(prototype && prototype.isReactComponent);\n      }\n      function isSimpleFunctionComponent(type) {\n        return typeof type === \"function\" && !shouldConstruct$1(type) && type.defaultProps === undefined;\n      }\n      function resolveLazyComponentTag(Component) {\n        if (typeof Component === \"function\") {\n          return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;\n        } else if (Component !== undefined && Component !== null) {\n          var $$typeof = Component.$$typeof;\n          if ($$typeof === REACT_FORWARD_REF_TYPE) {\n            return ForwardRef;\n          }\n          if ($$typeof === REACT_MEMO_TYPE) {\n            return MemoComponent;\n          }\n        }\n        return IndeterminateComponent;\n      }\n      function createWorkInProgress(current2, pendingProps) {\n        var workInProgress2 = current2.alternate;\n        if (workInProgress2 === null) {\n          workInProgress2 = createFiber(current2.tag, pendingProps, current2.key, current2.mode);\n          workInProgress2.elementType = current2.elementType;\n          workInProgress2.type = current2.type;\n          workInProgress2.stateNode = current2.stateNode;\n          {\n            workInProgress2._debugSource = current2._debugSource;\n            workInProgress2._debugOwner = current2._debugOwner;\n            workInProgress2._debugHookTypes = current2._debugHookTypes;\n          }\n          workInProgress2.alternate = current2;\n          current2.alternate = workInProgress2;\n        } else {\n          workInProgress2.pendingProps = pendingProps;\n          workInProgress2.type = current2.type;\n          workInProgress2.flags = NoFlags;\n          workInProgress2.subtreeFlags = NoFlags;\n          workInProgress2.deletions = null;\n          {\n            workInProgress2.actualDuration = 0;\n            workInProgress2.actualStartTime = -1;\n          }\n        }\n        workInProgress2.flags = current2.flags & StaticMask;\n        workInProgress2.childLanes = current2.childLanes;\n        workInProgress2.lanes = current2.lanes;\n        workInProgress2.child = current2.child;\n        workInProgress2.memoizedProps = current2.memoizedProps;\n        workInProgress2.memoizedState = current2.memoizedState;\n        workInProgress2.updateQueue = current2.updateQueue;\n        var currentDependencies = current2.dependencies;\n        workInProgress2.dependencies = currentDependencies === null ? null : {\n          lanes: currentDependencies.lanes,\n          firstContext: currentDependencies.firstContext\n        };\n        workInProgress2.sibling = current2.sibling;\n        workInProgress2.index = current2.index;\n        workInProgress2.ref = current2.ref;\n        {\n          workInProgress2.selfBaseDuration = current2.selfBaseDuration;\n          workInProgress2.treeBaseDuration = current2.treeBaseDuration;\n        }\n        {\n          workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;\n          switch (workInProgress2.tag) {\n            case IndeterminateComponent:\n            case FunctionComponent:\n            case SimpleMemoComponent:\n              workInProgress2.type = resolveFunctionForHotReloading(current2.type);\n              break;\n            case ClassComponent:\n              workInProgress2.type = resolveClassForHotReloading(current2.type);\n              break;\n            case ForwardRef:\n              workInProgress2.type = resolveForwardRefForHotReloading(current2.type);\n              break;\n          }\n        }\n        return workInProgress2;\n      }\n      function resetWorkInProgress(workInProgress2, renderLanes2) {\n        workInProgress2.flags &= StaticMask | Placement;\n        var current2 = workInProgress2.alternate;\n        if (current2 === null) {\n          workInProgress2.childLanes = NoLanes;\n          workInProgress2.lanes = renderLanes2;\n          workInProgress2.child = null;\n          workInProgress2.subtreeFlags = NoFlags;\n          workInProgress2.memoizedProps = null;\n          workInProgress2.memoizedState = null;\n          workInProgress2.updateQueue = null;\n          workInProgress2.dependencies = null;\n          workInProgress2.stateNode = null;\n          {\n            workInProgress2.selfBaseDuration = 0;\n            workInProgress2.treeBaseDuration = 0;\n          }\n        } else {\n          workInProgress2.childLanes = current2.childLanes;\n          workInProgress2.lanes = current2.lanes;\n          workInProgress2.child = current2.child;\n          workInProgress2.subtreeFlags = NoFlags;\n          workInProgress2.deletions = null;\n          workInProgress2.memoizedProps = current2.memoizedProps;\n          workInProgress2.memoizedState = current2.memoizedState;\n          workInProgress2.updateQueue = current2.updateQueue;\n          workInProgress2.type = current2.type;\n          var currentDependencies = current2.dependencies;\n          workInProgress2.dependencies = currentDependencies === null ? null : {\n            lanes: currentDependencies.lanes,\n            firstContext: currentDependencies.firstContext\n          };\n          {\n            workInProgress2.selfBaseDuration = current2.selfBaseDuration;\n            workInProgress2.treeBaseDuration = current2.treeBaseDuration;\n          }\n        }\n        return workInProgress2;\n      }\n      function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {\n        var mode;\n        if (tag === ConcurrentRoot) {\n          mode = ConcurrentMode;\n          if (isStrictMode === true) {\n            mode |= StrictLegacyMode;\n            {\n              mode |= StrictEffectsMode;\n            }\n          }\n        } else {\n          mode = NoMode;\n        }\n        if (isDevToolsPresent) {\n          mode |= ProfileMode;\n        }\n        return createFiber(HostRoot, null, null, mode);\n      }\n      function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {\n        var fiberTag = IndeterminateComponent;\n        var resolvedType = type;\n        if (typeof type === \"function\") {\n          if (shouldConstruct$1(type)) {\n            fiberTag = ClassComponent;\n            {\n              resolvedType = resolveClassForHotReloading(resolvedType);\n            }\n          } else {\n            {\n              resolvedType = resolveFunctionForHotReloading(resolvedType);\n            }\n          }\n        } else if (typeof type === \"string\") {\n          fiberTag = HostComponent;\n        } else {\n          getTag:\n            switch (type) {\n              case REACT_FRAGMENT_TYPE:\n                return createFiberFromFragment(pendingProps.children, mode, lanes, key);\n              case REACT_STRICT_MODE_TYPE:\n                fiberTag = Mode;\n                mode |= StrictLegacyMode;\n                if ((mode & ConcurrentMode) !== NoMode) {\n                  mode |= StrictEffectsMode;\n                }\n                break;\n              case REACT_PROFILER_TYPE:\n                return createFiberFromProfiler(pendingProps, mode, lanes, key);\n              case REACT_SUSPENSE_TYPE:\n                return createFiberFromSuspense(pendingProps, mode, lanes, key);\n              case REACT_SUSPENSE_LIST_TYPE:\n                return createFiberFromSuspenseList(pendingProps, mode, lanes, key);\n              case REACT_OFFSCREEN_TYPE:\n                return createFiberFromOffscreen(pendingProps, mode, lanes, key);\n              case REACT_LEGACY_HIDDEN_TYPE:\n              case REACT_SCOPE_TYPE:\n              case REACT_CACHE_TYPE:\n              case REACT_TRACING_MARKER_TYPE:\n              case REACT_DEBUG_TRACING_MODE_TYPE:\n              default: {\n                if (typeof type === \"object\" && type !== null) {\n                  switch (type.$$typeof) {\n                    case REACT_PROVIDER_TYPE:\n                      fiberTag = ContextProvider;\n                      break getTag;\n                    case REACT_CONTEXT_TYPE:\n                      fiberTag = ContextConsumer;\n                      break getTag;\n                    case REACT_FORWARD_REF_TYPE:\n                      fiberTag = ForwardRef;\n                      {\n                        resolvedType = resolveForwardRefForHotReloading(resolvedType);\n                      }\n                      break getTag;\n                    case REACT_MEMO_TYPE:\n                      fiberTag = MemoComponent;\n                      break getTag;\n                    case REACT_LAZY_TYPE:\n                      fiberTag = LazyComponent;\n                      resolvedType = null;\n                      break getTag;\n                  }\n                }\n                var info = \"\";\n                {\n                  if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                    info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and \" + \"named imports.\";\n                  }\n                  var ownerName = owner ? getComponentNameFromFiber(owner) : null;\n                  if (ownerName) {\n                    info += `\n\nCheck the render method of \\`` + ownerName + \"`.\";\n                  }\n                }\n                throw new Error(\"Element type is invalid: expected a string (for built-in \" + \"components) or a class/function (for composite components) \" + (\"but got: \" + (type == null ? type : typeof type) + \".\" + info));\n              }\n            }\n        }\n        var fiber = createFiber(fiberTag, pendingProps, key, mode);\n        fiber.elementType = type;\n        fiber.type = resolvedType;\n        fiber.lanes = lanes;\n        {\n          fiber._debugOwner = owner;\n        }\n        return fiber;\n      }\n      function createFiberFromElement(element, mode, lanes) {\n        var owner = null;\n        {\n          owner = element._owner;\n        }\n        var type = element.type;\n        var key = element.key;\n        var pendingProps = element.props;\n        var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);\n        {\n          fiber._debugSource = element._source;\n          fiber._debugOwner = element._owner;\n        }\n        return fiber;\n      }\n      function createFiberFromFragment(elements, mode, lanes, key) {\n        var fiber = createFiber(Fragment, elements, key, mode);\n        fiber.lanes = lanes;\n        return fiber;\n      }\n      function createFiberFromProfiler(pendingProps, mode, lanes, key) {\n        {\n          if (typeof pendingProps.id !== \"string\") {\n            error('Profiler must specify an \"id\" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);\n          }\n        }\n        var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);\n        fiber.elementType = REACT_PROFILER_TYPE;\n        fiber.lanes = lanes;\n        {\n          fiber.stateNode = {\n            effectDuration: 0,\n            passiveEffectDuration: 0\n          };\n        }\n        return fiber;\n      }\n      function createFiberFromSuspense(pendingProps, mode, lanes, key) {\n        var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);\n        fiber.elementType = REACT_SUSPENSE_TYPE;\n        fiber.lanes = lanes;\n        return fiber;\n      }\n      function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {\n        var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);\n        fiber.elementType = REACT_SUSPENSE_LIST_TYPE;\n        fiber.lanes = lanes;\n        return fiber;\n      }\n      function createFiberFromOffscreen(pendingProps, mode, lanes, key) {\n        var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);\n        fiber.elementType = REACT_OFFSCREEN_TYPE;\n        fiber.lanes = lanes;\n        var primaryChildInstance = {\n          isHidden: false\n        };\n        fiber.stateNode = primaryChildInstance;\n        return fiber;\n      }\n      function createFiberFromText(content, mode, lanes) {\n        var fiber = createFiber(HostText, content, null, mode);\n        fiber.lanes = lanes;\n        return fiber;\n      }\n      function createFiberFromHostInstanceForDeletion() {\n        var fiber = createFiber(HostComponent, null, null, NoMode);\n        fiber.elementType = \"DELETED\";\n        return fiber;\n      }\n      function createFiberFromDehydratedFragment(dehydratedNode) {\n        var fiber = createFiber(DehydratedFragment, null, null, NoMode);\n        fiber.stateNode = dehydratedNode;\n        return fiber;\n      }\n      function createFiberFromPortal(portal, mode, lanes) {\n        var pendingProps = portal.children !== null ? portal.children : [];\n        var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);\n        fiber.lanes = lanes;\n        fiber.stateNode = {\n          containerInfo: portal.containerInfo,\n          pendingChildren: null,\n          implementation: portal.implementation\n        };\n        return fiber;\n      }\n      function assignFiberPropertiesInDEV(target, source) {\n        if (target === null) {\n          target = createFiber(IndeterminateComponent, null, null, NoMode);\n        }\n        target.tag = source.tag;\n        target.key = source.key;\n        target.elementType = source.elementType;\n        target.type = source.type;\n        target.stateNode = source.stateNode;\n        target.return = source.return;\n        target.child = source.child;\n        target.sibling = source.sibling;\n        target.index = source.index;\n        target.ref = source.ref;\n        target.pendingProps = source.pendingProps;\n        target.memoizedProps = source.memoizedProps;\n        target.updateQueue = source.updateQueue;\n        target.memoizedState = source.memoizedState;\n        target.dependencies = source.dependencies;\n        target.mode = source.mode;\n        target.flags = source.flags;\n        target.subtreeFlags = source.subtreeFlags;\n        target.deletions = source.deletions;\n        target.lanes = source.lanes;\n        target.childLanes = source.childLanes;\n        target.alternate = source.alternate;\n        {\n          target.actualDuration = source.actualDuration;\n          target.actualStartTime = source.actualStartTime;\n          target.selfBaseDuration = source.selfBaseDuration;\n          target.treeBaseDuration = source.treeBaseDuration;\n        }\n        target._debugSource = source._debugSource;\n        target._debugOwner = source._debugOwner;\n        target._debugNeedsRemount = source._debugNeedsRemount;\n        target._debugHookTypes = source._debugHookTypes;\n        return target;\n      }\n      function FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError) {\n        this.tag = tag;\n        this.containerInfo = containerInfo;\n        this.pendingChildren = null;\n        this.current = null;\n        this.pingCache = null;\n        this.finishedWork = null;\n        this.timeoutHandle = noTimeout;\n        this.context = null;\n        this.pendingContext = null;\n        this.callbackNode = null;\n        this.callbackPriority = NoLane;\n        this.eventTimes = createLaneMap(NoLanes);\n        this.expirationTimes = createLaneMap(NoTimestamp);\n        this.pendingLanes = NoLanes;\n        this.suspendedLanes = NoLanes;\n        this.pingedLanes = NoLanes;\n        this.expiredLanes = NoLanes;\n        this.mutableReadLanes = NoLanes;\n        this.finishedLanes = NoLanes;\n        this.entangledLanes = NoLanes;\n        this.entanglements = createLaneMap(NoLanes);\n        this.identifierPrefix = identifierPrefix;\n        this.onRecoverableError = onRecoverableError;\n        {\n          this.mutableSourceEagerHydrationData = null;\n        }\n        {\n          this.effectDuration = 0;\n          this.passiveEffectDuration = 0;\n        }\n        {\n          this.memoizedUpdaters = new Set;\n          var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];\n          for (var _i = 0;_i < TotalLanes; _i++) {\n            pendingUpdatersLaneMap.push(new Set);\n          }\n        }\n        {\n          switch (tag) {\n            case ConcurrentRoot:\n              this._debugRootType = hydrate2 ? \"hydrateRoot()\" : \"createRoot()\";\n              break;\n            case LegacyRoot:\n              this._debugRootType = hydrate2 ? \"hydrate()\" : \"render()\";\n              break;\n          }\n        }\n      }\n      function createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {\n        var root2 = new FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError);\n        var uninitializedFiber = createHostRootFiber(tag, isStrictMode);\n        root2.current = uninitializedFiber;\n        uninitializedFiber.stateNode = root2;\n        {\n          var _initialState = {\n            element: initialChildren,\n            isDehydrated: hydrate2,\n            cache: null,\n            transitions: null,\n            pendingSuspenseBoundaries: null\n          };\n          uninitializedFiber.memoizedState = _initialState;\n        }\n        initializeUpdateQueue(uninitializedFiber);\n        return root2;\n      }\n      var ReactVersion = \"18.3.1\";\n      function createPortal(children, containerInfo, implementation) {\n        var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n        {\n          checkKeyStringCoercion(key);\n        }\n        return {\n          $$typeof: REACT_PORTAL_TYPE,\n          key: key == null ? null : \"\" + key,\n          children,\n          containerInfo,\n          implementation\n        };\n      }\n      var didWarnAboutNestedUpdates;\n      var didWarnAboutFindNodeInStrictMode;\n      {\n        didWarnAboutNestedUpdates = false;\n        didWarnAboutFindNodeInStrictMode = {};\n      }\n      function getContextForSubtree(parentComponent) {\n        if (!parentComponent) {\n          return emptyContextObject;\n        }\n        var fiber = get(parentComponent);\n        var parentContext = findCurrentUnmaskedContext(fiber);\n        if (fiber.tag === ClassComponent) {\n          var Component = fiber.type;\n          if (isContextProvider(Component)) {\n            return processChildContext(fiber, Component, parentContext);\n          }\n        }\n        return parentContext;\n      }\n      function findHostInstanceWithWarning(component, methodName) {\n        {\n          var fiber = get(component);\n          if (fiber === undefined) {\n            if (typeof component.render === \"function\") {\n              throw new Error(\"Unable to find node on an unmounted component.\");\n            } else {\n              var keys = Object.keys(component).join(\",\");\n              throw new Error(\"Argument appears to not be a ReactComponent. Keys: \" + keys);\n            }\n          }\n          var hostFiber = findCurrentHostFiber(fiber);\n          if (hostFiber === null) {\n            return null;\n          }\n          if (hostFiber.mode & StrictLegacyMode) {\n            var componentName = getComponentNameFromFiber(fiber) || \"Component\";\n            if (!didWarnAboutFindNodeInStrictMode[componentName]) {\n              didWarnAboutFindNodeInStrictMode[componentName] = true;\n              var previousFiber = current;\n              try {\n                setCurrentFiber(hostFiber);\n                if (fiber.mode & StrictLegacyMode) {\n                  error(\"%s is deprecated in StrictMode. \" + \"%s was passed an instance of %s which is inside StrictMode. \" + \"Instead, add a ref directly to the element you want to reference. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-find-node\", methodName, methodName, componentName);\n                } else {\n                  error(\"%s is deprecated in StrictMode. \" + \"%s was passed an instance of %s which renders StrictMode children. \" + \"Instead, add a ref directly to the element you want to reference. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-find-node\", methodName, methodName, componentName);\n                }\n              } finally {\n                if (previousFiber) {\n                  setCurrentFiber(previousFiber);\n                } else {\n                  resetCurrentFiber();\n                }\n              }\n            }\n          }\n          return hostFiber.stateNode;\n        }\n      }\n      function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {\n        var hydrate2 = false;\n        var initialChildren = null;\n        return createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);\n      }\n      function createHydrationContainer(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {\n        var hydrate2 = true;\n        var root2 = createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);\n        root2.context = getContextForSubtree(null);\n        var current2 = root2.current;\n        var eventTime = requestEventTime();\n        var lane = requestUpdateLane(current2);\n        var update = createUpdate(eventTime, lane);\n        update.callback = callback !== undefined && callback !== null ? callback : null;\n        enqueueUpdate(current2, update, lane);\n        scheduleInitialHydrationOnRoot(root2, lane, eventTime);\n        return root2;\n      }\n      function updateContainer(element, container, parentComponent, callback) {\n        {\n          onScheduleRoot(container, element);\n        }\n        var current$1 = container.current;\n        var eventTime = requestEventTime();\n        var lane = requestUpdateLane(current$1);\n        {\n          markRenderScheduled(lane);\n        }\n        var context = getContextForSubtree(parentComponent);\n        if (container.context === null) {\n          container.context = context;\n        } else {\n          container.pendingContext = context;\n        }\n        {\n          if (isRendering && current !== null && !didWarnAboutNestedUpdates) {\n            didWarnAboutNestedUpdates = true;\n            error(\"Render methods should be a pure function of props and state; \" + \"triggering nested component updates from render is not allowed. \" + `If necessary, trigger nested updates in componentDidUpdate.\n\n` + \"Check the render method of %s.\", getComponentNameFromFiber(current) || \"Unknown\");\n          }\n        }\n        var update = createUpdate(eventTime, lane);\n        update.payload = {\n          element\n        };\n        callback = callback === undefined ? null : callback;\n        if (callback !== null) {\n          {\n            if (typeof callback !== \"function\") {\n              error(\"render(...): Expected the last optional `callback` argument to be a \" + \"function. Instead received: %s.\", callback);\n            }\n          }\n          update.callback = callback;\n        }\n        var root2 = enqueueUpdate(current$1, update, lane);\n        if (root2 !== null) {\n          scheduleUpdateOnFiber(root2, current$1, lane, eventTime);\n          entangleTransitions(root2, current$1, lane);\n        }\n        return lane;\n      }\n      function getPublicRootInstance(container) {\n        var containerFiber = container.current;\n        if (!containerFiber.child) {\n          return null;\n        }\n        switch (containerFiber.child.tag) {\n          case HostComponent:\n            return getPublicInstance(containerFiber.child.stateNode);\n          default:\n            return containerFiber.child.stateNode;\n        }\n      }\n      function attemptSynchronousHydration$1(fiber) {\n        switch (fiber.tag) {\n          case HostRoot: {\n            var root2 = fiber.stateNode;\n            if (isRootDehydrated(root2)) {\n              var lanes = getHighestPriorityPendingLanes(root2);\n              flushRoot(root2, lanes);\n            }\n            break;\n          }\n          case SuspenseComponent: {\n            flushSync(function() {\n              var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);\n              if (root3 !== null) {\n                var eventTime = requestEventTime();\n                scheduleUpdateOnFiber(root3, fiber, SyncLane, eventTime);\n              }\n            });\n            var retryLane = SyncLane;\n            markRetryLaneIfNotHydrated(fiber, retryLane);\n            break;\n          }\n        }\n      }\n      function markRetryLaneImpl(fiber, retryLane) {\n        var suspenseState = fiber.memoizedState;\n        if (suspenseState !== null && suspenseState.dehydrated !== null) {\n          suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);\n        }\n      }\n      function markRetryLaneIfNotHydrated(fiber, retryLane) {\n        markRetryLaneImpl(fiber, retryLane);\n        var alternate = fiber.alternate;\n        if (alternate) {\n          markRetryLaneImpl(alternate, retryLane);\n        }\n      }\n      function attemptContinuousHydration$1(fiber) {\n        if (fiber.tag !== SuspenseComponent) {\n          return;\n        }\n        var lane = SelectiveHydrationLane;\n        var root2 = enqueueConcurrentRenderForLane(fiber, lane);\n        if (root2 !== null) {\n          var eventTime = requestEventTime();\n          scheduleUpdateOnFiber(root2, fiber, lane, eventTime);\n        }\n        markRetryLaneIfNotHydrated(fiber, lane);\n      }\n      function attemptHydrationAtCurrentPriority$1(fiber) {\n        if (fiber.tag !== SuspenseComponent) {\n          return;\n        }\n        var lane = requestUpdateLane(fiber);\n        var root2 = enqueueConcurrentRenderForLane(fiber, lane);\n        if (root2 !== null) {\n          var eventTime = requestEventTime();\n          scheduleUpdateOnFiber(root2, fiber, lane, eventTime);\n        }\n        markRetryLaneIfNotHydrated(fiber, lane);\n      }\n      function findHostInstanceWithNoPortals(fiber) {\n        var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n        if (hostFiber === null) {\n          return null;\n        }\n        return hostFiber.stateNode;\n      }\n      var shouldErrorImpl = function(fiber) {\n        return null;\n      };\n      function shouldError(fiber) {\n        return shouldErrorImpl(fiber);\n      }\n      var shouldSuspendImpl = function(fiber) {\n        return false;\n      };\n      function shouldSuspend(fiber) {\n        return shouldSuspendImpl(fiber);\n      }\n      var overrideHookState = null;\n      var overrideHookStateDeletePath = null;\n      var overrideHookStateRenamePath = null;\n      var overrideProps = null;\n      var overridePropsDeletePath = null;\n      var overridePropsRenamePath = null;\n      var scheduleUpdate = null;\n      var setErrorHandler = null;\n      var setSuspenseHandler = null;\n      {\n        var copyWithDeleteImpl = function(obj, path, index2) {\n          var key = path[index2];\n          var updated = isArray(obj) ? obj.slice() : assign({}, obj);\n          if (index2 + 1 === path.length) {\n            if (isArray(updated)) {\n              updated.splice(key, 1);\n            } else {\n              delete updated[key];\n            }\n            return updated;\n          }\n          updated[key] = copyWithDeleteImpl(obj[key], path, index2 + 1);\n          return updated;\n        };\n        var copyWithDelete = function(obj, path) {\n          return copyWithDeleteImpl(obj, path, 0);\n        };\n        var copyWithRenameImpl = function(obj, oldPath, newPath, index2) {\n          var oldKey = oldPath[index2];\n          var updated = isArray(obj) ? obj.slice() : assign({}, obj);\n          if (index2 + 1 === oldPath.length) {\n            var newKey = newPath[index2];\n            updated[newKey] = updated[oldKey];\n            if (isArray(updated)) {\n              updated.splice(oldKey, 1);\n            } else {\n              delete updated[oldKey];\n            }\n          } else {\n            updated[oldKey] = copyWithRenameImpl(obj[oldKey], oldPath, newPath, index2 + 1);\n          }\n          return updated;\n        };\n        var copyWithRename = function(obj, oldPath, newPath) {\n          if (oldPath.length !== newPath.length) {\n            warn(\"copyWithRename() expects paths of the same length\");\n            return;\n          } else {\n            for (var i = 0;i < newPath.length - 1; i++) {\n              if (oldPath[i] !== newPath[i]) {\n                warn(\"copyWithRename() expects paths to be the same except for the deepest key\");\n                return;\n              }\n            }\n          }\n          return copyWithRenameImpl(obj, oldPath, newPath, 0);\n        };\n        var copyWithSetImpl = function(obj, path, index2, value) {\n          if (index2 >= path.length) {\n            return value;\n          }\n          var key = path[index2];\n          var updated = isArray(obj) ? obj.slice() : assign({}, obj);\n          updated[key] = copyWithSetImpl(obj[key], path, index2 + 1, value);\n          return updated;\n        };\n        var copyWithSet = function(obj, path, value) {\n          return copyWithSetImpl(obj, path, 0, value);\n        };\n        var findHook = function(fiber, id) {\n          var currentHook2 = fiber.memoizedState;\n          while (currentHook2 !== null && id > 0) {\n            currentHook2 = currentHook2.next;\n            id--;\n          }\n          return currentHook2;\n        };\n        overrideHookState = function(fiber, id, path, value) {\n          var hook = findHook(fiber, id);\n          if (hook !== null) {\n            var newState = copyWithSet(hook.memoizedState, path, value);\n            hook.memoizedState = newState;\n            hook.baseState = newState;\n            fiber.memoizedProps = assign({}, fiber.memoizedProps);\n            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);\n            if (root2 !== null) {\n              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);\n            }\n          }\n        };\n        overrideHookStateDeletePath = function(fiber, id, path) {\n          var hook = findHook(fiber, id);\n          if (hook !== null) {\n            var newState = copyWithDelete(hook.memoizedState, path);\n            hook.memoizedState = newState;\n            hook.baseState = newState;\n            fiber.memoizedProps = assign({}, fiber.memoizedProps);\n            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);\n            if (root2 !== null) {\n              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);\n            }\n          }\n        };\n        overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {\n          var hook = findHook(fiber, id);\n          if (hook !== null) {\n            var newState = copyWithRename(hook.memoizedState, oldPath, newPath);\n            hook.memoizedState = newState;\n            hook.baseState = newState;\n            fiber.memoizedProps = assign({}, fiber.memoizedProps);\n            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);\n            if (root2 !== null) {\n              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);\n            }\n          }\n        };\n        overrideProps = function(fiber, path, value) {\n          fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);\n          if (fiber.alternate) {\n            fiber.alternate.pendingProps = fiber.pendingProps;\n          }\n          var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);\n          if (root2 !== null) {\n            scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);\n          }\n        };\n        overridePropsDeletePath = function(fiber, path) {\n          fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);\n          if (fiber.alternate) {\n            fiber.alternate.pendingProps = fiber.pendingProps;\n          }\n          var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);\n          if (root2 !== null) {\n            scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);\n          }\n        };\n        overridePropsRenamePath = function(fiber, oldPath, newPath) {\n          fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);\n          if (fiber.alternate) {\n            fiber.alternate.pendingProps = fiber.pendingProps;\n          }\n          var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);\n          if (root2 !== null) {\n            scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);\n          }\n        };\n        scheduleUpdate = function(fiber) {\n          var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);\n          if (root2 !== null) {\n            scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);\n          }\n        };\n        setErrorHandler = function(newShouldErrorImpl) {\n          shouldErrorImpl = newShouldErrorImpl;\n        };\n        setSuspenseHandler = function(newShouldSuspendImpl) {\n          shouldSuspendImpl = newShouldSuspendImpl;\n        };\n      }\n      function findHostInstanceByFiber(fiber) {\n        var hostFiber = findCurrentHostFiber(fiber);\n        if (hostFiber === null) {\n          return null;\n        }\n        return hostFiber.stateNode;\n      }\n      function emptyFindFiberByHostInstance(instance) {\n        return null;\n      }\n      function getCurrentFiberForDevTools() {\n        return current;\n      }\n      function injectIntoDevTools(devToolsConfig) {\n        var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\n        var ReactCurrentDispatcher2 = ReactSharedInternals.ReactCurrentDispatcher;\n        return injectInternals({\n          bundleType: devToolsConfig.bundleType,\n          version: devToolsConfig.version,\n          rendererPackageName: devToolsConfig.rendererPackageName,\n          rendererConfig: devToolsConfig.rendererConfig,\n          overrideHookState,\n          overrideHookStateDeletePath,\n          overrideHookStateRenamePath,\n          overrideProps,\n          overridePropsDeletePath,\n          overridePropsRenamePath,\n          setErrorHandler,\n          setSuspenseHandler,\n          scheduleUpdate,\n          currentDispatcherRef: ReactCurrentDispatcher2,\n          findHostInstanceByFiber,\n          findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,\n          findHostInstancesForRefresh,\n          scheduleRefresh,\n          scheduleRoot,\n          setRefreshHandler,\n          getCurrentFiber: getCurrentFiberForDevTools,\n          reconcilerVersion: ReactVersion\n        });\n      }\n      var defaultOnRecoverableError = typeof reportError === \"function\" ? reportError : function(error2) {\n        console[\"error\"](error2);\n      };\n      function ReactDOMRoot(internalRoot) {\n        this._internalRoot = internalRoot;\n      }\n      ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {\n        var root2 = this._internalRoot;\n        if (root2 === null) {\n          throw new Error(\"Cannot update an unmounted root.\");\n        }\n        {\n          if (typeof arguments[1] === \"function\") {\n            error(\"render(...): does not support the second callback argument. \" + \"To execute a side effect after rendering, declare it in a component body with useEffect().\");\n          } else if (isValidContainer(arguments[1])) {\n            error(\"You passed a container to the second argument of root.render(...). \" + \"You don't need to pass it again since you already passed it to create the root.\");\n          } else if (typeof arguments[1] !== \"undefined\") {\n            error(\"You passed a second argument to root.render(...) but it only accepts \" + \"one argument.\");\n          }\n          var container = root2.containerInfo;\n          if (container.nodeType !== COMMENT_NODE) {\n            var hostInstance = findHostInstanceWithNoPortals(root2.current);\n            if (hostInstance) {\n              if (hostInstance.parentNode !== container) {\n                error(\"render(...): It looks like the React-rendered content of the \" + \"root container was removed without using React. This is not \" + \"supported and will cause errors. Instead, call \" + \"root.unmount() to empty a root's container.\");\n              }\n            }\n          }\n        }\n        updateContainer(children, root2, null, null);\n      };\n      ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {\n        {\n          if (typeof arguments[0] === \"function\") {\n            error(\"unmount(...): does not support a callback argument. \" + \"To execute a side effect after rendering, declare it in a component body with useEffect().\");\n          }\n        }\n        var root2 = this._internalRoot;\n        if (root2 !== null) {\n          this._internalRoot = null;\n          var container = root2.containerInfo;\n          {\n            if (isAlreadyRendering()) {\n              error(\"Attempted to synchronously unmount a root while React was already \" + \"rendering. React cannot finish unmounting the root until the \" + \"current render has completed, which may lead to a race condition.\");\n            }\n          }\n          flushSync(function() {\n            updateContainer(null, root2, null, null);\n          });\n          unmarkContainerAsRoot(container);\n        }\n      };\n      function createRoot(container, options2) {\n        if (!isValidContainer(container)) {\n          throw new Error(\"createRoot(...): Target container is not a DOM element.\");\n        }\n        warnIfReactDOMContainerInDEV(container);\n        var isStrictMode = false;\n        var concurrentUpdatesByDefaultOverride = false;\n        var identifierPrefix = \"\";\n        var onRecoverableError = defaultOnRecoverableError;\n        var transitionCallbacks = null;\n        if (options2 !== null && options2 !== undefined) {\n          {\n            if (options2.hydrate) {\n              warn(\"hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.\");\n            } else {\n              if (typeof options2 === \"object\" && options2 !== null && options2.$$typeof === REACT_ELEMENT_TYPE) {\n                error(\"You passed a JSX element to createRoot. You probably meant to \" + \"call root.render instead. \" + `Example usage:\n\n` + `  let root = createRoot(domContainer);\n` + \"  root.render(<App />);\");\n              }\n            }\n          }\n          if (options2.unstable_strictMode === true) {\n            isStrictMode = true;\n          }\n          if (options2.identifierPrefix !== undefined) {\n            identifierPrefix = options2.identifierPrefix;\n          }\n          if (options2.onRecoverableError !== undefined) {\n            onRecoverableError = options2.onRecoverableError;\n          }\n          if (options2.transitionCallbacks !== undefined) {\n            transitionCallbacks = options2.transitionCallbacks;\n          }\n        }\n        var root2 = createContainer(container, ConcurrentRoot, null, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);\n        markContainerAsRoot(root2.current, container);\n        var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;\n        listenToAllSupportedEvents(rootContainerElement);\n        return new ReactDOMRoot(root2);\n      }\n      function ReactDOMHydrationRoot(internalRoot) {\n        this._internalRoot = internalRoot;\n      }\n      function scheduleHydration(target) {\n        if (target) {\n          queueExplicitHydrationTarget(target);\n        }\n      }\n      ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = scheduleHydration;\n      function hydrateRoot(container, initialChildren, options2) {\n        if (!isValidContainer(container)) {\n          throw new Error(\"hydrateRoot(...): Target container is not a DOM element.\");\n        }\n        warnIfReactDOMContainerInDEV(container);\n        {\n          if (initialChildren === undefined) {\n            error(\"Must provide initial children as second argument to hydrateRoot. \" + \"Example usage: hydrateRoot(domContainer, <App />)\");\n          }\n        }\n        var hydrationCallbacks = options2 != null ? options2 : null;\n        var mutableSources = options2 != null && options2.hydratedSources || null;\n        var isStrictMode = false;\n        var concurrentUpdatesByDefaultOverride = false;\n        var identifierPrefix = \"\";\n        var onRecoverableError = defaultOnRecoverableError;\n        if (options2 !== null && options2 !== undefined) {\n          if (options2.unstable_strictMode === true) {\n            isStrictMode = true;\n          }\n          if (options2.identifierPrefix !== undefined) {\n            identifierPrefix = options2.identifierPrefix;\n          }\n          if (options2.onRecoverableError !== undefined) {\n            onRecoverableError = options2.onRecoverableError;\n          }\n        }\n        var root2 = createHydrationContainer(initialChildren, null, container, ConcurrentRoot, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);\n        markContainerAsRoot(root2.current, container);\n        listenToAllSupportedEvents(container);\n        if (mutableSources) {\n          for (var i = 0;i < mutableSources.length; i++) {\n            var mutableSource = mutableSources[i];\n            registerMutableSourceForHydration(root2, mutableSource);\n          }\n        }\n        return new ReactDOMHydrationRoot(root2);\n      }\n      function isValidContainer(node) {\n        return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || !disableCommentsAsDOMContainers));\n      }\n      function isValidContainerLegacy(node) {\n        return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === \" react-mount-point-unstable \"));\n      }\n      function warnIfReactDOMContainerInDEV(container) {\n        {\n          if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === \"BODY\") {\n            error(\"createRoot(): Creating roots directly with document.body is \" + \"discouraged, since its children are often manipulated by third-party \" + \"scripts and browser extensions. This may lead to subtle \" + \"reconciliation issues. Try using a container element created \" + \"for your app.\");\n          }\n          if (isContainerMarkedAsRoot(container)) {\n            if (container._reactRootContainer) {\n              error(\"You are calling ReactDOMClient.createRoot() on a container that was previously \" + \"passed to ReactDOM.render(). This is not supported.\");\n            } else {\n              error(\"You are calling ReactDOMClient.createRoot() on a container that \" + \"has already been passed to createRoot() before. Instead, call \" + \"root.render() on the existing root instead if you want to update it.\");\n            }\n          }\n        }\n      }\n      var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;\n      var topLevelUpdateWarnings;\n      {\n        topLevelUpdateWarnings = function(container) {\n          if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {\n            var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer.current);\n            if (hostInstance) {\n              if (hostInstance.parentNode !== container) {\n                error(\"render(...): It looks like the React-rendered content of this \" + \"container was removed without using React. This is not \" + \"supported and will cause errors. Instead, call \" + \"ReactDOM.unmountComponentAtNode to empty a container.\");\n              }\n            }\n          }\n          var isRootRenderedBySomeReact = !!container._reactRootContainer;\n          var rootEl = getReactRootElementInContainer(container);\n          var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));\n          if (hasNonRootReactChild && !isRootRenderedBySomeReact) {\n            error(\"render(...): Replacing React-rendered children with a new root \" + \"component. If you intended to update the children of this node, \" + \"you should instead have the existing children update their state \" + \"and render the new components instead of calling ReactDOM.render.\");\n          }\n          if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === \"BODY\") {\n            error(\"render(): Rendering components directly into document.body is \" + \"discouraged, since its children are often manipulated by third-party \" + \"scripts and browser extensions. This may lead to subtle \" + \"reconciliation issues. Try rendering into a container element created \" + \"for your app.\");\n          }\n        };\n      }\n      function getReactRootElementInContainer(container) {\n        if (!container) {\n          return null;\n        }\n        if (container.nodeType === DOCUMENT_NODE) {\n          return container.documentElement;\n        } else {\n          return container.firstChild;\n        }\n      }\n      function noopOnRecoverableError() {}\n      function legacyCreateRootFromDOMContainer(container, initialChildren, parentComponent, callback, isHydrationContainer) {\n        if (isHydrationContainer) {\n          if (typeof callback === \"function\") {\n            var originalCallback = callback;\n            callback = function() {\n              var instance = getPublicRootInstance(root2);\n              originalCallback.call(instance);\n            };\n          }\n          var root2 = createHydrationContainer(initialChildren, callback, container, LegacyRoot, null, false, false, \"\", noopOnRecoverableError);\n          container._reactRootContainer = root2;\n          markContainerAsRoot(root2.current, container);\n          var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;\n          listenToAllSupportedEvents(rootContainerElement);\n          flushSync();\n          return root2;\n        } else {\n          var rootSibling;\n          while (rootSibling = container.lastChild) {\n            container.removeChild(rootSibling);\n          }\n          if (typeof callback === \"function\") {\n            var _originalCallback = callback;\n            callback = function() {\n              var instance = getPublicRootInstance(_root);\n              _originalCallback.call(instance);\n            };\n          }\n          var _root = createContainer(container, LegacyRoot, null, false, false, \"\", noopOnRecoverableError);\n          container._reactRootContainer = _root;\n          markContainerAsRoot(_root.current, container);\n          var _rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;\n          listenToAllSupportedEvents(_rootContainerElement);\n          flushSync(function() {\n            updateContainer(initialChildren, _root, parentComponent, callback);\n          });\n          return _root;\n        }\n      }\n      function warnOnInvalidCallback$1(callback, callerName) {\n        {\n          if (callback !== null && typeof callback !== \"function\") {\n            error(\"%s(...): Expected the last optional `callback` argument to be a \" + \"function. Instead received: %s.\", callerName, callback);\n          }\n        }\n      }\n      function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {\n        {\n          topLevelUpdateWarnings(container);\n          warnOnInvalidCallback$1(callback === undefined ? null : callback, \"render\");\n        }\n        var maybeRoot = container._reactRootContainer;\n        var root2;\n        if (!maybeRoot) {\n          root2 = legacyCreateRootFromDOMContainer(container, children, parentComponent, callback, forceHydrate);\n        } else {\n          root2 = maybeRoot;\n          if (typeof callback === \"function\") {\n            var originalCallback = callback;\n            callback = function() {\n              var instance = getPublicRootInstance(root2);\n              originalCallback.call(instance);\n            };\n          }\n          updateContainer(children, root2, parentComponent, callback);\n        }\n        return getPublicRootInstance(root2);\n      }\n      var didWarnAboutFindDOMNode = false;\n      function findDOMNode(componentOrElement) {\n        {\n          if (!didWarnAboutFindDOMNode) {\n            didWarnAboutFindDOMNode = true;\n            error(\"findDOMNode is deprecated and will be removed in the next major \" + \"release. Instead, add a ref directly to the element you want \" + \"to reference. Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-find-node\");\n          }\n          var owner = ReactCurrentOwner$3.current;\n          if (owner !== null && owner.stateNode !== null) {\n            var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;\n            if (!warnedAboutRefsInRender) {\n              error(\"%s is accessing findDOMNode inside its render(). \" + \"render() should be a pure function of props and state. It should \" + \"never access something that requires stale data from the previous \" + \"render, such as refs. Move this logic to componentDidMount and \" + \"componentDidUpdate instead.\", getComponentNameFromType(owner.type) || \"A component\");\n            }\n            owner.stateNode._warnedAboutRefsInRender = true;\n          }\n        }\n        if (componentOrElement == null) {\n          return null;\n        }\n        if (componentOrElement.nodeType === ELEMENT_NODE) {\n          return componentOrElement;\n        }\n        {\n          return findHostInstanceWithWarning(componentOrElement, \"findDOMNode\");\n        }\n      }\n      function hydrate(element, container, callback) {\n        {\n          error(\"ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot \" + \"instead. Until you switch to the new API, your app will behave as \" + \"if it's running React 17. Learn \" + \"more: https://reactjs.org/link/switch-to-createroot\");\n        }\n        if (!isValidContainerLegacy(container)) {\n          throw new Error(\"Target container is not a DOM element.\");\n        }\n        {\n          var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;\n          if (isModernRoot) {\n            error(\"You are calling ReactDOM.hydrate() on a container that was previously \" + \"passed to ReactDOMClient.createRoot(). This is not supported. \" + \"Did you mean to call hydrateRoot(container, element)?\");\n          }\n        }\n        return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);\n      }\n      function render(element, container, callback) {\n        {\n          error(\"ReactDOM.render is no longer supported in React 18. Use createRoot \" + \"instead. Until you switch to the new API, your app will behave as \" + \"if it's running React 17. Learn \" + \"more: https://reactjs.org/link/switch-to-createroot\");\n        }\n        if (!isValidContainerLegacy(container)) {\n          throw new Error(\"Target container is not a DOM element.\");\n        }\n        {\n          var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;\n          if (isModernRoot) {\n            error(\"You are calling ReactDOM.render() on a container that was previously \" + \"passed to ReactDOMClient.createRoot(). This is not supported. \" + \"Did you mean to call root.render(element)?\");\n          }\n        }\n        return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);\n      }\n      function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {\n        {\n          error(\"ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported \" + \"in React 18. Consider using a portal instead. Until you switch to \" + \"the createRoot API, your app will behave as if it's running React \" + \"17. Learn more: https://reactjs.org/link/switch-to-createroot\");\n        }\n        if (!isValidContainerLegacy(containerNode)) {\n          throw new Error(\"Target container is not a DOM element.\");\n        }\n        if (parentComponent == null || !has(parentComponent)) {\n          throw new Error(\"parentComponent must be a valid React Component\");\n        }\n        return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);\n      }\n      var didWarnAboutUnmountComponentAtNode = false;\n      function unmountComponentAtNode(container) {\n        {\n          if (!didWarnAboutUnmountComponentAtNode) {\n            didWarnAboutUnmountComponentAtNode = true;\n            error(\"unmountComponentAtNode is deprecated and will be removed in the \" + \"next major release. Switch to the createRoot API. Learn \" + \"more: https://reactjs.org/link/switch-to-createroot\");\n          }\n        }\n        if (!isValidContainerLegacy(container)) {\n          throw new Error(\"unmountComponentAtNode(...): Target container is not a DOM element.\");\n        }\n        {\n          var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;\n          if (isModernRoot) {\n            error(\"You are calling ReactDOM.unmountComponentAtNode() on a container that was previously \" + \"passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?\");\n          }\n        }\n        if (container._reactRootContainer) {\n          {\n            var rootEl = getReactRootElementInContainer(container);\n            var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);\n            if (renderedByDifferentReact) {\n              error(\"unmountComponentAtNode(): The node you're attempting to unmount \" + \"was rendered by another copy of React.\");\n            }\n          }\n          flushSync(function() {\n            legacyRenderSubtreeIntoContainer(null, null, container, false, function() {\n              container._reactRootContainer = null;\n              unmarkContainerAsRoot(container);\n            });\n          });\n          return true;\n        } else {\n          {\n            var _rootEl = getReactRootElementInContainer(container);\n            var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl));\n            var isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainerLegacy(container.parentNode) && !!container.parentNode._reactRootContainer;\n            if (hasNonRootReactChild) {\n              error(\"unmountComponentAtNode(): The node you're attempting to unmount \" + \"was rendered by React and is not a top-level container. %s\", isContainerReactRoot ? \"You may have accidentally passed in a React root node instead \" + \"of its container.\" : \"Instead, have the parent component update its state and \" + \"rerender in order to remove this component.\");\n            }\n          }\n          return false;\n        }\n      }\n      setAttemptSynchronousHydration(attemptSynchronousHydration$1);\n      setAttemptContinuousHydration(attemptContinuousHydration$1);\n      setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);\n      setGetCurrentUpdatePriority(getCurrentUpdatePriority);\n      setAttemptHydrationAtPriority(runWithPriority);\n      {\n        if (typeof Map !== \"function\" || Map.prototype == null || typeof Map.prototype.forEach !== \"function\" || typeof Set !== \"function\" || Set.prototype == null || typeof Set.prototype.clear !== \"function\" || typeof Set.prototype.forEach !== \"function\") {\n          error(\"React depends on Map and Set built-in types. Make sure that you load a \" + \"polyfill in older browsers. https://reactjs.org/link/react-polyfills\");\n        }\n      }\n      setRestoreImplementation(restoreControlledState$3);\n      setBatchingImplementation(batchedUpdates$1, discreteUpdates, flushSync);\n      function createPortal$1(children, container) {\n        var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n        if (!isValidContainer(container)) {\n          throw new Error(\"Target container is not a DOM element.\");\n        }\n        return createPortal(children, container, null, key);\n      }\n      function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {\n        return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);\n      }\n      var Internals = {\n        usingClientEntryPoint: false,\n        Events: [getInstanceFromNode, getNodeFromInstance, getFiberCurrentPropsFromNode, enqueueStateRestore, restoreStateIfNeeded, batchedUpdates$1]\n      };\n      function createRoot$1(container, options2) {\n        {\n          if (!Internals.usingClientEntryPoint && true) {\n            error('You are importing createRoot from \"react-dom\" which is not supported. ' + 'You should instead import it from \"react-dom/client\".');\n          }\n        }\n        return createRoot(container, options2);\n      }\n      function hydrateRoot$1(container, initialChildren, options2) {\n        {\n          if (!Internals.usingClientEntryPoint && true) {\n            error('You are importing hydrateRoot from \"react-dom\" which is not supported. ' + 'You should instead import it from \"react-dom/client\".');\n          }\n        }\n        return hydrateRoot(container, initialChildren, options2);\n      }\n      function flushSync$1(fn) {\n        {\n          if (isAlreadyRendering()) {\n            error(\"flushSync was called from inside a lifecycle method. React cannot \" + \"flush when React is already rendering. Consider moving this call to \" + \"a scheduler task or micro task.\");\n          }\n        }\n        return flushSync(fn);\n      }\n      var foundDevTools = injectIntoDevTools({\n        findFiberByHostInstance: getClosestInstanceFromNode,\n        bundleType: 1,\n        version: ReactVersion,\n        rendererPackageName: \"react-dom\"\n      });\n      {\n        if (!foundDevTools && canUseDOM && window.top === window.self) {\n          if (navigator.userAgent.indexOf(\"Chrome\") > -1 && navigator.userAgent.indexOf(\"Edge\") === -1 || navigator.userAgent.indexOf(\"Firefox\") > -1) {\n            var protocol = window.location.protocol;\n            if (/^(https?|file):$/.test(protocol)) {\n              console.info(\"%cDownload the React DevTools \" + \"for a better development experience: \" + \"https://reactjs.org/link/react-devtools\" + (protocol === \"file:\" ? `\nYou might need to use a local HTTP server (instead of file://): ` + \"https://reactjs.org/link/react-devtools-faq\" : \"\"), \"font-weight:bold\");\n            }\n          }\n        }\n      }\n      exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;\n      exports.createPortal = createPortal$1;\n      exports.createRoot = createRoot$1;\n      exports.findDOMNode = findDOMNode;\n      exports.flushSync = flushSync$1;\n      exports.hydrate = hydrate;\n      exports.hydrateRoot = hydrateRoot$1;\n      exports.render = render;\n      exports.unmountComponentAtNode = unmountComponentAtNode;\n      exports.unstable_batchedUpdates = batchedUpdates$1;\n      exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;\n      exports.version = ReactVersion;\n      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error);\n      }\n    })();\n  }\n});\n\n// ../../node_modules/.bun/react-dom@18.3.1+f4eacebf2041cd4f/node_modules/react-dom/index.js\nvar require_react_dom = __commonJS((exports, module) => {\n  var react_dom_development = __toESM(require_react_dom_development(), 1);\n  if (false) {} else {\n    module.exports = react_dom_development;\n  }\n});\n\n// ../../node_modules/.bun/react-dom@18.3.1+f4eacebf2041cd4f/node_modules/react-dom/client.js\nvar require_client = __commonJS((exports) => {\n  var m = __toESM(require_react_dom(), 1);\n  if (false) {} else {\n    i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    exports.createRoot = function(c, o) {\n      i.usingClientEntryPoint = true;\n      try {\n        return m.createRoot(c, o);\n      } finally {\n        i.usingClientEntryPoint = false;\n      }\n    };\n    exports.hydrateRoot = function(c, h, o) {\n      i.usingClientEntryPoint = true;\n      try {\n        return m.hydrateRoot(c, h, o);\n      } finally {\n        i.usingClientEntryPoint = false;\n      }\n    };\n  }\n  var i;\n});\n\n// ../../node_modules/.bun/react@18.3.1/node_modules/react/cjs/react-jsx-dev-runtime.development.js\nvar require_react_jsx_dev_runtime_development = __commonJS((exports) => {\n  var React = __toESM(require_react(), 1);\n  if (true) {\n    (function() {\n      var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n      var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n      var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n      var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n      var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n      var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n      var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n      var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n      var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n      var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n      var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n      var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n      var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n      var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n      function getIteratorFn(maybeIterable) {\n        if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n          return null;\n        }\n        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n        if (typeof maybeIterator === \"function\") {\n          return maybeIterator;\n        }\n        return null;\n      }\n      var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n      function error(format) {\n        {\n          {\n            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;_key2 < _len2; _key2++) {\n              args[_key2 - 1] = arguments[_key2];\n            }\n            printWarning(\"error\", format, args);\n          }\n        }\n      }\n      function printWarning(level, format, args) {\n        {\n          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;\n          var stack = ReactDebugCurrentFrame2.getStackAddendum();\n          if (stack !== \"\") {\n            format += \"%s\";\n            args = args.concat([stack]);\n          }\n          var argsWithFormat = args.map(function(item) {\n            return String(item);\n          });\n          argsWithFormat.unshift(\"Warning: \" + format);\n          Function.prototype.apply.call(console[level], console, argsWithFormat);\n        }\n      }\n      var enableScopeAPI = false;\n      var enableCacheElement = false;\n      var enableTransitionTracing = false;\n      var enableLegacyHidden = false;\n      var enableDebugTracing = false;\n      var REACT_MODULE_REFERENCE;\n      {\n        REACT_MODULE_REFERENCE = Symbol.for(\"react.module.reference\");\n      }\n      function isValidElementType(type) {\n        if (typeof type === \"string\" || typeof type === \"function\") {\n          return true;\n        }\n        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n          return true;\n        }\n        if (typeof type === \"object\" && type !== null) {\n          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n            return true;\n          }\n        }\n        return false;\n      }\n      function getWrappedName(outerType, innerType, wrapperName) {\n        var displayName = outerType.displayName;\n        if (displayName) {\n          return displayName;\n        }\n        var functionName = innerType.displayName || innerType.name || \"\";\n        return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n      }\n      function getContextName(type) {\n        return type.displayName || \"Context\";\n      }\n      function getComponentNameFromType(type) {\n        if (type == null) {\n          return null;\n        }\n        {\n          if (typeof type.tag === \"number\") {\n            error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n          }\n        }\n        if (typeof type === \"function\") {\n          return type.displayName || type.name || null;\n        }\n        if (typeof type === \"string\") {\n          return type;\n        }\n        switch (type) {\n          case REACT_FRAGMENT_TYPE:\n            return \"Fragment\";\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_PROFILER_TYPE:\n            return \"Profiler\";\n          case REACT_STRICT_MODE_TYPE:\n            return \"StrictMode\";\n          case REACT_SUSPENSE_TYPE:\n            return \"Suspense\";\n          case REACT_SUSPENSE_LIST_TYPE:\n            return \"SuspenseList\";\n        }\n        if (typeof type === \"object\") {\n          switch (type.$$typeof) {\n            case REACT_CONTEXT_TYPE:\n              var context = type;\n              return getContextName(context) + \".Consumer\";\n            case REACT_PROVIDER_TYPE:\n              var provider = type;\n              return getContextName(provider._context) + \".Provider\";\n            case REACT_FORWARD_REF_TYPE:\n              return getWrappedName(type, type.render, \"ForwardRef\");\n            case REACT_MEMO_TYPE:\n              var outerName = type.displayName || null;\n              if (outerName !== null) {\n                return outerName;\n              }\n              return getComponentNameFromType(type.type) || \"Memo\";\n            case REACT_LAZY_TYPE: {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n              try {\n                return getComponentNameFromType(init(payload));\n              } catch (x) {\n                return null;\n              }\n            }\n          }\n        }\n        return null;\n      }\n      var assign = Object.assign;\n      var disabledDepth = 0;\n      var prevLog;\n      var prevInfo;\n      var prevWarn;\n      var prevError;\n      var prevGroup;\n      var prevGroupCollapsed;\n      var prevGroupEnd;\n      function disabledLog() {}\n      disabledLog.__reactDisabledLog = true;\n      function disableLogs() {\n        {\n          if (disabledDepth === 0) {\n            prevLog = console.log;\n            prevInfo = console.info;\n            prevWarn = console.warn;\n            prevError = console.error;\n            prevGroup = console.group;\n            prevGroupCollapsed = console.groupCollapsed;\n            prevGroupEnd = console.groupEnd;\n            var props = {\n              configurable: true,\n              enumerable: true,\n              value: disabledLog,\n              writable: true\n            };\n            Object.defineProperties(console, {\n              info: props,\n              log: props,\n              warn: props,\n              error: props,\n              group: props,\n              groupCollapsed: props,\n              groupEnd: props\n            });\n          }\n          disabledDepth++;\n        }\n      }\n      function reenableLogs() {\n        {\n          disabledDepth--;\n          if (disabledDepth === 0) {\n            var props = {\n              configurable: true,\n              enumerable: true,\n              writable: true\n            };\n            Object.defineProperties(console, {\n              log: assign({}, props, {\n                value: prevLog\n              }),\n              info: assign({}, props, {\n                value: prevInfo\n              }),\n              warn: assign({}, props, {\n                value: prevWarn\n              }),\n              error: assign({}, props, {\n                value: prevError\n              }),\n              group: assign({}, props, {\n                value: prevGroup\n              }),\n              groupCollapsed: assign({}, props, {\n                value: prevGroupCollapsed\n              }),\n              groupEnd: assign({}, props, {\n                value: prevGroupEnd\n              })\n            });\n          }\n          if (disabledDepth < 0) {\n            error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n          }\n        }\n      }\n      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n      var prefix;\n      function describeBuiltInComponentFrame(name, source, ownerFn) {\n        {\n          if (prefix === undefined) {\n            try {\n              throw Error();\n            } catch (x) {\n              var match = x.stack.trim().match(/\\n( *(at )?)/);\n              prefix = match && match[1] || \"\";\n            }\n          }\n          return `\n` + prefix + name;\n        }\n      }\n      var reentry = false;\n      var componentFrameCache;\n      {\n        var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n        componentFrameCache = new PossiblyWeakMap;\n      }\n      function describeNativeComponentFrame(fn, construct) {\n        if (!fn || reentry) {\n          return \"\";\n        }\n        {\n          var frame = componentFrameCache.get(fn);\n          if (frame !== undefined) {\n            return frame;\n          }\n        }\n        var control;\n        reentry = true;\n        var previousPrepareStackTrace = Error.prepareStackTrace;\n        Error.prepareStackTrace = undefined;\n        var previousDispatcher;\n        {\n          previousDispatcher = ReactCurrentDispatcher.current;\n          ReactCurrentDispatcher.current = null;\n          disableLogs();\n        }\n        try {\n          if (construct) {\n            var Fake = function() {\n              throw Error();\n            };\n            Object.defineProperty(Fake.prototype, \"props\", {\n              set: function() {\n                throw Error();\n              }\n            });\n            if (typeof Reflect === \"object\" && Reflect.construct) {\n              try {\n                Reflect.construct(Fake, []);\n              } catch (x) {\n                control = x;\n              }\n              Reflect.construct(fn, [], Fake);\n            } else {\n              try {\n                Fake.call();\n              } catch (x) {\n                control = x;\n              }\n              fn.call(Fake.prototype);\n            }\n          } else {\n            try {\n              throw Error();\n            } catch (x) {\n              control = x;\n            }\n            fn();\n          }\n        } catch (sample) {\n          if (sample && control && typeof sample.stack === \"string\") {\n            var sampleLines = sample.stack.split(`\n`);\n            var controlLines = control.stack.split(`\n`);\n            var s = sampleLines.length - 1;\n            var c = controlLines.length - 1;\n            while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n              c--;\n            }\n            for (;s >= 1 && c >= 0; s--, c--) {\n              if (sampleLines[s] !== controlLines[c]) {\n                if (s !== 1 || c !== 1) {\n                  do {\n                    s--;\n                    c--;\n                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                      var _frame = `\n` + sampleLines[s].replace(\" at new \", \" at \");\n                      if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                        _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                      }\n                      {\n                        if (typeof fn === \"function\") {\n                          componentFrameCache.set(fn, _frame);\n                        }\n                      }\n                      return _frame;\n                    }\n                  } while (s >= 1 && c >= 0);\n                }\n                break;\n              }\n            }\n          }\n        } finally {\n          reentry = false;\n          {\n            ReactCurrentDispatcher.current = previousDispatcher;\n            reenableLogs();\n          }\n          Error.prepareStackTrace = previousPrepareStackTrace;\n        }\n        var name = fn ? fn.displayName || fn.name : \"\";\n        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n        {\n          if (typeof fn === \"function\") {\n            componentFrameCache.set(fn, syntheticFrame);\n          }\n        }\n        return syntheticFrame;\n      }\n      function describeFunctionComponentFrame(fn, source, ownerFn) {\n        {\n          return describeNativeComponentFrame(fn, false);\n        }\n      }\n      function shouldConstruct(Component) {\n        var prototype = Component.prototype;\n        return !!(prototype && prototype.isReactComponent);\n      }\n      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n        if (type == null) {\n          return \"\";\n        }\n        if (typeof type === \"function\") {\n          {\n            return describeNativeComponentFrame(type, shouldConstruct(type));\n          }\n        }\n        if (typeof type === \"string\") {\n          return describeBuiltInComponentFrame(type);\n        }\n        switch (type) {\n          case REACT_SUSPENSE_TYPE:\n            return describeBuiltInComponentFrame(\"Suspense\");\n          case REACT_SUSPENSE_LIST_TYPE:\n            return describeBuiltInComponentFrame(\"SuspenseList\");\n        }\n        if (typeof type === \"object\") {\n          switch (type.$$typeof) {\n            case REACT_FORWARD_REF_TYPE:\n              return describeFunctionComponentFrame(type.render);\n            case REACT_MEMO_TYPE:\n              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n            case REACT_LAZY_TYPE: {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n              try {\n                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n              } catch (x) {}\n            }\n          }\n        }\n        return \"\";\n      }\n      var hasOwnProperty = Object.prototype.hasOwnProperty;\n      var loggedTypeFailures = {};\n      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n      function setCurrentlyValidatingElement(element) {\n        {\n          if (element) {\n            var owner = element._owner;\n            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n            ReactDebugCurrentFrame.setExtraStackFrame(stack);\n          } else {\n            ReactDebugCurrentFrame.setExtraStackFrame(null);\n          }\n        }\n      }\n      function checkPropTypes(typeSpecs, values, location, componentName, element) {\n        {\n          var has = Function.call.bind(hasOwnProperty);\n          for (var typeSpecName in typeSpecs) {\n            if (has(typeSpecs, typeSpecName)) {\n              var error$1 = undefined;\n              try {\n                if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                  var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                  err.name = \"Invariant Violation\";\n                  throw err;\n                }\n                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n              } catch (ex) {\n                error$1 = ex;\n              }\n              if (error$1 && !(error$1 instanceof Error)) {\n                setCurrentlyValidatingElement(element);\n                error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                setCurrentlyValidatingElement(null);\n              }\n              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                loggedTypeFailures[error$1.message] = true;\n                setCurrentlyValidatingElement(element);\n                error(\"Failed %s type: %s\", location, error$1.message);\n                setCurrentlyValidatingElement(null);\n              }\n            }\n          }\n        }\n      }\n      var isArrayImpl = Array.isArray;\n      function isArray(a) {\n        return isArrayImpl(a);\n      }\n      function typeName(value) {\n        {\n          var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n          var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\";\n          return type;\n        }\n      }\n      function willCoercionThrow(value) {\n        {\n          try {\n            testStringCoercion(value);\n            return false;\n          } catch (e) {\n            return true;\n          }\n        }\n      }\n      function testStringCoercion(value) {\n        return \"\" + value;\n      }\n      function checkKeyStringCoercion(value) {\n        {\n          if (willCoercionThrow(value)) {\n            error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before before using it here.\", typeName(value));\n            return testStringCoercion(value);\n          }\n        }\n      }\n      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n      var RESERVED_PROPS = {\n        key: true,\n        ref: true,\n        __self: true,\n        __source: true\n      };\n      var specialPropKeyWarningShown;\n      var specialPropRefWarningShown;\n      var didWarnAboutStringRefs;\n      {\n        didWarnAboutStringRefs = {};\n      }\n      function hasValidRef(config) {\n        {\n          if (hasOwnProperty.call(config, \"ref\")) {\n            var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n            if (getter && getter.isReactWarning) {\n              return false;\n            }\n          }\n        }\n        return config.ref !== undefined;\n      }\n      function hasValidKey(config) {\n        {\n          if (hasOwnProperty.call(config, \"key\")) {\n            var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n            if (getter && getter.isReactWarning) {\n              return false;\n            }\n          }\n        }\n        return config.key !== undefined;\n      }\n      function warnIfStringRefCannotBeAutoConverted(config, self) {\n        {\n          if (typeof config.ref === \"string\" && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n            var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n            if (!didWarnAboutStringRefs[componentName]) {\n              error('Component \"%s\" contains the string ref \"%s\". ' + \"Support for string refs will be removed in a future major release. \" + \"This case cannot be automatically converted to an arrow function. \" + \"We ask you to manually fix this case by using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n              didWarnAboutStringRefs[componentName] = true;\n            }\n          }\n        }\n      }\n      function defineKeyPropWarningGetter(props, displayName) {\n        {\n          var warnAboutAccessingKey = function() {\n            if (!specialPropKeyWarningShown) {\n              specialPropKeyWarningShown = true;\n              error(\"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n            }\n          };\n          warnAboutAccessingKey.isReactWarning = true;\n          Object.defineProperty(props, \"key\", {\n            get: warnAboutAccessingKey,\n            configurable: true\n          });\n        }\n      }\n      function defineRefPropWarningGetter(props, displayName) {\n        {\n          var warnAboutAccessingRef = function() {\n            if (!specialPropRefWarningShown) {\n              specialPropRefWarningShown = true;\n              error(\"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n            }\n          };\n          warnAboutAccessingRef.isReactWarning = true;\n          Object.defineProperty(props, \"ref\", {\n            get: warnAboutAccessingRef,\n            configurable: true\n          });\n        }\n      }\n      var ReactElement = function(type, key, ref, self, source, owner, props) {\n        var element = {\n          $$typeof: REACT_ELEMENT_TYPE,\n          type,\n          key,\n          ref,\n          props,\n          _owner: owner\n        };\n        {\n          element._store = {};\n          Object.defineProperty(element._store, \"validated\", {\n            configurable: false,\n            enumerable: false,\n            writable: true,\n            value: false\n          });\n          Object.defineProperty(element, \"_self\", {\n            configurable: false,\n            enumerable: false,\n            writable: false,\n            value: self\n          });\n          Object.defineProperty(element, \"_source\", {\n            configurable: false,\n            enumerable: false,\n            writable: false,\n            value: source\n          });\n          if (Object.freeze) {\n            Object.freeze(element.props);\n            Object.freeze(element);\n          }\n        }\n        return element;\n      };\n      function jsxDEV(type, config, maybeKey, source, self) {\n        {\n          var propName;\n          var props = {};\n          var key = null;\n          var ref = null;\n          if (maybeKey !== undefined) {\n            {\n              checkKeyStringCoercion(maybeKey);\n            }\n            key = \"\" + maybeKey;\n          }\n          if (hasValidKey(config)) {\n            {\n              checkKeyStringCoercion(config.key);\n            }\n            key = \"\" + config.key;\n          }\n          if (hasValidRef(config)) {\n            ref = config.ref;\n            warnIfStringRefCannotBeAutoConverted(config, self);\n          }\n          for (propName in config) {\n            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n              props[propName] = config[propName];\n            }\n          }\n          if (type && type.defaultProps) {\n            var defaultProps = type.defaultProps;\n            for (propName in defaultProps) {\n              if (props[propName] === undefined) {\n                props[propName] = defaultProps[propName];\n              }\n            }\n          }\n          if (key || ref) {\n            var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n            if (key) {\n              defineKeyPropWarningGetter(props, displayName);\n            }\n            if (ref) {\n              defineRefPropWarningGetter(props, displayName);\n            }\n          }\n          return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n        }\n      }\n      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n      function setCurrentlyValidatingElement$1(element) {\n        {\n          if (element) {\n            var owner = element._owner;\n            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n          } else {\n            ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n          }\n        }\n      }\n      var propTypesMisspellWarningShown;\n      {\n        propTypesMisspellWarningShown = false;\n      }\n      function isValidElement(object) {\n        {\n          return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n        }\n      }\n      function getDeclarationErrorAddendum() {\n        {\n          if (ReactCurrentOwner$1.current) {\n            var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n            if (name) {\n              return `\n\nCheck the render method of \\`` + name + \"`.\";\n            }\n          }\n          return \"\";\n        }\n      }\n      function getSourceInfoErrorAddendum(source) {\n        {\n          if (source !== undefined) {\n            var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n            var lineNumber = source.lineNumber;\n            return `\n\nCheck your code at ` + fileName + \":\" + lineNumber + \".\";\n          }\n          return \"\";\n        }\n      }\n      var ownerHasKeyUseWarning = {};\n      function getCurrentComponentErrorInfo(parentType) {\n        {\n          var info = getDeclarationErrorAddendum();\n          if (!info) {\n            var parentName = typeof parentType === \"string\" ? parentType : parentType.displayName || parentType.name;\n            if (parentName) {\n              info = `\n\nCheck the top-level render call using <` + parentName + \">.\";\n            }\n          }\n          return info;\n        }\n      }\n      function validateExplicitKey(element, parentType) {\n        {\n          if (!element._store || element._store.validated || element.key != null) {\n            return;\n          }\n          element._store.validated = true;\n          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n            return;\n          }\n          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n          var childOwner = \"\";\n          if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n            childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n          }\n          setCurrentlyValidatingElement$1(element);\n          error('Each child in a list should have a unique \"key\" prop.' + \"%s%s See https://reactjs.org/link/warning-keys for more information.\", currentComponentErrorInfo, childOwner);\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n      function validateChildKeys(node, parentType) {\n        {\n          if (typeof node !== \"object\") {\n            return;\n          }\n          if (isArray(node)) {\n            for (var i = 0;i < node.length; i++) {\n              var child = node[i];\n              if (isValidElement(child)) {\n                validateExplicitKey(child, parentType);\n              }\n            }\n          } else if (isValidElement(node)) {\n            if (node._store) {\n              node._store.validated = true;\n            }\n          } else if (node) {\n            var iteratorFn = getIteratorFn(node);\n            if (typeof iteratorFn === \"function\") {\n              if (iteratorFn !== node.entries) {\n                var iterator = iteratorFn.call(node);\n                var step;\n                while (!(step = iterator.next()).done) {\n                  if (isValidElement(step.value)) {\n                    validateExplicitKey(step.value, parentType);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      function validatePropTypes(element) {\n        {\n          var type = element.type;\n          if (type === null || type === undefined || typeof type === \"string\") {\n            return;\n          }\n          var propTypes;\n          if (typeof type === \"function\") {\n            propTypes = type.propTypes;\n          } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {\n            propTypes = type.propTypes;\n          } else {\n            return;\n          }\n          if (propTypes) {\n            var name = getComponentNameFromType(type);\n            checkPropTypes(propTypes, element.props, \"prop\", name, element);\n          } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n            propTypesMisspellWarningShown = true;\n            var _name = getComponentNameFromType(type);\n            error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n          }\n          if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n            error(\"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\");\n          }\n        }\n      }\n      function validateFragmentProps(fragment) {\n        {\n          var keys = Object.keys(fragment.props);\n          for (var i = 0;i < keys.length; i++) {\n            var key = keys[i];\n            if (key !== \"children\" && key !== \"key\") {\n              setCurrentlyValidatingElement$1(fragment);\n              error(\"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.\", key);\n              setCurrentlyValidatingElement$1(null);\n              break;\n            }\n          }\n          if (fragment.ref !== null) {\n            setCurrentlyValidatingElement$1(fragment);\n            error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n            setCurrentlyValidatingElement$1(null);\n          }\n        }\n      }\n      var didWarnAboutKeySpread = {};\n      function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n        {\n          var validType = isValidElementType(type);\n          if (!validType) {\n            var info = \"\";\n            if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n              info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n            }\n            var sourceInfo = getSourceInfoErrorAddendum(source);\n            if (sourceInfo) {\n              info += sourceInfo;\n            } else {\n              info += getDeclarationErrorAddendum();\n            }\n            var typeString;\n            if (type === null) {\n              typeString = \"null\";\n            } else if (isArray(type)) {\n              typeString = \"array\";\n            } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n              typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n              info = \" Did you accidentally export a JSX literal instead of a component?\";\n            } else {\n              typeString = typeof type;\n            }\n            error(\"React.jsx: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n          }\n          var element = jsxDEV(type, props, key, source, self);\n          if (element == null) {\n            return element;\n          }\n          if (validType) {\n            var children = props.children;\n            if (children !== undefined) {\n              if (isStaticChildren) {\n                if (isArray(children)) {\n                  for (var i = 0;i < children.length; i++) {\n                    validateChildKeys(children[i], type);\n                  }\n                  if (Object.freeze) {\n                    Object.freeze(children);\n                  }\n                } else {\n                  error(\"React.jsx: Static children should always be an array. \" + \"You are likely explicitly calling React.jsxs or React.jsxDEV. \" + \"Use the Babel transform instead.\");\n                }\n              } else {\n                validateChildKeys(children, type);\n              }\n            }\n          }\n          {\n            if (hasOwnProperty.call(props, \"key\")) {\n              var componentName = getComponentNameFromType(type);\n              var keys = Object.keys(props).filter(function(k) {\n                return k !== \"key\";\n              });\n              var beforeExample = keys.length > 0 ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n              if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n                var afterExample = keys.length > 0 ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\";\n                error(`A props object containing a \"key\" prop is being spread into JSX:\n` + `  let props = %s;\n` + `  <%s {...props} />\n` + `React keys must be passed directly to JSX without using spread:\n` + `  let props = %s;\n` + \"  <%s key={someKey} {...props} />\", beforeExample, componentName, afterExample, componentName);\n                didWarnAboutKeySpread[componentName + beforeExample] = true;\n              }\n            }\n          }\n          if (type === REACT_FRAGMENT_TYPE) {\n            validateFragmentProps(element);\n          } else {\n            validatePropTypes(element);\n          }\n          return element;\n        }\n      }\n      var jsxDEV$1 = jsxWithValidation;\n      exports.Fragment = REACT_FRAGMENT_TYPE;\n      exports.jsxDEV = jsxDEV$1;\n    })();\n  }\n});\n\n// ../../node_modules/.bun/react@18.3.1/node_modules/react/jsx-dev-runtime.js\nvar require_jsx_dev_runtime = __commonJS((exports, module) => {\n  var react_jsx_dev_runtime_development = __toESM(require_react_jsx_dev_runtime_development(), 1);\n  if (false) {} else {\n    module.exports = react_jsx_dev_runtime_development;\n  }\n});\n\n// ../../node_modules/.bun/tweakpane@4.0.5/node_modules/tweakpane/dist/tweakpane.js\n/*! Tweakpane 4.0.5 (c) 2016 cocopon, licensed under the MIT license. */\nfunction forceCast(v) {\n  return v;\n}\nfunction isEmpty(value) {\n  return value === null || value === undefined;\n}\nfunction isObject$1(value) {\n  return value !== null && typeof value === \"object\";\n}\nfunction isRecord(value) {\n  return value !== null && typeof value === \"object\";\n}\nfunction deepEqualsArray(a1, a2) {\n  if (a1.length !== a2.length) {\n    return false;\n  }\n  for (let i = 0;i < a1.length; i++) {\n    if (a1[i] !== a2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction deepMerge(r1, r2) {\n  const keys = Array.from(new Set([...Object.keys(r1), ...Object.keys(r2)]));\n  return keys.reduce((result, key) => {\n    const v1 = r1[key];\n    const v2 = r2[key];\n    return isRecord(v1) && isRecord(v2) ? Object.assign(Object.assign({}, result), { [key]: deepMerge(v1, v2) }) : Object.assign(Object.assign({}, result), { [key]: key in r2 ? v2 : v1 });\n  }, {});\n}\nfunction isBinding(value) {\n  if (!isObject$1(value)) {\n    return false;\n  }\n  return \"target\" in value;\n}\nvar CREATE_MESSAGE_MAP = {\n  alreadydisposed: () => \"View has been already disposed\",\n  invalidparams: (context) => `Invalid parameters for '${context.name}'`,\n  nomatchingcontroller: (context) => `No matching controller for '${context.key}'`,\n  nomatchingview: (context) => `No matching view for '${JSON.stringify(context.params)}'`,\n  notbindable: () => `Value is not bindable`,\n  notcompatible: (context) => `Not compatible with  plugin '${context.id}'`,\n  propertynotfound: (context) => `Property '${context.name}' not found`,\n  shouldneverhappen: () => \"This error should never happen\"\n};\n\nclass TpError {\n  static alreadyDisposed() {\n    return new TpError({ type: \"alreadydisposed\" });\n  }\n  static notBindable() {\n    return new TpError({\n      type: \"notbindable\"\n    });\n  }\n  static notCompatible(bundleId, id) {\n    return new TpError({\n      type: \"notcompatible\",\n      context: {\n        id: `${bundleId}.${id}`\n      }\n    });\n  }\n  static propertyNotFound(name) {\n    return new TpError({\n      type: \"propertynotfound\",\n      context: {\n        name\n      }\n    });\n  }\n  static shouldNeverHappen() {\n    return new TpError({ type: \"shouldneverhappen\" });\n  }\n  constructor(config) {\n    var _a;\n    this.message = (_a = CREATE_MESSAGE_MAP[config.type](forceCast(config.context))) !== null && _a !== undefined ? _a : \"Unexpected error\";\n    this.name = this.constructor.name;\n    this.stack = new Error(this.message).stack;\n    this.type = config.type;\n  }\n  toString() {\n    return this.message;\n  }\n}\n\nclass BindingTarget {\n  constructor(obj, key) {\n    this.obj_ = obj;\n    this.key = key;\n  }\n  static isBindable(obj) {\n    if (obj === null) {\n      return false;\n    }\n    if (typeof obj !== \"object\" && typeof obj !== \"function\") {\n      return false;\n    }\n    return true;\n  }\n  read() {\n    return this.obj_[this.key];\n  }\n  write(value) {\n    this.obj_[this.key] = value;\n  }\n  writeProperty(name, value) {\n    const valueObj = this.read();\n    if (!BindingTarget.isBindable(valueObj)) {\n      throw TpError.notBindable();\n    }\n    if (!(name in valueObj)) {\n      throw TpError.propertyNotFound(name);\n    }\n    valueObj[name] = value;\n  }\n}\n\nclass Emitter {\n  constructor() {\n    this.observers_ = {};\n  }\n  on(eventName, handler, opt_options) {\n    var _a;\n    let observers = this.observers_[eventName];\n    if (!observers) {\n      observers = this.observers_[eventName] = [];\n    }\n    observers.push({\n      handler,\n      key: (_a = opt_options === null || opt_options === undefined ? undefined : opt_options.key) !== null && _a !== undefined ? _a : handler\n    });\n    return this;\n  }\n  off(eventName, key) {\n    const observers = this.observers_[eventName];\n    if (observers) {\n      this.observers_[eventName] = observers.filter((observer) => {\n        return observer.key !== key;\n      });\n    }\n    return this;\n  }\n  emit(eventName, event) {\n    const observers = this.observers_[eventName];\n    if (!observers) {\n      return;\n    }\n    observers.forEach((observer) => {\n      observer.handler(event);\n    });\n  }\n}\n\nclass ComplexValue {\n  constructor(initialValue, config) {\n    var _a;\n    this.constraint_ = config === null || config === undefined ? undefined : config.constraint;\n    this.equals_ = (_a = config === null || config === undefined ? undefined : config.equals) !== null && _a !== undefined ? _a : (v1, v2) => v1 === v2;\n    this.emitter = new Emitter;\n    this.rawValue_ = initialValue;\n  }\n  get constraint() {\n    return this.constraint_;\n  }\n  get rawValue() {\n    return this.rawValue_;\n  }\n  set rawValue(rawValue) {\n    this.setRawValue(rawValue, {\n      forceEmit: false,\n      last: true\n    });\n  }\n  setRawValue(rawValue, options) {\n    const opts = options !== null && options !== undefined ? options : {\n      forceEmit: false,\n      last: true\n    };\n    const constrainedValue = this.constraint_ ? this.constraint_.constrain(rawValue) : rawValue;\n    const prevValue = this.rawValue_;\n    const changed = !this.equals_(prevValue, constrainedValue);\n    if (!changed && !opts.forceEmit) {\n      return;\n    }\n    this.emitter.emit(\"beforechange\", {\n      sender: this\n    });\n    this.rawValue_ = constrainedValue;\n    this.emitter.emit(\"change\", {\n      options: opts,\n      previousRawValue: prevValue,\n      rawValue: constrainedValue,\n      sender: this\n    });\n  }\n}\n\nclass PrimitiveValue {\n  constructor(initialValue) {\n    this.emitter = new Emitter;\n    this.value_ = initialValue;\n  }\n  get rawValue() {\n    return this.value_;\n  }\n  set rawValue(value) {\n    this.setRawValue(value, {\n      forceEmit: false,\n      last: true\n    });\n  }\n  setRawValue(value, options) {\n    const opts = options !== null && options !== undefined ? options : {\n      forceEmit: false,\n      last: true\n    };\n    const prevValue = this.value_;\n    if (prevValue === value && !opts.forceEmit) {\n      return;\n    }\n    this.emitter.emit(\"beforechange\", {\n      sender: this\n    });\n    this.value_ = value;\n    this.emitter.emit(\"change\", {\n      options: opts,\n      previousRawValue: prevValue,\n      rawValue: this.value_,\n      sender: this\n    });\n  }\n}\n\nclass ReadonlyPrimitiveValue {\n  constructor(value) {\n    this.emitter = new Emitter;\n    this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this);\n    this.onValueChange_ = this.onValueChange_.bind(this);\n    this.value_ = value;\n    this.value_.emitter.on(\"beforechange\", this.onValueBeforeChange_);\n    this.value_.emitter.on(\"change\", this.onValueChange_);\n  }\n  get rawValue() {\n    return this.value_.rawValue;\n  }\n  onValueBeforeChange_(ev) {\n    this.emitter.emit(\"beforechange\", Object.assign(Object.assign({}, ev), { sender: this }));\n  }\n  onValueChange_(ev) {\n    this.emitter.emit(\"change\", Object.assign(Object.assign({}, ev), { sender: this }));\n  }\n}\nfunction createValue(initialValue, config) {\n  const constraint = config === null || config === undefined ? undefined : config.constraint;\n  const equals = config === null || config === undefined ? undefined : config.equals;\n  if (!constraint && !equals) {\n    return new PrimitiveValue(initialValue);\n  }\n  return new ComplexValue(initialValue, config);\n}\nfunction createReadonlyValue(value) {\n  return [\n    new ReadonlyPrimitiveValue(value),\n    (rawValue, options) => {\n      value.setRawValue(rawValue, options);\n    }\n  ];\n}\n\nclass ValueMap {\n  constructor(valueMap) {\n    this.emitter = new Emitter;\n    this.valMap_ = valueMap;\n    for (const key in this.valMap_) {\n      const v = this.valMap_[key];\n      v.emitter.on(\"change\", () => {\n        this.emitter.emit(\"change\", {\n          key,\n          sender: this\n        });\n      });\n    }\n  }\n  static createCore(initialValue) {\n    const keys = Object.keys(initialValue);\n    return keys.reduce((o, key) => {\n      return Object.assign(o, {\n        [key]: createValue(initialValue[key])\n      });\n    }, {});\n  }\n  static fromObject(initialValue) {\n    const core = this.createCore(initialValue);\n    return new ValueMap(core);\n  }\n  get(key) {\n    return this.valMap_[key].rawValue;\n  }\n  set(key, value) {\n    this.valMap_[key].rawValue = value;\n  }\n  value(key) {\n    return this.valMap_[key];\n  }\n}\n\nclass DefiniteRangeConstraint {\n  constructor(config) {\n    this.values = ValueMap.fromObject({\n      max: config.max,\n      min: config.min\n    });\n  }\n  constrain(value) {\n    const max = this.values.get(\"max\");\n    const min = this.values.get(\"min\");\n    return Math.min(Math.max(value, min), max);\n  }\n}\n\nclass RangeConstraint {\n  constructor(config) {\n    this.values = ValueMap.fromObject({\n      max: config.max,\n      min: config.min\n    });\n  }\n  constrain(value) {\n    const max = this.values.get(\"max\");\n    const min = this.values.get(\"min\");\n    let result = value;\n    if (!isEmpty(min)) {\n      result = Math.max(result, min);\n    }\n    if (!isEmpty(max)) {\n      result = Math.min(result, max);\n    }\n    return result;\n  }\n}\n\nclass StepConstraint {\n  constructor(step, origin = 0) {\n    this.step = step;\n    this.origin = origin;\n  }\n  constrain(value) {\n    const o = this.origin % this.step;\n    const r = Math.round((value - o) / this.step);\n    return o + r * this.step;\n  }\n}\n\nclass NumberLiteralNode {\n  constructor(text) {\n    this.text = text;\n  }\n  evaluate() {\n    return Number(this.text);\n  }\n  toString() {\n    return this.text;\n  }\n}\nvar BINARY_OPERATION_MAP = {\n  \"**\": (v1, v2) => Math.pow(v1, v2),\n  \"*\": (v1, v2) => v1 * v2,\n  \"/\": (v1, v2) => v1 / v2,\n  \"%\": (v1, v2) => v1 % v2,\n  \"+\": (v1, v2) => v1 + v2,\n  \"-\": (v1, v2) => v1 - v2,\n  \"<<\": (v1, v2) => v1 << v2,\n  \">>\": (v1, v2) => v1 >> v2,\n  \">>>\": (v1, v2) => v1 >>> v2,\n  \"&\": (v1, v2) => v1 & v2,\n  \"^\": (v1, v2) => v1 ^ v2,\n  \"|\": (v1, v2) => v1 | v2\n};\n\nclass BinaryOperationNode {\n  constructor(operator, left, right) {\n    this.left = left;\n    this.operator = operator;\n    this.right = right;\n  }\n  evaluate() {\n    const op = BINARY_OPERATION_MAP[this.operator];\n    if (!op) {\n      throw new Error(`unexpected binary operator: '${this.operator}`);\n    }\n    return op(this.left.evaluate(), this.right.evaluate());\n  }\n  toString() {\n    return [\n      \"b(\",\n      this.left.toString(),\n      this.operator,\n      this.right.toString(),\n      \")\"\n    ].join(\" \");\n  }\n}\nvar UNARY_OPERATION_MAP = {\n  \"+\": (v) => v,\n  \"-\": (v) => -v,\n  \"~\": (v) => ~v\n};\n\nclass UnaryOperationNode {\n  constructor(operator, expr) {\n    this.operator = operator;\n    this.expression = expr;\n  }\n  evaluate() {\n    const op = UNARY_OPERATION_MAP[this.operator];\n    if (!op) {\n      throw new Error(`unexpected unary operator: '${this.operator}`);\n    }\n    return op(this.expression.evaluate());\n  }\n  toString() {\n    return [\"u(\", this.operator, this.expression.toString(), \")\"].join(\" \");\n  }\n}\nfunction combineReader(parsers) {\n  return (text, cursor) => {\n    for (let i = 0;i < parsers.length; i++) {\n      const result = parsers[i](text, cursor);\n      if (result !== \"\") {\n        return result;\n      }\n    }\n    return \"\";\n  };\n}\nfunction readWhitespace(text, cursor) {\n  var _a;\n  const m = text.substr(cursor).match(/^\\s+/);\n  return (_a = m && m[0]) !== null && _a !== undefined ? _a : \"\";\n}\nfunction readNonZeroDigit(text, cursor) {\n  const ch = text.substr(cursor, 1);\n  return ch.match(/^[1-9]$/) ? ch : \"\";\n}\nfunction readDecimalDigits(text, cursor) {\n  var _a;\n  const m = text.substr(cursor).match(/^[0-9]+/);\n  return (_a = m && m[0]) !== null && _a !== undefined ? _a : \"\";\n}\nfunction readSignedInteger(text, cursor) {\n  const ds = readDecimalDigits(text, cursor);\n  if (ds !== \"\") {\n    return ds;\n  }\n  const sign = text.substr(cursor, 1);\n  cursor += 1;\n  if (sign !== \"-\" && sign !== \"+\") {\n    return \"\";\n  }\n  const sds = readDecimalDigits(text, cursor);\n  if (sds === \"\") {\n    return \"\";\n  }\n  return sign + sds;\n}\nfunction readExponentPart(text, cursor) {\n  const e = text.substr(cursor, 1);\n  cursor += 1;\n  if (e.toLowerCase() !== \"e\") {\n    return \"\";\n  }\n  const si = readSignedInteger(text, cursor);\n  if (si === \"\") {\n    return \"\";\n  }\n  return e + si;\n}\nfunction readDecimalIntegerLiteral(text, cursor) {\n  const ch = text.substr(cursor, 1);\n  if (ch === \"0\") {\n    return ch;\n  }\n  const nzd = readNonZeroDigit(text, cursor);\n  cursor += nzd.length;\n  if (nzd === \"\") {\n    return \"\";\n  }\n  return nzd + readDecimalDigits(text, cursor);\n}\nfunction readDecimalLiteral1(text, cursor) {\n  const dil = readDecimalIntegerLiteral(text, cursor);\n  cursor += dil.length;\n  if (dil === \"\") {\n    return \"\";\n  }\n  const dot = text.substr(cursor, 1);\n  cursor += dot.length;\n  if (dot !== \".\") {\n    return \"\";\n  }\n  const dds = readDecimalDigits(text, cursor);\n  cursor += dds.length;\n  return dil + dot + dds + readExponentPart(text, cursor);\n}\nfunction readDecimalLiteral2(text, cursor) {\n  const dot = text.substr(cursor, 1);\n  cursor += dot.length;\n  if (dot !== \".\") {\n    return \"\";\n  }\n  const dds = readDecimalDigits(text, cursor);\n  cursor += dds.length;\n  if (dds === \"\") {\n    return \"\";\n  }\n  return dot + dds + readExponentPart(text, cursor);\n}\nfunction readDecimalLiteral3(text, cursor) {\n  const dil = readDecimalIntegerLiteral(text, cursor);\n  cursor += dil.length;\n  if (dil === \"\") {\n    return \"\";\n  }\n  return dil + readExponentPart(text, cursor);\n}\nvar readDecimalLiteral = combineReader([\n  readDecimalLiteral1,\n  readDecimalLiteral2,\n  readDecimalLiteral3\n]);\nfunction parseBinaryDigits(text, cursor) {\n  var _a;\n  const m = text.substr(cursor).match(/^[01]+/);\n  return (_a = m && m[0]) !== null && _a !== undefined ? _a : \"\";\n}\nfunction readBinaryIntegerLiteral(text, cursor) {\n  const prefix = text.substr(cursor, 2);\n  cursor += prefix.length;\n  if (prefix.toLowerCase() !== \"0b\") {\n    return \"\";\n  }\n  const bds = parseBinaryDigits(text, cursor);\n  if (bds === \"\") {\n    return \"\";\n  }\n  return prefix + bds;\n}\nfunction readOctalDigits(text, cursor) {\n  var _a;\n  const m = text.substr(cursor).match(/^[0-7]+/);\n  return (_a = m && m[0]) !== null && _a !== undefined ? _a : \"\";\n}\nfunction readOctalIntegerLiteral(text, cursor) {\n  const prefix = text.substr(cursor, 2);\n  cursor += prefix.length;\n  if (prefix.toLowerCase() !== \"0o\") {\n    return \"\";\n  }\n  const ods = readOctalDigits(text, cursor);\n  if (ods === \"\") {\n    return \"\";\n  }\n  return prefix + ods;\n}\nfunction readHexDigits(text, cursor) {\n  var _a;\n  const m = text.substr(cursor).match(/^[0-9a-f]+/i);\n  return (_a = m && m[0]) !== null && _a !== undefined ? _a : \"\";\n}\nfunction readHexIntegerLiteral(text, cursor) {\n  const prefix = text.substr(cursor, 2);\n  cursor += prefix.length;\n  if (prefix.toLowerCase() !== \"0x\") {\n    return \"\";\n  }\n  const hds = readHexDigits(text, cursor);\n  if (hds === \"\") {\n    return \"\";\n  }\n  return prefix + hds;\n}\nvar readNonDecimalIntegerLiteral = combineReader([\n  readBinaryIntegerLiteral,\n  readOctalIntegerLiteral,\n  readHexIntegerLiteral\n]);\nvar readNumericLiteral = combineReader([\n  readNonDecimalIntegerLiteral,\n  readDecimalLiteral\n]);\nfunction parseLiteral(text, cursor) {\n  const num = readNumericLiteral(text, cursor);\n  cursor += num.length;\n  if (num === \"\") {\n    return null;\n  }\n  return {\n    evaluable: new NumberLiteralNode(num),\n    cursor\n  };\n}\nfunction parseParenthesizedExpression(text, cursor) {\n  const op = text.substr(cursor, 1);\n  cursor += op.length;\n  if (op !== \"(\") {\n    return null;\n  }\n  const expr = parseExpression(text, cursor);\n  if (!expr) {\n    return null;\n  }\n  cursor = expr.cursor;\n  cursor += readWhitespace(text, cursor).length;\n  const cl = text.substr(cursor, 1);\n  cursor += cl.length;\n  if (cl !== \")\") {\n    return null;\n  }\n  return {\n    evaluable: expr.evaluable,\n    cursor\n  };\n}\nfunction parsePrimaryExpression(text, cursor) {\n  var _a;\n  return (_a = parseLiteral(text, cursor)) !== null && _a !== undefined ? _a : parseParenthesizedExpression(text, cursor);\n}\nfunction parseUnaryExpression(text, cursor) {\n  const expr = parsePrimaryExpression(text, cursor);\n  if (expr) {\n    return expr;\n  }\n  const op = text.substr(cursor, 1);\n  cursor += op.length;\n  if (op !== \"+\" && op !== \"-\" && op !== \"~\") {\n    return null;\n  }\n  const num = parseUnaryExpression(text, cursor);\n  if (!num) {\n    return null;\n  }\n  cursor = num.cursor;\n  return {\n    cursor,\n    evaluable: new UnaryOperationNode(op, num.evaluable)\n  };\n}\nfunction readBinaryOperator(ops, text, cursor) {\n  cursor += readWhitespace(text, cursor).length;\n  const op = ops.filter((op2) => text.startsWith(op2, cursor))[0];\n  if (!op) {\n    return null;\n  }\n  cursor += op.length;\n  cursor += readWhitespace(text, cursor).length;\n  return {\n    cursor,\n    operator: op\n  };\n}\nfunction createBinaryOperationExpressionParser(exprParser, ops) {\n  return (text, cursor) => {\n    const firstExpr = exprParser(text, cursor);\n    if (!firstExpr) {\n      return null;\n    }\n    cursor = firstExpr.cursor;\n    let expr = firstExpr.evaluable;\n    for (;; ) {\n      const op = readBinaryOperator(ops, text, cursor);\n      if (!op) {\n        break;\n      }\n      cursor = op.cursor;\n      const nextExpr = exprParser(text, cursor);\n      if (!nextExpr) {\n        return null;\n      }\n      cursor = nextExpr.cursor;\n      expr = new BinaryOperationNode(op.operator, expr, nextExpr.evaluable);\n    }\n    return expr ? {\n      cursor,\n      evaluable: expr\n    } : null;\n  };\n}\nvar parseBinaryOperationExpression = [\n  [\"**\"],\n  [\"*\", \"/\", \"%\"],\n  [\"+\", \"-\"],\n  [\"<<\", \">>>\", \">>\"],\n  [\"&\"],\n  [\"^\"],\n  [\"|\"]\n].reduce((parser, ops) => {\n  return createBinaryOperationExpressionParser(parser, ops);\n}, parseUnaryExpression);\nfunction parseExpression(text, cursor) {\n  cursor += readWhitespace(text, cursor).length;\n  return parseBinaryOperationExpression(text, cursor);\n}\nfunction parseEcmaNumberExpression(text) {\n  const expr = parseExpression(text, 0);\n  if (!expr) {\n    return null;\n  }\n  const cursor = expr.cursor + readWhitespace(text, expr.cursor).length;\n  if (cursor !== text.length) {\n    return null;\n  }\n  return expr.evaluable;\n}\nfunction parseNumber(text) {\n  var _a;\n  const r = parseEcmaNumberExpression(text);\n  return (_a = r === null || r === undefined ? undefined : r.evaluate()) !== null && _a !== undefined ? _a : null;\n}\nfunction numberFromUnknown(value) {\n  if (typeof value === \"number\") {\n    return value;\n  }\n  if (typeof value === \"string\") {\n    const pv = parseNumber(value);\n    if (!isEmpty(pv)) {\n      return pv;\n    }\n  }\n  return 0;\n}\nfunction numberToString(value) {\n  return String(value);\n}\nfunction createNumberFormatter(digits) {\n  return (value) => {\n    return value.toFixed(Math.max(Math.min(digits, 20), 0));\n  };\n}\nfunction mapRange(value, start1, end1, start2, end2) {\n  const p = (value - start1) / (end1 - start1);\n  return start2 + p * (end2 - start2);\n}\nfunction getDecimalDigits(value) {\n  const text = String(value.toFixed(10));\n  const frac = text.split(\".\")[1];\n  return frac.replace(/0+$/, \"\").length;\n}\nfunction constrainRange(value, min, max) {\n  return Math.min(Math.max(value, min), max);\n}\nfunction loopRange(value, max) {\n  return (value % max + max) % max;\n}\nfunction getSuitableDecimalDigits(params, rawValue) {\n  return !isEmpty(params.step) ? getDecimalDigits(params.step) : Math.max(getDecimalDigits(rawValue), 2);\n}\nfunction getSuitableKeyScale(params) {\n  var _a;\n  return (_a = params.step) !== null && _a !== undefined ? _a : 1;\n}\nfunction getSuitablePointerScale(params, rawValue) {\n  var _a;\n  const base = Math.abs((_a = params.step) !== null && _a !== undefined ? _a : rawValue);\n  return base === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(base)) - 1);\n}\nfunction createStepConstraint(params, initialValue) {\n  if (!isEmpty(params.step)) {\n    return new StepConstraint(params.step, initialValue);\n  }\n  return null;\n}\nfunction createRangeConstraint(params) {\n  if (!isEmpty(params.max) && !isEmpty(params.min)) {\n    return new DefiniteRangeConstraint({\n      max: params.max,\n      min: params.min\n    });\n  }\n  if (!isEmpty(params.max) || !isEmpty(params.min)) {\n    return new RangeConstraint({\n      max: params.max,\n      min: params.min\n    });\n  }\n  return null;\n}\nfunction createNumberTextPropsObject(params, initialValue) {\n  var _a, _b, _c;\n  return {\n    formatter: (_a = params.format) !== null && _a !== undefined ? _a : createNumberFormatter(getSuitableDecimalDigits(params, initialValue)),\n    keyScale: (_b = params.keyScale) !== null && _b !== undefined ? _b : getSuitableKeyScale(params),\n    pointerScale: (_c = params.pointerScale) !== null && _c !== undefined ? _c : getSuitablePointerScale(params, initialValue)\n  };\n}\nfunction createNumberTextInputParamsParser(p) {\n  return {\n    format: p.optional.function,\n    keyScale: p.optional.number,\n    max: p.optional.number,\n    min: p.optional.number,\n    pointerScale: p.optional.number,\n    step: p.optional.number\n  };\n}\nfunction createPointAxis(config) {\n  return {\n    constraint: config.constraint,\n    textProps: ValueMap.fromObject(createNumberTextPropsObject(config.params, config.initialValue))\n  };\n}\n\nclass BladeApi {\n  constructor(controller) {\n    this.controller = controller;\n  }\n  get element() {\n    return this.controller.view.element;\n  }\n  get disabled() {\n    return this.controller.viewProps.get(\"disabled\");\n  }\n  set disabled(disabled) {\n    this.controller.viewProps.set(\"disabled\", disabled);\n  }\n  get hidden() {\n    return this.controller.viewProps.get(\"hidden\");\n  }\n  set hidden(hidden) {\n    this.controller.viewProps.set(\"hidden\", hidden);\n  }\n  dispose() {\n    this.controller.viewProps.set(\"disposed\", true);\n  }\n  importState(state) {\n    return this.controller.importState(state);\n  }\n  exportState() {\n    return this.controller.exportState();\n  }\n}\n\nclass TpEvent {\n  constructor(target) {\n    this.target = target;\n  }\n}\n\nclass TpChangeEvent extends TpEvent {\n  constructor(target, value, last) {\n    super(target);\n    this.value = value;\n    this.last = last !== null && last !== undefined ? last : true;\n  }\n}\n\nclass TpFoldEvent extends TpEvent {\n  constructor(target, expanded) {\n    super(target);\n    this.expanded = expanded;\n  }\n}\n\nclass TpTabSelectEvent extends TpEvent {\n  constructor(target, index) {\n    super(target);\n    this.index = index;\n  }\n}\n\nclass TpMouseEvent extends TpEvent {\n  constructor(target, nativeEvent) {\n    super(target);\n    this.native = nativeEvent;\n  }\n}\n\nclass BindingApi extends BladeApi {\n  constructor(controller) {\n    super(controller);\n    this.onValueChange_ = this.onValueChange_.bind(this);\n    this.emitter_ = new Emitter;\n    this.controller.value.emitter.on(\"change\", this.onValueChange_);\n  }\n  get label() {\n    return this.controller.labelController.props.get(\"label\");\n  }\n  set label(label) {\n    this.controller.labelController.props.set(\"label\", label);\n  }\n  get key() {\n    return this.controller.value.binding.target.key;\n  }\n  get tag() {\n    return this.controller.tag;\n  }\n  set tag(tag) {\n    this.controller.tag = tag;\n  }\n  on(eventName, handler) {\n    const bh = handler.bind(this);\n    this.emitter_.on(eventName, (ev) => {\n      bh(ev);\n    }, {\n      key: handler\n    });\n    return this;\n  }\n  off(eventName, handler) {\n    this.emitter_.off(eventName, handler);\n    return this;\n  }\n  refresh() {\n    this.controller.value.fetch();\n  }\n  onValueChange_(ev) {\n    const value = this.controller.value;\n    this.emitter_.emit(\"change\", new TpChangeEvent(this, forceCast(value.binding.target.read()), ev.options.last));\n  }\n}\n\nclass InputBindingValue {\n  constructor(value, binding) {\n    this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this);\n    this.onValueChange_ = this.onValueChange_.bind(this);\n    this.binding = binding;\n    this.value_ = value;\n    this.value_.emitter.on(\"beforechange\", this.onValueBeforeChange_);\n    this.value_.emitter.on(\"change\", this.onValueChange_);\n    this.emitter = new Emitter;\n  }\n  get rawValue() {\n    return this.value_.rawValue;\n  }\n  set rawValue(rawValue) {\n    this.value_.rawValue = rawValue;\n  }\n  setRawValue(rawValue, options) {\n    this.value_.setRawValue(rawValue, options);\n  }\n  fetch() {\n    this.value_.rawValue = this.binding.read();\n  }\n  push() {\n    this.binding.write(this.value_.rawValue);\n  }\n  onValueBeforeChange_(ev) {\n    this.emitter.emit(\"beforechange\", Object.assign(Object.assign({}, ev), { sender: this }));\n  }\n  onValueChange_(ev) {\n    this.push();\n    this.emitter.emit(\"change\", Object.assign(Object.assign({}, ev), { sender: this }));\n  }\n}\nfunction isInputBindingValue(v) {\n  if (!(\"binding\" in v)) {\n    return false;\n  }\n  const b = v[\"binding\"];\n  return isBinding(b) && \"read\" in b && \"write\" in b;\n}\nfunction parseObject(value, keyToParserMap) {\n  const keys = Object.keys(keyToParserMap);\n  const result = keys.reduce((tmp, key) => {\n    if (tmp === undefined) {\n      return;\n    }\n    const parser = keyToParserMap[key];\n    const result2 = parser(value[key]);\n    return result2.succeeded ? Object.assign(Object.assign({}, tmp), { [key]: result2.value }) : undefined;\n  }, {});\n  return forceCast(result);\n}\nfunction parseArray(value, parseItem) {\n  return value.reduce((tmp, item) => {\n    if (tmp === undefined) {\n      return;\n    }\n    const result = parseItem(item);\n    if (!result.succeeded || result.value === undefined) {\n      return;\n    }\n    return [...tmp, result.value];\n  }, []);\n}\nfunction isObject(value) {\n  if (value === null) {\n    return false;\n  }\n  return typeof value === \"object\";\n}\nfunction createMicroParserBuilder(parse) {\n  return (optional) => (v) => {\n    if (!optional && v === undefined) {\n      return {\n        succeeded: false,\n        value: undefined\n      };\n    }\n    if (optional && v === undefined) {\n      return {\n        succeeded: true,\n        value: undefined\n      };\n    }\n    const result = parse(v);\n    return result !== undefined ? {\n      succeeded: true,\n      value: result\n    } : {\n      succeeded: false,\n      value: undefined\n    };\n  };\n}\nfunction createMicroParserBuilders(optional) {\n  return {\n    custom: (parse) => createMicroParserBuilder(parse)(optional),\n    boolean: createMicroParserBuilder((v) => typeof v === \"boolean\" ? v : undefined)(optional),\n    number: createMicroParserBuilder((v) => typeof v === \"number\" ? v : undefined)(optional),\n    string: createMicroParserBuilder((v) => typeof v === \"string\" ? v : undefined)(optional),\n    function: createMicroParserBuilder((v) => typeof v === \"function\" ? v : undefined)(optional),\n    constant: (value) => createMicroParserBuilder((v) => v === value ? value : undefined)(optional),\n    raw: createMicroParserBuilder((v) => v)(optional),\n    object: (keyToParserMap) => createMicroParserBuilder((v) => {\n      if (!isObject(v)) {\n        return;\n      }\n      return parseObject(v, keyToParserMap);\n    })(optional),\n    array: (itemParser) => createMicroParserBuilder((v) => {\n      if (!Array.isArray(v)) {\n        return;\n      }\n      return parseArray(v, itemParser);\n    })(optional)\n  };\n}\nvar MicroParsers = {\n  optional: createMicroParserBuilders(true),\n  required: createMicroParserBuilders(false)\n};\nfunction parseRecord(value, keyToParserMap) {\n  const map = keyToParserMap(MicroParsers);\n  const result = MicroParsers.required.object(map)(value);\n  return result.succeeded ? result.value : undefined;\n}\nfunction importBladeState(state, superImport, parser, callback) {\n  if (superImport && !superImport(state)) {\n    return false;\n  }\n  const result = parseRecord(state, parser);\n  return result ? callback(result) : false;\n}\nfunction exportBladeState(superExport, thisState) {\n  var _a;\n  return deepMerge((_a = superExport === null || superExport === undefined ? undefined : superExport()) !== null && _a !== undefined ? _a : {}, thisState);\n}\nfunction isValueBladeController(bc) {\n  return \"value\" in bc;\n}\nfunction isBindingValue(v) {\n  if (!isObject$1(v) || !(\"binding\" in v)) {\n    return false;\n  }\n  const b = v.binding;\n  return isBinding(b);\n}\nvar SVG_NS = \"http://www.w3.org/2000/svg\";\nfunction forceReflow(element) {\n  element.offsetHeight;\n}\nfunction disableTransitionTemporarily(element, callback) {\n  const t = element.style.transition;\n  element.style.transition = \"none\";\n  callback();\n  element.style.transition = t;\n}\nfunction supportsTouch(doc) {\n  return doc.ontouchstart !== undefined;\n}\nfunction getGlobalObject() {\n  return globalThis;\n}\nfunction getWindowDocument() {\n  const globalObj = forceCast(getGlobalObject());\n  return globalObj.document;\n}\nfunction getCanvasContext(canvasElement) {\n  const win = canvasElement.ownerDocument.defaultView;\n  if (!win) {\n    return null;\n  }\n  const isBrowser = \"document\" in win;\n  return isBrowser ? canvasElement.getContext(\"2d\", {\n    willReadFrequently: true\n  }) : null;\n}\nvar ICON_ID_TO_INNER_HTML_MAP = {\n  check: '<path d=\"M2 8l4 4l8 -8\"/>',\n  dropdown: '<path d=\"M5 7h6l-3 3 z\"/>',\n  p2dpad: '<path d=\"M8 4v8\"/><path d=\"M4 8h8\"/><circle cx=\"12\" cy=\"12\" r=\"1.2\"/>'\n};\nfunction createSvgIconElement(document2, iconId) {\n  const elem = document2.createElementNS(SVG_NS, \"svg\");\n  elem.innerHTML = ICON_ID_TO_INNER_HTML_MAP[iconId];\n  return elem;\n}\nfunction insertElementAt(parentElement, element, index) {\n  parentElement.insertBefore(element, parentElement.children[index]);\n}\nfunction removeElement(element) {\n  if (element.parentElement) {\n    element.parentElement.removeChild(element);\n  }\n}\nfunction removeChildElements(element) {\n  while (element.children.length > 0) {\n    element.removeChild(element.children[0]);\n  }\n}\nfunction removeChildNodes(element) {\n  while (element.childNodes.length > 0) {\n    element.removeChild(element.childNodes[0]);\n  }\n}\nfunction findNextTarget(ev) {\n  if (ev.relatedTarget) {\n    return forceCast(ev.relatedTarget);\n  }\n  if (\"explicitOriginalTarget\" in ev) {\n    return ev.explicitOriginalTarget;\n  }\n  return null;\n}\nfunction bindValue(value, applyValue) {\n  value.emitter.on(\"change\", (ev) => {\n    applyValue(ev.rawValue);\n  });\n  applyValue(value.rawValue);\n}\nfunction bindValueMap(valueMap, key, applyValue) {\n  bindValue(valueMap.value(key), applyValue);\n}\nvar PREFIX = \"tp\";\nfunction ClassName(viewName) {\n  const fn = (opt_elementName, opt_modifier) => {\n    return [\n      PREFIX,\n      \"-\",\n      viewName,\n      \"v\",\n      opt_elementName ? `_${opt_elementName}` : \"\",\n      opt_modifier ? `-${opt_modifier}` : \"\"\n    ].join(\"\");\n  };\n  return fn;\n}\nvar cn$r = ClassName(\"lbl\");\nfunction createLabelNode(doc, label) {\n  const frag = doc.createDocumentFragment();\n  const lineNodes = label.split(`\n`).map((line) => {\n    return doc.createTextNode(line);\n  });\n  lineNodes.forEach((lineNode, index) => {\n    if (index > 0) {\n      frag.appendChild(doc.createElement(\"br\"));\n    }\n    frag.appendChild(lineNode);\n  });\n  return frag;\n}\n\nclass LabelView {\n  constructor(doc, config) {\n    this.element = doc.createElement(\"div\");\n    this.element.classList.add(cn$r());\n    config.viewProps.bindClassModifiers(this.element);\n    const labelElem = doc.createElement(\"div\");\n    labelElem.classList.add(cn$r(\"l\"));\n    bindValueMap(config.props, \"label\", (value) => {\n      if (isEmpty(value)) {\n        this.element.classList.add(cn$r(undefined, \"nol\"));\n      } else {\n        this.element.classList.remove(cn$r(undefined, \"nol\"));\n        removeChildNodes(labelElem);\n        labelElem.appendChild(createLabelNode(doc, value));\n      }\n    });\n    this.element.appendChild(labelElem);\n    this.labelElement = labelElem;\n    const valueElem = doc.createElement(\"div\");\n    valueElem.classList.add(cn$r(\"v\"));\n    this.element.appendChild(valueElem);\n    this.valueElement = valueElem;\n  }\n}\n\nclass LabelController {\n  constructor(doc, config) {\n    this.props = config.props;\n    this.valueController = config.valueController;\n    this.viewProps = config.valueController.viewProps;\n    this.view = new LabelView(doc, {\n      props: config.props,\n      viewProps: this.viewProps\n    });\n    this.view.valueElement.appendChild(this.valueController.view.element);\n  }\n  importProps(state) {\n    return importBladeState(state, null, (p) => ({\n      label: p.optional.string\n    }), (result) => {\n      this.props.set(\"label\", result.label);\n      return true;\n    });\n  }\n  exportProps() {\n    return exportBladeState(null, {\n      label: this.props.get(\"label\")\n    });\n  }\n}\nfunction getAllBladePositions() {\n  return [\"veryfirst\", \"first\", \"last\", \"verylast\"];\n}\nvar cn$q = ClassName(\"\");\nvar POS_TO_CLASS_NAME_MAP = {\n  veryfirst: \"vfst\",\n  first: \"fst\",\n  last: \"lst\",\n  verylast: \"vlst\"\n};\n\nclass BladeController {\n  constructor(config) {\n    this.parent_ = null;\n    this.blade = config.blade;\n    this.view = config.view;\n    this.viewProps = config.viewProps;\n    const elem = this.view.element;\n    this.blade.value(\"positions\").emitter.on(\"change\", () => {\n      getAllBladePositions().forEach((pos) => {\n        elem.classList.remove(cn$q(undefined, POS_TO_CLASS_NAME_MAP[pos]));\n      });\n      this.blade.get(\"positions\").forEach((pos) => {\n        elem.classList.add(cn$q(undefined, POS_TO_CLASS_NAME_MAP[pos]));\n      });\n    });\n    this.viewProps.handleDispose(() => {\n      removeElement(elem);\n    });\n  }\n  get parent() {\n    return this.parent_;\n  }\n  set parent(parent) {\n    this.parent_ = parent;\n    this.viewProps.set(\"parent\", this.parent_ ? this.parent_.viewProps : null);\n  }\n  importState(state) {\n    return importBladeState(state, null, (p) => ({\n      disabled: p.required.boolean,\n      hidden: p.required.boolean\n    }), (result) => {\n      this.viewProps.importState(result);\n      return true;\n    });\n  }\n  exportState() {\n    return exportBladeState(null, Object.assign({}, this.viewProps.exportState()));\n  }\n}\n\nclass LabeledValueBladeController extends BladeController {\n  constructor(doc, config) {\n    if (config.value !== config.valueController.value) {\n      throw TpError.shouldNeverHappen();\n    }\n    const viewProps = config.valueController.viewProps;\n    const lc = new LabelController(doc, {\n      blade: config.blade,\n      props: config.props,\n      valueController: config.valueController\n    });\n    super(Object.assign(Object.assign({}, config), { view: new LabelView(doc, {\n      props: config.props,\n      viewProps\n    }), viewProps }));\n    this.labelController = lc;\n    this.value = config.value;\n    this.valueController = config.valueController;\n    this.view.valueElement.appendChild(this.valueController.view.element);\n  }\n  importState(state) {\n    return importBladeState(state, (s) => {\n      var _a, _b, _c;\n      return super.importState(s) && this.labelController.importProps(s) && ((_c = (_b = (_a = this.valueController).importProps) === null || _b === undefined ? undefined : _b.call(_a, state)) !== null && _c !== undefined ? _c : true);\n    }, (p) => ({\n      value: p.optional.raw\n    }), (result) => {\n      if (result.value) {\n        this.value.rawValue = result.value;\n      }\n      return true;\n    });\n  }\n  exportState() {\n    var _a, _b, _c;\n    return exportBladeState(() => super.exportState(), Object.assign(Object.assign({ value: this.value.rawValue }, this.labelController.exportProps()), (_c = (_b = (_a = this.valueController).exportProps) === null || _b === undefined ? undefined : _b.call(_a)) !== null && _c !== undefined ? _c : {}));\n  }\n}\nfunction excludeValue(state) {\n  const result = Object.assign({}, state);\n  delete result.value;\n  return result;\n}\n\nclass BindingController extends LabeledValueBladeController {\n  constructor(doc, config) {\n    super(doc, config);\n    this.tag = config.tag;\n  }\n  importState(state) {\n    return importBladeState(state, (_s) => super.importState(excludeValue(state)), (p) => ({\n      tag: p.optional.string\n    }), (result) => {\n      this.tag = result.tag;\n      return true;\n    });\n  }\n  exportState() {\n    return exportBladeState(() => excludeValue(super.exportState()), {\n      binding: {\n        key: this.value.binding.target.key,\n        value: this.value.binding.target.read()\n      },\n      tag: this.tag\n    });\n  }\n}\nfunction isBindingController(bc) {\n  return isValueBladeController(bc) && isBindingValue(bc.value);\n}\n\nclass InputBindingController extends BindingController {\n  importState(state) {\n    return importBladeState(state, (s) => super.importState(s), (p) => ({\n      binding: p.required.object({\n        value: p.required.raw\n      })\n    }), (result) => {\n      this.value.binding.inject(result.binding.value);\n      this.value.fetch();\n      return true;\n    });\n  }\n}\nfunction isInputBindingController(bc) {\n  return isValueBladeController(bc) && isInputBindingValue(bc.value);\n}\nfunction fillBuffer(buffer, bufferSize) {\n  while (buffer.length < bufferSize) {\n    buffer.push(undefined);\n  }\n}\nfunction initializeBuffer(bufferSize) {\n  const buffer = [];\n  fillBuffer(buffer, bufferSize);\n  return buffer;\n}\nfunction createTrimmedBuffer(buffer) {\n  const index = buffer.indexOf(undefined);\n  return forceCast(index < 0 ? buffer : buffer.slice(0, index));\n}\nfunction createPushedBuffer(buffer, newValue) {\n  const newBuffer = [...createTrimmedBuffer(buffer), newValue];\n  if (newBuffer.length > buffer.length) {\n    newBuffer.splice(0, newBuffer.length - buffer.length);\n  } else {\n    fillBuffer(newBuffer, buffer.length);\n  }\n  return newBuffer;\n}\n\nclass MonitorBindingValue {\n  constructor(config) {\n    this.emitter = new Emitter;\n    this.onTick_ = this.onTick_.bind(this);\n    this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this);\n    this.onValueChange_ = this.onValueChange_.bind(this);\n    this.binding = config.binding;\n    this.value_ = createValue(initializeBuffer(config.bufferSize));\n    this.value_.emitter.on(\"beforechange\", this.onValueBeforeChange_);\n    this.value_.emitter.on(\"change\", this.onValueChange_);\n    this.ticker = config.ticker;\n    this.ticker.emitter.on(\"tick\", this.onTick_);\n    this.fetch();\n  }\n  get rawValue() {\n    return this.value_.rawValue;\n  }\n  set rawValue(rawValue) {\n    this.value_.rawValue = rawValue;\n  }\n  setRawValue(rawValue, options) {\n    this.value_.setRawValue(rawValue, options);\n  }\n  fetch() {\n    this.value_.rawValue = createPushedBuffer(this.value_.rawValue, this.binding.read());\n  }\n  onTick_() {\n    this.fetch();\n  }\n  onValueBeforeChange_(ev) {\n    this.emitter.emit(\"beforechange\", Object.assign(Object.assign({}, ev), { sender: this }));\n  }\n  onValueChange_(ev) {\n    this.emitter.emit(\"change\", Object.assign(Object.assign({}, ev), { sender: this }));\n  }\n}\nfunction isMonitorBindingValue(v) {\n  if (!(\"binding\" in v)) {\n    return false;\n  }\n  const b = v[\"binding\"];\n  return isBinding(b) && \"read\" in b && !(\"write\" in b);\n}\n\nclass MonitorBindingController extends BindingController {\n  exportState() {\n    return exportBladeState(() => super.exportState(), {\n      binding: {\n        readonly: true\n      }\n    });\n  }\n}\nfunction isMonitorBindingController(bc) {\n  return isValueBladeController(bc) && isMonitorBindingValue(bc.value);\n}\n\nclass ButtonApi extends BladeApi {\n  get label() {\n    return this.controller.labelController.props.get(\"label\");\n  }\n  set label(label) {\n    this.controller.labelController.props.set(\"label\", label);\n  }\n  get title() {\n    var _a;\n    return (_a = this.controller.buttonController.props.get(\"title\")) !== null && _a !== undefined ? _a : \"\";\n  }\n  set title(title) {\n    this.controller.buttonController.props.set(\"title\", title);\n  }\n  on(eventName, handler) {\n    const bh = handler.bind(this);\n    const emitter = this.controller.buttonController.emitter;\n    emitter.on(eventName, (ev) => {\n      bh(new TpMouseEvent(this, ev.nativeEvent));\n    });\n    return this;\n  }\n  off(eventName, handler) {\n    const emitter = this.controller.buttonController.emitter;\n    emitter.off(eventName, handler);\n    return this;\n  }\n}\nfunction applyClass(elem, className, active) {\n  if (active) {\n    elem.classList.add(className);\n  } else {\n    elem.classList.remove(className);\n  }\n}\nfunction valueToClassName(elem, className) {\n  return (value) => {\n    applyClass(elem, className, value);\n  };\n}\nfunction bindValueToTextContent(value, elem) {\n  bindValue(value, (text) => {\n    elem.textContent = text !== null && text !== undefined ? text : \"\";\n  });\n}\nvar cn$p = ClassName(\"btn\");\n\nclass ButtonView {\n  constructor(doc, config) {\n    this.element = doc.createElement(\"div\");\n    this.element.classList.add(cn$p());\n    config.viewProps.bindClassModifiers(this.element);\n    const buttonElem = doc.createElement(\"button\");\n    buttonElem.classList.add(cn$p(\"b\"));\n    config.viewProps.bindDisabled(buttonElem);\n    this.element.appendChild(buttonElem);\n    this.buttonElement = buttonElem;\n    const titleElem = doc.createElement(\"div\");\n    titleElem.classList.add(cn$p(\"t\"));\n    bindValueToTextContent(config.props.value(\"title\"), titleElem);\n    this.buttonElement.appendChild(titleElem);\n  }\n}\n\nclass ButtonController {\n  constructor(doc, config) {\n    this.emitter = new Emitter;\n    this.onClick_ = this.onClick_.bind(this);\n    this.props = config.props;\n    this.viewProps = config.viewProps;\n    this.view = new ButtonView(doc, {\n      props: this.props,\n      viewProps: this.viewProps\n    });\n    this.view.buttonElement.addEventListener(\"click\", this.onClick_);\n  }\n  importProps(state) {\n    return importBladeState(state, null, (p) => ({\n      title: p.optional.string\n    }), (result) => {\n      this.props.set(\"title\", result.title);\n      return true;\n    });\n  }\n  exportProps() {\n    return exportBladeState(null, {\n      title: this.props.get(\"title\")\n    });\n  }\n  onClick_(ev) {\n    this.emitter.emit(\"click\", {\n      nativeEvent: ev,\n      sender: this\n    });\n  }\n}\n\nclass ButtonBladeController extends BladeController {\n  constructor(doc, config) {\n    const bc = new ButtonController(doc, {\n      props: config.buttonProps,\n      viewProps: config.viewProps\n    });\n    const lc = new LabelController(doc, {\n      blade: config.blade,\n      props: config.labelProps,\n      valueController: bc\n    });\n    super({\n      blade: config.blade,\n      view: lc.view,\n      viewProps: config.viewProps\n    });\n    this.buttonController = bc;\n    this.labelController = lc;\n  }\n  importState(state) {\n    return importBladeState(state, (s) => super.importState(s) && this.buttonController.importProps(s) && this.labelController.importProps(s), () => ({}), () => true);\n  }\n  exportState() {\n    return exportBladeState(() => super.exportState(), Object.assign(Object.assign({}, this.buttonController.exportProps()), this.labelController.exportProps()));\n  }\n}\n\nclass Semver {\n  constructor(text) {\n    const [core, prerelease] = text.split(\"-\");\n    const coreComps = core.split(\".\");\n    this.major = parseInt(coreComps[0], 10);\n    this.minor = parseInt(coreComps[1], 10);\n    this.patch = parseInt(coreComps[2], 10);\n    this.prerelease = prerelease !== null && prerelease !== undefined ? prerelease : null;\n  }\n  toString() {\n    const core = [this.major, this.minor, this.patch].join(\".\");\n    return this.prerelease !== null ? [core, this.prerelease].join(\"-\") : core;\n  }\n}\nvar VERSION$1 = new Semver(\"2.0.5\");\nfunction createPlugin(plugin) {\n  return Object.assign({ core: VERSION$1 }, plugin);\n}\nvar ButtonBladePlugin = createPlugin({\n  id: \"button\",\n  type: \"blade\",\n  accept(params) {\n    const result = parseRecord(params, (p) => ({\n      title: p.required.string,\n      view: p.required.constant(\"button\"),\n      label: p.optional.string\n    }));\n    return result ? { params: result } : null;\n  },\n  controller(args) {\n    return new ButtonBladeController(args.document, {\n      blade: args.blade,\n      buttonProps: ValueMap.fromObject({\n        title: args.params.title\n      }),\n      labelProps: ValueMap.fromObject({\n        label: args.params.label\n      }),\n      viewProps: args.viewProps\n    });\n  },\n  api(args) {\n    if (args.controller instanceof ButtonBladeController) {\n      return new ButtonApi(args.controller);\n    }\n    return null;\n  }\n});\nfunction addButtonAsBlade(api, params) {\n  return api.addBlade(Object.assign(Object.assign({}, params), { view: \"button\" }));\n}\nfunction addFolderAsBlade(api, params) {\n  return api.addBlade(Object.assign(Object.assign({}, params), { view: \"folder\" }));\n}\nfunction addTabAsBlade(api, params) {\n  return api.addBlade(Object.assign(Object.assign({}, params), { view: \"tab\" }));\n}\nfunction isRefreshable(value) {\n  if (!isObject$1(value)) {\n    return false;\n  }\n  return \"refresh\" in value && typeof value.refresh === \"function\";\n}\nfunction createBindingTarget(obj, key) {\n  if (!BindingTarget.isBindable(obj)) {\n    throw TpError.notBindable();\n  }\n  return new BindingTarget(obj, key);\n}\n\nclass RackApi {\n  constructor(controller, pool) {\n    this.onRackValueChange_ = this.onRackValueChange_.bind(this);\n    this.controller_ = controller;\n    this.emitter_ = new Emitter;\n    this.pool_ = pool;\n    const rack = this.controller_.rack;\n    rack.emitter.on(\"valuechange\", this.onRackValueChange_);\n  }\n  get children() {\n    return this.controller_.rack.children.map((bc) => this.pool_.createApi(bc));\n  }\n  addBinding(object, key, opt_params) {\n    const params = opt_params !== null && opt_params !== undefined ? opt_params : {};\n    const doc = this.controller_.element.ownerDocument;\n    const bc = this.pool_.createBinding(doc, createBindingTarget(object, key), params);\n    const api = this.pool_.createBindingApi(bc);\n    return this.add(api, params.index);\n  }\n  addFolder(params) {\n    return addFolderAsBlade(this, params);\n  }\n  addButton(params) {\n    return addButtonAsBlade(this, params);\n  }\n  addTab(params) {\n    return addTabAsBlade(this, params);\n  }\n  add(api, opt_index) {\n    const bc = api.controller;\n    this.controller_.rack.add(bc, opt_index);\n    return api;\n  }\n  remove(api) {\n    this.controller_.rack.remove(api.controller);\n  }\n  addBlade(params) {\n    const doc = this.controller_.element.ownerDocument;\n    const bc = this.pool_.createBlade(doc, params);\n    const api = this.pool_.createApi(bc);\n    return this.add(api, params.index);\n  }\n  on(eventName, handler) {\n    const bh = handler.bind(this);\n    this.emitter_.on(eventName, (ev) => {\n      bh(ev);\n    }, {\n      key: handler\n    });\n    return this;\n  }\n  off(eventName, handler) {\n    this.emitter_.off(eventName, handler);\n    return this;\n  }\n  refresh() {\n    this.children.forEach((c) => {\n      if (isRefreshable(c)) {\n        c.refresh();\n      }\n    });\n  }\n  onRackValueChange_(ev) {\n    const bc = ev.bladeController;\n    const api = this.pool_.createApi(bc);\n    const binding = isBindingValue(bc.value) ? bc.value.binding : null;\n    this.emitter_.emit(\"change\", new TpChangeEvent(api, binding ? binding.target.read() : bc.value.rawValue, ev.options.last));\n  }\n}\n\nclass ContainerBladeApi extends BladeApi {\n  constructor(controller, pool) {\n    super(controller);\n    this.rackApi_ = new RackApi(controller.rackController, pool);\n  }\n  refresh() {\n    this.rackApi_.refresh();\n  }\n}\n\nclass ContainerBladeController extends BladeController {\n  constructor(config) {\n    super({\n      blade: config.blade,\n      view: config.view,\n      viewProps: config.rackController.viewProps\n    });\n    this.rackController = config.rackController;\n  }\n  importState(state) {\n    return importBladeState(state, (s) => super.importState(s), (p) => ({\n      children: p.required.array(p.required.raw)\n    }), (result) => {\n      return this.rackController.rack.children.every((c, index) => {\n        return c.importState(result.children[index]);\n      });\n    });\n  }\n  exportState() {\n    return exportBladeState(() => super.exportState(), {\n      children: this.rackController.rack.children.map((c) => c.exportState())\n    });\n  }\n}\nfunction isContainerBladeController(bc) {\n  return \"rackController\" in bc;\n}\n\nclass NestedOrderedSet {\n  constructor(extract) {\n    this.emitter = new Emitter;\n    this.items_ = [];\n    this.cache_ = new Set;\n    this.onSubListAdd_ = this.onSubListAdd_.bind(this);\n    this.onSubListRemove_ = this.onSubListRemove_.bind(this);\n    this.extract_ = extract;\n  }\n  get items() {\n    return this.items_;\n  }\n  allItems() {\n    return Array.from(this.cache_);\n  }\n  find(callback) {\n    for (const item of this.allItems()) {\n      if (callback(item)) {\n        return item;\n      }\n    }\n    return null;\n  }\n  includes(item) {\n    return this.cache_.has(item);\n  }\n  add(item, opt_index) {\n    if (this.includes(item)) {\n      throw TpError.shouldNeverHappen();\n    }\n    const index = opt_index !== undefined ? opt_index : this.items_.length;\n    this.items_.splice(index, 0, item);\n    this.cache_.add(item);\n    const subList = this.extract_(item);\n    if (subList) {\n      subList.emitter.on(\"add\", this.onSubListAdd_);\n      subList.emitter.on(\"remove\", this.onSubListRemove_);\n      subList.allItems().forEach((i) => {\n        this.cache_.add(i);\n      });\n    }\n    this.emitter.emit(\"add\", {\n      index,\n      item,\n      root: this,\n      target: this\n    });\n  }\n  remove(item) {\n    const index = this.items_.indexOf(item);\n    if (index < 0) {\n      return;\n    }\n    this.items_.splice(index, 1);\n    this.cache_.delete(item);\n    const subList = this.extract_(item);\n    if (subList) {\n      subList.allItems().forEach((i) => {\n        this.cache_.delete(i);\n      });\n      subList.emitter.off(\"add\", this.onSubListAdd_);\n      subList.emitter.off(\"remove\", this.onSubListRemove_);\n    }\n    this.emitter.emit(\"remove\", {\n      index,\n      item,\n      root: this,\n      target: this\n    });\n  }\n  onSubListAdd_(ev) {\n    this.cache_.add(ev.item);\n    this.emitter.emit(\"add\", {\n      index: ev.index,\n      item: ev.item,\n      root: this,\n      target: ev.target\n    });\n  }\n  onSubListRemove_(ev) {\n    this.cache_.delete(ev.item);\n    this.emitter.emit(\"remove\", {\n      index: ev.index,\n      item: ev.item,\n      root: this,\n      target: ev.target\n    });\n  }\n}\nfunction findValueBladeController(bcs, v) {\n  for (let i = 0;i < bcs.length; i++) {\n    const bc = bcs[i];\n    if (isValueBladeController(bc) && bc.value === v) {\n      return bc;\n    }\n  }\n  return null;\n}\nfunction findSubBladeControllerSet(bc) {\n  return isContainerBladeController(bc) ? bc.rackController.rack[\"bcSet_\"] : null;\n}\n\nclass Rack {\n  constructor(config) {\n    var _a, _b;\n    this.emitter = new Emitter;\n    this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this);\n    this.onSetAdd_ = this.onSetAdd_.bind(this);\n    this.onSetRemove_ = this.onSetRemove_.bind(this);\n    this.onChildDispose_ = this.onChildDispose_.bind(this);\n    this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this);\n    this.onChildValueChange_ = this.onChildValueChange_.bind(this);\n    this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this);\n    this.onRackLayout_ = this.onRackLayout_.bind(this);\n    this.onRackValueChange_ = this.onRackValueChange_.bind(this);\n    this.blade_ = (_a = config.blade) !== null && _a !== undefined ? _a : null;\n    (_b = this.blade_) === null || _b === undefined || _b.value(\"positions\").emitter.on(\"change\", this.onBladePositionsChange_);\n    this.viewProps = config.viewProps;\n    this.bcSet_ = new NestedOrderedSet(findSubBladeControllerSet);\n    this.bcSet_.emitter.on(\"add\", this.onSetAdd_);\n    this.bcSet_.emitter.on(\"remove\", this.onSetRemove_);\n  }\n  get children() {\n    return this.bcSet_.items;\n  }\n  add(bc, opt_index) {\n    var _a;\n    (_a = bc.parent) === null || _a === undefined || _a.remove(bc);\n    bc.parent = this;\n    this.bcSet_.add(bc, opt_index);\n  }\n  remove(bc) {\n    bc.parent = null;\n    this.bcSet_.remove(bc);\n  }\n  find(finder) {\n    return this.bcSet_.allItems().filter(finder);\n  }\n  onSetAdd_(ev) {\n    this.updatePositions_();\n    const root = ev.target === ev.root;\n    this.emitter.emit(\"add\", {\n      bladeController: ev.item,\n      index: ev.index,\n      root,\n      sender: this\n    });\n    if (!root) {\n      return;\n    }\n    const bc = ev.item;\n    bc.viewProps.emitter.on(\"change\", this.onChildViewPropsChange_);\n    bc.blade.value(\"positions\").emitter.on(\"change\", this.onChildPositionsChange_);\n    bc.viewProps.handleDispose(this.onChildDispose_);\n    if (isValueBladeController(bc)) {\n      bc.value.emitter.on(\"change\", this.onChildValueChange_);\n    } else if (isContainerBladeController(bc)) {\n      const rack = bc.rackController.rack;\n      if (rack) {\n        const emitter = rack.emitter;\n        emitter.on(\"layout\", this.onRackLayout_);\n        emitter.on(\"valuechange\", this.onRackValueChange_);\n      }\n    }\n  }\n  onSetRemove_(ev) {\n    this.updatePositions_();\n    const root = ev.target === ev.root;\n    this.emitter.emit(\"remove\", {\n      bladeController: ev.item,\n      root,\n      sender: this\n    });\n    if (!root) {\n      return;\n    }\n    const bc = ev.item;\n    if (isValueBladeController(bc)) {\n      bc.value.emitter.off(\"change\", this.onChildValueChange_);\n    } else if (isContainerBladeController(bc)) {\n      const rack = bc.rackController.rack;\n      if (rack) {\n        const emitter = rack.emitter;\n        emitter.off(\"layout\", this.onRackLayout_);\n        emitter.off(\"valuechange\", this.onRackValueChange_);\n      }\n    }\n  }\n  updatePositions_() {\n    const visibleItems = this.bcSet_.items.filter((bc) => !bc.viewProps.get(\"hidden\"));\n    const firstVisibleItem = visibleItems[0];\n    const lastVisibleItem = visibleItems[visibleItems.length - 1];\n    this.bcSet_.items.forEach((bc) => {\n      const ps = [];\n      if (bc === firstVisibleItem) {\n        ps.push(\"first\");\n        if (!this.blade_ || this.blade_.get(\"positions\").includes(\"veryfirst\")) {\n          ps.push(\"veryfirst\");\n        }\n      }\n      if (bc === lastVisibleItem) {\n        ps.push(\"last\");\n        if (!this.blade_ || this.blade_.get(\"positions\").includes(\"verylast\")) {\n          ps.push(\"verylast\");\n        }\n      }\n      bc.blade.set(\"positions\", ps);\n    });\n  }\n  onChildPositionsChange_() {\n    this.updatePositions_();\n    this.emitter.emit(\"layout\", {\n      sender: this\n    });\n  }\n  onChildViewPropsChange_(_ev) {\n    this.updatePositions_();\n    this.emitter.emit(\"layout\", {\n      sender: this\n    });\n  }\n  onChildDispose_() {\n    const disposedUcs = this.bcSet_.items.filter((bc) => {\n      return bc.viewProps.get(\"disposed\");\n    });\n    disposedUcs.forEach((bc) => {\n      this.bcSet_.remove(bc);\n    });\n  }\n  onChildValueChange_(ev) {\n    const bc = findValueBladeController(this.find(isValueBladeController), ev.sender);\n    if (!bc) {\n      throw TpError.alreadyDisposed();\n    }\n    this.emitter.emit(\"valuechange\", {\n      bladeController: bc,\n      options: ev.options,\n      sender: this\n    });\n  }\n  onRackLayout_(_) {\n    this.updatePositions_();\n    this.emitter.emit(\"layout\", {\n      sender: this\n    });\n  }\n  onRackValueChange_(ev) {\n    this.emitter.emit(\"valuechange\", {\n      bladeController: ev.bladeController,\n      options: ev.options,\n      sender: this\n    });\n  }\n  onBladePositionsChange_() {\n    this.updatePositions_();\n  }\n}\n\nclass RackController {\n  constructor(config) {\n    this.onRackAdd_ = this.onRackAdd_.bind(this);\n    this.onRackRemove_ = this.onRackRemove_.bind(this);\n    this.element = config.element;\n    this.viewProps = config.viewProps;\n    const rack = new Rack({\n      blade: config.root ? undefined : config.blade,\n      viewProps: config.viewProps\n    });\n    rack.emitter.on(\"add\", this.onRackAdd_);\n    rack.emitter.on(\"remove\", this.onRackRemove_);\n    this.rack = rack;\n    this.viewProps.handleDispose(() => {\n      for (let i = this.rack.children.length - 1;i >= 0; i--) {\n        const bc = this.rack.children[i];\n        bc.viewProps.set(\"disposed\", true);\n      }\n    });\n  }\n  onRackAdd_(ev) {\n    if (!ev.root) {\n      return;\n    }\n    insertElementAt(this.element, ev.bladeController.view.element, ev.index);\n  }\n  onRackRemove_(ev) {\n    if (!ev.root) {\n      return;\n    }\n    removeElement(ev.bladeController.view.element);\n  }\n}\nfunction createBlade() {\n  return new ValueMap({\n    positions: createValue([], {\n      equals: deepEqualsArray\n    })\n  });\n}\n\nclass Foldable extends ValueMap {\n  constructor(valueMap) {\n    super(valueMap);\n  }\n  static create(expanded) {\n    const coreObj = {\n      completed: true,\n      expanded,\n      expandedHeight: null,\n      shouldFixHeight: false,\n      temporaryExpanded: null\n    };\n    const core = ValueMap.createCore(coreObj);\n    return new Foldable(core);\n  }\n  get styleExpanded() {\n    var _a;\n    return (_a = this.get(\"temporaryExpanded\")) !== null && _a !== undefined ? _a : this.get(\"expanded\");\n  }\n  get styleHeight() {\n    if (!this.styleExpanded) {\n      return \"0\";\n    }\n    const exHeight = this.get(\"expandedHeight\");\n    if (this.get(\"shouldFixHeight\") && !isEmpty(exHeight)) {\n      return `${exHeight}px`;\n    }\n    return \"auto\";\n  }\n  bindExpandedClass(elem, expandedClassName) {\n    const onExpand = () => {\n      const expanded = this.styleExpanded;\n      if (expanded) {\n        elem.classList.add(expandedClassName);\n      } else {\n        elem.classList.remove(expandedClassName);\n      }\n    };\n    bindValueMap(this, \"expanded\", onExpand);\n    bindValueMap(this, \"temporaryExpanded\", onExpand);\n  }\n  cleanUpTransition() {\n    this.set(\"shouldFixHeight\", false);\n    this.set(\"expandedHeight\", null);\n    this.set(\"completed\", true);\n  }\n}\nfunction computeExpandedFolderHeight(folder, containerElement) {\n  let height = 0;\n  disableTransitionTemporarily(containerElement, () => {\n    folder.set(\"expandedHeight\", null);\n    folder.set(\"temporaryExpanded\", true);\n    forceReflow(containerElement);\n    height = containerElement.clientHeight;\n    folder.set(\"temporaryExpanded\", null);\n    forceReflow(containerElement);\n  });\n  return height;\n}\nfunction applyHeight(foldable, elem) {\n  elem.style.height = foldable.styleHeight;\n}\nfunction bindFoldable(foldable, elem) {\n  foldable.value(\"expanded\").emitter.on(\"beforechange\", () => {\n    foldable.set(\"completed\", false);\n    if (isEmpty(foldable.get(\"expandedHeight\"))) {\n      const h = computeExpandedFolderHeight(foldable, elem);\n      if (h > 0) {\n        foldable.set(\"expandedHeight\", h);\n      }\n    }\n    foldable.set(\"shouldFixHeight\", true);\n    forceReflow(elem);\n  });\n  foldable.emitter.on(\"change\", () => {\n    applyHeight(foldable, elem);\n  });\n  applyHeight(foldable, elem);\n  elem.addEventListener(\"transitionend\", (ev) => {\n    if (ev.propertyName !== \"height\") {\n      return;\n    }\n    foldable.cleanUpTransition();\n  });\n}\n\nclass FolderApi extends ContainerBladeApi {\n  constructor(controller, pool) {\n    super(controller, pool);\n    this.emitter_ = new Emitter;\n    this.controller.foldable.value(\"expanded\").emitter.on(\"change\", (ev) => {\n      this.emitter_.emit(\"fold\", new TpFoldEvent(this, ev.sender.rawValue));\n    });\n    this.rackApi_.on(\"change\", (ev) => {\n      this.emitter_.emit(\"change\", ev);\n    });\n  }\n  get expanded() {\n    return this.controller.foldable.get(\"expanded\");\n  }\n  set expanded(expanded) {\n    this.controller.foldable.set(\"expanded\", expanded);\n  }\n  get title() {\n    return this.controller.props.get(\"title\");\n  }\n  set title(title) {\n    this.controller.props.set(\"title\", title);\n  }\n  get children() {\n    return this.rackApi_.children;\n  }\n  addBinding(object, key, opt_params) {\n    return this.rackApi_.addBinding(object, key, opt_params);\n  }\n  addFolder(params) {\n    return this.rackApi_.addFolder(params);\n  }\n  addButton(params) {\n    return this.rackApi_.addButton(params);\n  }\n  addTab(params) {\n    return this.rackApi_.addTab(params);\n  }\n  add(api, opt_index) {\n    return this.rackApi_.add(api, opt_index);\n  }\n  remove(api) {\n    this.rackApi_.remove(api);\n  }\n  addBlade(params) {\n    return this.rackApi_.addBlade(params);\n  }\n  on(eventName, handler) {\n    const bh = handler.bind(this);\n    this.emitter_.on(eventName, (ev) => {\n      bh(ev);\n    }, {\n      key: handler\n    });\n    return this;\n  }\n  off(eventName, handler) {\n    this.emitter_.off(eventName, handler);\n    return this;\n  }\n}\nvar bladeContainerClassName = ClassName(\"cnt\");\n\nclass FolderView {\n  constructor(doc, config) {\n    var _a;\n    this.className_ = ClassName((_a = config.viewName) !== null && _a !== undefined ? _a : \"fld\");\n    this.element = doc.createElement(\"div\");\n    this.element.classList.add(this.className_(), bladeContainerClassName());\n    config.viewProps.bindClassModifiers(this.element);\n    this.foldable_ = config.foldable;\n    this.foldable_.bindExpandedClass(this.element, this.className_(undefined, \"expanded\"));\n    bindValueMap(this.foldable_, \"completed\", valueToClassName(this.element, this.className_(undefined, \"cpl\")));\n    const buttonElem = doc.createElement(\"button\");\n    buttonElem.classList.add(this.className_(\"b\"));\n    bindValueMap(config.props, \"title\", (title) => {\n      if (isEmpty(title)) {\n        this.element.classList.add(this.className_(undefined, \"not\"));\n      } else {\n        this.element.classList.remove(this.className_(undefined, \"not\"));\n      }\n    });\n    config.viewProps.bindDisabled(buttonElem);\n    this.element.appendChild(buttonElem);\n    this.buttonElement = buttonElem;\n    const indentElem = doc.createElement(\"div\");\n    indentElem.classList.add(this.className_(\"i\"));\n    this.element.appendChild(indentElem);\n    const titleElem = doc.createElement(\"div\");\n    titleElem.classList.add(this.className_(\"t\"));\n    bindValueToTextContent(config.props.value(\"title\"), titleElem);\n    this.buttonElement.appendChild(titleElem);\n    this.titleElement = titleElem;\n    const markElem = doc.createElement(\"div\");\n    markElem.classList.add(this.className_(\"m\"));\n    this.buttonElement.appendChild(markElem);\n    const containerElem = doc.createElement(\"div\");\n    containerElem.classList.add(this.className_(\"c\"));\n    this.element.appendChild(containerElem);\n    this.containerElement = containerElem;\n  }\n}\n\nclass FolderController extends ContainerBladeController {\n  constructor(doc, config) {\n    var _a;\n    const foldable = Foldable.create((_a = config.expanded) !== null && _a !== undefined ? _a : true);\n    const view = new FolderView(doc, {\n      foldable,\n      props: config.props,\n      viewName: config.root ? \"rot\" : undefined,\n      viewProps: config.viewProps\n    });\n    super(Object.assign(Object.assign({}, config), { rackController: new RackController({\n      blade: config.blade,\n      element: view.containerElement,\n      root: config.root,\n      viewProps: config.viewProps\n    }), view }));\n    this.onTitleClick_ = this.onTitleClick_.bind(this);\n    this.props = config.props;\n    this.foldable = foldable;\n    bindFoldable(this.foldable, this.view.containerElement);\n    this.rackController.rack.emitter.on(\"add\", () => {\n      this.foldable.cleanUpTransition();\n    });\n    this.rackController.rack.emitter.on(\"remove\", () => {\n      this.foldable.cleanUpTransition();\n    });\n    this.view.buttonElement.addEventListener(\"click\", this.onTitleClick_);\n  }\n  get document() {\n    return this.view.element.ownerDocument;\n  }\n  importState(state) {\n    return importBladeState(state, (s) => super.importState(s), (p) => ({\n      expanded: p.required.boolean,\n      title: p.optional.string\n    }), (result) => {\n      this.foldable.set(\"expanded\", result.expanded);\n      this.props.set(\"title\", result.title);\n      return true;\n    });\n  }\n  exportState() {\n    return exportBladeState(() => super.exportState(), {\n      expanded: this.foldable.get(\"expanded\"),\n      title: this.props.get(\"title\")\n    });\n  }\n  onTitleClick_() {\n    this.foldable.set(\"expanded\", !this.foldable.get(\"expanded\"));\n  }\n}\nvar FolderBladePlugin = createPlugin({\n  id: \"folder\",\n  type: \"blade\",\n  accept(params) {\n    const result = parseRecord(params, (p) => ({\n      title: p.required.string,\n      view: p.required.constant(\"folder\"),\n      expanded: p.optional.boolean\n    }));\n    return result ? { params: result } : null;\n  },\n  controller(args) {\n    return new FolderController(args.document, {\n      blade: args.blade,\n      expanded: args.params.expanded,\n      props: ValueMap.fromObject({\n        title: args.params.title\n      }),\n      viewProps: args.viewProps\n    });\n  },\n  api(args) {\n    if (!(args.controller instanceof FolderController)) {\n      return null;\n    }\n    return new FolderApi(args.controller, args.pool);\n  }\n});\nvar cn$o = ClassName(\"\");\nfunction valueToModifier(elem, modifier) {\n  return valueToClassName(elem, cn$o(undefined, modifier));\n}\n\nclass ViewProps extends ValueMap {\n  constructor(valueMap) {\n    var _a;\n    super(valueMap);\n    this.onDisabledChange_ = this.onDisabledChange_.bind(this);\n    this.onParentChange_ = this.onParentChange_.bind(this);\n    this.onParentGlobalDisabledChange_ = this.onParentGlobalDisabledChange_.bind(this);\n    [this.globalDisabled_, this.setGlobalDisabled_] = createReadonlyValue(createValue(this.getGlobalDisabled_()));\n    this.value(\"disabled\").emitter.on(\"change\", this.onDisabledChange_);\n    this.value(\"parent\").emitter.on(\"change\", this.onParentChange_);\n    (_a = this.get(\"parent\")) === null || _a === undefined || _a.globalDisabled.emitter.on(\"change\", this.onParentGlobalDisabledChange_);\n  }\n  static create(opt_initialValue) {\n    var _a, _b, _c;\n    const initialValue = opt_initialValue !== null && opt_initialValue !== undefined ? opt_initialValue : {};\n    return new ViewProps(ValueMap.createCore({\n      disabled: (_a = initialValue.disabled) !== null && _a !== undefined ? _a : false,\n      disposed: false,\n      hidden: (_b = initialValue.hidden) !== null && _b !== undefined ? _b : false,\n      parent: (_c = initialValue.parent) !== null && _c !== undefined ? _c : null\n    }));\n  }\n  get globalDisabled() {\n    return this.globalDisabled_;\n  }\n  bindClassModifiers(elem) {\n    bindValue(this.globalDisabled_, valueToModifier(elem, \"disabled\"));\n    bindValueMap(this, \"hidden\", valueToModifier(elem, \"hidden\"));\n  }\n  bindDisabled(target) {\n    bindValue(this.globalDisabled_, (disabled) => {\n      target.disabled = disabled;\n    });\n  }\n  bindTabIndex(elem) {\n    bindValue(this.globalDisabled_, (disabled) => {\n      elem.tabIndex = disabled ? -1 : 0;\n    });\n  }\n  handleDispose(callback) {\n    this.value(\"disposed\").emitter.on(\"change\", (disposed) => {\n      if (disposed) {\n        callback();\n      }\n    });\n  }\n  importState(state) {\n    this.set(\"disabled\", state.disabled);\n    this.set(\"hidden\", state.hidden);\n  }\n  exportState() {\n    return {\n      disabled: this.get(\"disabled\"),\n      hidden: this.get(\"hidden\")\n    };\n  }\n  getGlobalDisabled_() {\n    const parent = this.get(\"parent\");\n    const parentDisabled = parent ? parent.globalDisabled.rawValue : false;\n    return parentDisabled || this.get(\"disabled\");\n  }\n  updateGlobalDisabled_() {\n    this.setGlobalDisabled_(this.getGlobalDisabled_());\n  }\n  onDisabledChange_() {\n    this.updateGlobalDisabled_();\n  }\n  onParentGlobalDisabledChange_() {\n    this.updateGlobalDisabled_();\n  }\n  onParentChange_(ev) {\n    var _a;\n    const prevParent = ev.previousRawValue;\n    prevParent === null || prevParent === undefined || prevParent.globalDisabled.emitter.off(\"change\", this.onParentGlobalDisabledChange_);\n    (_a = this.get(\"parent\")) === null || _a === undefined || _a.globalDisabled.emitter.on(\"change\", this.onParentGlobalDisabledChange_);\n    this.updateGlobalDisabled_();\n  }\n}\nvar cn$n = ClassName(\"tbp\");\n\nclass TabPageView {\n  constructor(doc, config) {\n    this.element = doc.createElement(\"div\");\n    this.element.classList.add(cn$n());\n    config.viewProps.bindClassModifiers(this.element);\n    const containerElem = doc.createElement(\"div\");\n    containerElem.classList.add(cn$n(\"c\"));\n    this.element.appendChild(containerElem);\n    this.containerElement = containerElem;\n  }\n}\nvar cn$m = ClassName(\"tbi\");\n\nclass TabItemView {\n  constructor(doc, config) {\n    this.element = doc.createElement(\"div\");\n    this.element.classList.add(cn$m());\n    config.viewProps.bindClassModifiers(this.element);\n    bindValueMap(config.props, \"selected\", (selected) => {\n      if (selected) {\n        this.element.classList.add(cn$m(undefined, \"sel\"));\n      } else {\n        this.element.classList.remove(cn$m(undefined, \"sel\"));\n      }\n    });\n    const buttonElem = doc.createElement(\"button\");\n    buttonElem.classList.add(cn$m(\"b\"));\n    config.viewProps.bindDisabled(buttonElem);\n    this.element.appendChild(buttonElem);\n    this.buttonElement = buttonElem;\n    const titleElem = doc.createElement(\"div\");\n    titleElem.classList.add(cn$m(\"t\"));\n    bindValueToTextContent(config.props.value(\"title\"), titleElem);\n    this.buttonElement.appendChild(titleElem);\n    this.titleElement = titleElem;\n  }\n}\n\nclass TabItemController {\n  constructor(doc, config) {\n    this.emitter = new Emitter;\n    this.onClick_ = this.onClick_.bind(this);\n    this.props = config.props;\n    this.viewProps = config.viewProps;\n    this.view = new TabItemView(doc, {\n      props: config.props,\n      viewProps: config.viewProps\n    });\n    this.view.buttonElement.addEventListener(\"click\", this.onClick_);\n  }\n  onClick_() {\n    this.emitter.emit(\"click\", {\n      sender: this\n    });\n  }\n}\n\nclass TabPageController extends ContainerBladeController {\n  constructor(doc, config) {\n    const view = new TabPageView(doc, {\n      viewProps: config.viewProps\n    });\n    super(Object.assign(Object.assign({}, config), { rackController: new RackController({\n      blade: config.blade,\n      element: view.containerElement,\n      viewProps: config.viewProps\n    }), view }));\n    this.onItemClick_ = this.onItemClick_.bind(this);\n    this.ic_ = new TabItemController(doc, {\n      props: config.itemProps,\n      viewProps: ViewProps.create()\n    });\n    this.ic_.emitter.on(\"click\", this.onItemClick_);\n    this.props = config.props;\n    bindValueMap(this.props, \"selected\", (selected) => {\n      this.itemController.props.set(\"selected\", selected);\n      this.viewProps.set(\"hidden\", !selected);\n    });\n  }\n  get itemController() {\n    return this.ic_;\n  }\n  importState(state) {\n    return importBladeState(state, (s) => super.importState(s), (p) => ({\n      selected: p.required.boolean,\n      title: p.required.string\n    }), (result) => {\n      this.ic_.props.set(\"selected\", result.selected);\n      this.ic_.props.set(\"title\", result.title);\n      return true;\n    });\n  }\n  exportState() {\n    return exportBladeState(() => super.exportState(), {\n      selected: this.ic_.props.get(\"selected\"),\n      title: this.ic_.props.get(\"title\")\n    });\n  }\n  onItemClick_() {\n    this.props.set(\"selected\", true);\n  }\n}\n\nclass TabApi extends ContainerBladeApi {\n  constructor(controller, pool) {\n    super(controller, pool);\n    this.emitter_ = new Emitter;\n    this.onSelect_ = this.onSelect_.bind(this);\n    this.pool_ = pool;\n    this.rackApi_.on(\"change\", (ev) => {\n      this.emitter_.emit(\"change\", ev);\n    });\n    this.controller.tab.selectedIndex.emitter.on(\"change\", this.onSelect_);\n  }\n  get pages() {\n    return this.rackApi_.children;\n  }\n  addPage(params) {\n    const doc = this.controller.view.element.ownerDocument;\n    const pc = new TabPageController(doc, {\n      blade: createBlade(),\n      itemProps: ValueMap.fromObject({\n        selected: false,\n        title: params.title\n      }),\n      props: ValueMap.fromObject({\n        selected: false\n      }),\n      viewProps: ViewProps.create()\n    });\n    const papi = this.pool_.createApi(pc);\n    return this.rackApi_.add(papi, params.index);\n  }\n  removePage(index) {\n    this.rackApi_.remove(this.rackApi_.children[index]);\n  }\n  on(eventName, handler) {\n    const bh = handler.bind(this);\n    this.emitter_.on(eventName, (ev) => {\n      bh(ev);\n    }, {\n      key: handler\n    });\n    return this;\n  }\n  off(eventName, handler) {\n    this.emitter_.off(eventName, handler);\n    return this;\n  }\n  onSelect_(ev) {\n    this.emitter_.emit(\"select\", new TpTabSelectEvent(this, ev.rawValue));\n  }\n}\n\nclass TabPageApi extends ContainerBladeApi {\n  get title() {\n    var _a;\n    return (_a = this.controller.itemController.props.get(\"title\")) !== null && _a !== undefined ? _a : \"\";\n  }\n  set title(title) {\n    this.controller.itemController.props.set(\"title\", title);\n  }\n  get selected() {\n    return this.controller.props.get(\"selected\");\n  }\n  set selected(selected) {\n    this.controller.props.set(\"selected\", selected);\n  }\n  get children() {\n    return this.rackApi_.children;\n  }\n  addButton(params) {\n    return this.rackApi_.addButton(params);\n  }\n  addFolder(params) {\n    return this.rackApi_.addFolder(params);\n  }\n  addTab(params) {\n    return this.rackApi_.addTab(params);\n  }\n  add(api, opt_index) {\n    this.rackApi_.add(api, opt_index);\n  }\n  remove(api) {\n    this.rackApi_.remove(api);\n  }\n  addBinding(object, key, opt_params) {\n    return this.rackApi_.addBinding(object, key, opt_params);\n  }\n  addBlade(params) {\n    return this.rackApi_.addBlade(params);\n  }\n}\nvar INDEX_NOT_SELECTED = -1;\n\nclass Tab {\n  constructor() {\n    this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this);\n    this.empty = createValue(true);\n    this.selectedIndex = createValue(INDEX_NOT_SELECTED);\n    this.items_ = [];\n  }\n  add(item, opt_index) {\n    const index = opt_index !== null && opt_index !== undefined ? opt_index : this.items_.length;\n    this.items_.splice(index, 0, item);\n    item.emitter.on(\"change\", this.onItemSelectedChange_);\n    this.keepSelection_();\n  }\n  remove(item) {\n    const index = this.items_.indexOf(item);\n    if (index < 0) {\n      return;\n    }\n    this.items_.splice(index, 1);\n    item.emitter.off(\"change\", this.onItemSelectedChange_);\n    this.keepSelection_();\n  }\n  keepSelection_() {\n    if (this.items_.length === 0) {\n      this.selectedIndex.rawValue = INDEX_NOT_SELECTED;\n      this.empty.rawValue = true;\n      return;\n    }\n    const firstSelIndex = this.items_.findIndex((s) => s.rawValue);\n    if (firstSelIndex < 0) {\n      this.items_.forEach((s, i) => {\n        s.rawValue = i === 0;\n      });\n      this.selectedIndex.rawValue = 0;\n    } else {\n      this.items_.forEach((s, i) => {\n        s.rawValue = i === firstSelIndex;\n      });\n      this.selectedIndex.rawValue = firstSelIndex;\n    }\n    this.empty.rawValue = false;\n  }\n  onItemSelectedChange_(ev) {\n    if (ev.rawValue) {\n      const index = this.items_.findIndex((s) => s === ev.sender);\n      this.items_.forEach((s, i) => {\n        s.rawValue = i === index;\n      });\n      this.selectedIndex.rawValue = index;\n    } else {\n      this.keepSelection_();\n    }\n  }\n}\nvar cn$l = ClassName(\"tab\");\n\nclass TabView {\n  constructor(doc, config) {\n    this.element = doc.createElement(\"div\");\n    this.element.classList.add(cn$l(), bladeContainerClassName());\n    config.viewProps.bindClassModifiers(this.element);\n    bindValue(config.empty, valueToClassName(this.element, cn$l(undefined, \"nop\")));\n    const titleElem = doc.createElement(\"div\");\n    titleElem.classList.add(cn$l(\"t\"));\n    this.element.appendChild(titleElem);\n    this.itemsElement = titleElem;\n    const indentElem = doc.createElement(\"div\");\n    indentElem.classList.add(cn$l(\"i\"));\n    this.element.appendChild(indentElem);\n    const contentsElem = doc.createElement(\"div\");\n    contentsElem.classList.add(cn$l(\"c\"));\n    this.element.appendChild(contentsElem);\n    this.contentsElement = contentsElem;\n  }\n}\n\nclass TabController extends ContainerBladeController {\n  constructor(doc, config) {\n    const tab = new Tab;\n    const view = new TabView(doc, {\n      empty: tab.empty,\n      viewProps: config.viewProps\n    });\n    super({\n      blade: config.blade,\n      rackController: new RackController({\n        blade: config.blade,\n        element: view.contentsElement,\n        viewProps: config.viewProps\n      }),\n      view\n    });\n    this.onRackAdd_ = this.onRackAdd_.bind(this);\n    this.onRackRemove_ = this.onRackRemove_.bind(this);\n    const rack = this.rackController.rack;\n    rack.emitter.on(\"add\", this.onRackAdd_);\n    rack.emitter.on(\"remove\", this.onRackRemove_);\n    this.tab = tab;\n  }\n  add(pc, opt_index) {\n    this.rackController.rack.add(pc, opt_index);\n  }\n  remove(index) {\n    this.rackController.rack.remove(this.rackController.rack.children[index]);\n  }\n  onRackAdd_(ev) {\n    if (!ev.root) {\n      return;\n    }\n    const pc = ev.bladeController;\n    insertElementAt(this.view.itemsElement, pc.itemController.view.element, ev.index);\n    pc.itemController.viewProps.set(\"parent\", this.viewProps);\n    this.tab.add(pc.props.value(\"selected\"));\n  }\n  onRackRemove_(ev) {\n    if (!ev.root) {\n      return;\n    }\n    const pc = ev.bladeController;\n    removeElement(pc.itemController.view.element);\n    pc.itemController.viewProps.set(\"parent\", null);\n    this.tab.remove(pc.props.value(\"selected\"));\n  }\n}\nvar TabBladePlugin = createPlugin({\n  id: \"tab\",\n  type: \"blade\",\n  accept(params) {\n    const result = parseRecord(params, (p) => ({\n      pages: p.required.array(p.required.object({ title: p.required.string })),\n      view: p.required.constant(\"tab\")\n    }));\n    if (!result || result.pages.length === 0) {\n      return null;\n    }\n    return { params: result };\n  },\n  controller(args) {\n    const c = new TabController(args.document, {\n      blade: args.blade,\n      viewProps: args.viewProps\n    });\n    args.params.pages.forEach((p) => {\n      const pc = new TabPageController(args.document, {\n        blade: createBlade(),\n        itemProps: ValueMap.fromObject({\n          selected: false,\n          title: p.title\n        }),\n        props: ValueMap.fromObject({\n          selected: false\n        }),\n        viewProps: ViewProps.create()\n      });\n      c.add(pc);\n    });\n    return c;\n  },\n  api(args) {\n    if (args.controller instanceof TabController) {\n      return new TabApi(args.controller, args.pool);\n    }\n    if (args.controller instanceof TabPageController) {\n      return new TabPageApi(args.controller, args.pool);\n    }\n    return null;\n  }\n});\nfunction createBladeController(plugin, args) {\n  const ac = plugin.accept(args.params);\n  if (!ac) {\n    return null;\n  }\n  const params = parseRecord(args.params, (p) => ({\n    disabled: p.optional.boolean,\n    hidden: p.optional.boolean\n  }));\n  return plugin.controller({\n    blade: createBlade(),\n    document: args.document,\n    params: forceCast(Object.assign(Object.assign({}, ac.params), { disabled: params === null || params === undefined ? undefined : params.disabled, hidden: params === null || params === undefined ? undefined : params.hidden })),\n    viewProps: ViewProps.create({\n      disabled: params === null || params === undefined ? undefined : params.disabled,\n      hidden: params === null || params === undefined ? undefined : params.hidden\n    })\n  });\n}\n\nclass ListInputBindingApi extends BindingApi {\n  get options() {\n    return this.controller.valueController.props.get(\"options\");\n  }\n  set options(options) {\n    this.controller.valueController.props.set(\"options\", options);\n  }\n}\n\nclass ManualTicker {\n  constructor() {\n    this.disabled = false;\n    this.emitter = new Emitter;\n  }\n  dispose() {}\n  tick() {\n    if (this.disabled) {\n      return;\n    }\n    this.emitter.emit(\"tick\", {\n      sender: this\n    });\n  }\n}\n\nclass IntervalTicker {\n  constructor(doc, interval) {\n    this.disabled_ = false;\n    this.timerId_ = null;\n    this.onTick_ = this.onTick_.bind(this);\n    this.doc_ = doc;\n    this.emitter = new Emitter;\n    this.interval_ = interval;\n    this.setTimer_();\n  }\n  get disabled() {\n    return this.disabled_;\n  }\n  set disabled(inactive) {\n    this.disabled_ = inactive;\n    if (this.disabled_) {\n      this.clearTimer_();\n    } else {\n      this.setTimer_();\n    }\n  }\n  dispose() {\n    this.clearTimer_();\n  }\n  clearTimer_() {\n    if (this.timerId_ === null) {\n      return;\n    }\n    const win = this.doc_.defaultView;\n    if (win) {\n      win.clearInterval(this.timerId_);\n    }\n    this.timerId_ = null;\n  }\n  setTimer_() {\n    this.clearTimer_();\n    if (this.interval_ <= 0) {\n      return;\n    }\n    const win = this.doc_.defaultView;\n    if (win) {\n      this.timerId_ = win.setInterval(this.onTick_, this.interval_);\n    }\n  }\n  onTick_() {\n    if (this.disabled_) {\n      return;\n    }\n    this.emitter.emit(\"tick\", {\n      sender: this\n    });\n  }\n}\n\nclass CompositeConstraint {\n  constructor(constraints) {\n    this.constraints = constraints;\n  }\n  constrain(value) {\n    return this.constraints.reduce((result, c) => {\n      return c.constrain(result);\n    }, value);\n  }\n}\nfunction findConstraint(c, constraintClass) {\n  if (c instanceof constraintClass) {\n    return c;\n  }\n  if (c instanceof CompositeConstraint) {\n    const result = c.constraints.reduce((tmpResult, sc) => {\n      if (tmpResult) {\n        return tmpResult;\n      }\n      return sc instanceof constraintClass ? sc : null;\n    }, null);\n    if (result) {\n      return result;\n    }\n  }\n  return null;\n}\n\nclass ListConstraint {\n  constructor(options) {\n    this.values = ValueMap.fromObject({\n      options\n    });\n  }\n  constrain(value) {\n    const opts = this.values.get(\"options\");\n    if (opts.length === 0) {\n      return value;\n    }\n    const matched = opts.filter((item) => {\n      return item.value === value;\n    }).length > 0;\n    return matched ? value : opts[0].value;\n  }\n}\nfunction parseListOptions(value) {\n  var _a;\n  const p = MicroParsers;\n  if (Array.isArray(value)) {\n    return (_a = parseRecord({ items: value }, (p2) => ({\n      items: p2.required.array(p2.required.object({\n        text: p2.required.string,\n        value: p2.required.raw\n      }))\n    }))) === null || _a === undefined ? undefined : _a.items;\n  }\n  if (typeof value === \"object\") {\n    return p.required.raw(value).value;\n  }\n  return;\n}\nfunction normalizeListOptions(options) {\n  if (Array.isArray(options)) {\n    return options;\n  }\n  const items = [];\n  Object.keys(options).forEach((text) => {\n    items.push({ text, value: options[text] });\n  });\n  return items;\n}\nfunction createListConstraint(options) {\n  return !isEmpty(options) ? new ListConstraint(normalizeListOptions(forceCast(options))) : null;\n}\nvar cn$k = ClassName(\"lst\");\n\nclass ListView {\n  constructor(doc, config) {\n    this.onValueChange_ = this.onValueChange_.bind(this);\n    this.props_ = config.props;\n    this.element = doc.createElement(\"div\");\n    this.element.classList.add(cn$k());\n    config.viewProps.bindClassModifiers(this.element);\n    const selectElem = doc.createElement(\"select\");\n    selectElem.classList.add(cn$k(\"s\"));\n    config.viewProps.bindDisabled(selectElem);\n    this.element.appendChild(selectElem);\n    this.selectElement = selectElem;\n    const markElem = doc.createElement(\"div\");\n    markElem.classList.add(cn$k(\"m\"));\n    markElem.appendChild(createSvgIconElement(doc, \"dropdown\"));\n    this.element.appendChild(markElem);\n    config.value.emitter.on(\"change\", this.onValueChange_);\n    this.value_ = config.value;\n    bindValueMap(this.props_, \"options\", (opts) => {\n      removeChildElements(this.selectElement);\n      opts.forEach((item) => {\n        const optionElem = doc.createElement(\"option\");\n        optionElem.textContent = item.text;\n        this.selectElement.appendChild(optionElem);\n      });\n      this.update_();\n    });\n  }\n  update_() {\n    const values = this.props_.get(\"options\").map((o) => o.value);\n    this.selectElement.selectedIndex = values.indexOf(this.value_.rawValue);\n  }\n  onValueChange_() {\n    this.update_();\n  }\n}\n\nclass ListController {\n  constructor(doc, config) {\n    this.onSelectChange_ = this.onSelectChange_.bind(this);\n    this.props = config.props;\n    this.value = config.value;\n    this.viewProps = config.viewProps;\n    this.view = new ListView(doc, {\n      props: this.props,\n      value: this.value,\n      viewProps: this.viewProps\n    });\n    this.view.selectElement.addEventListener(\"change\", this.onSelectChange_);\n  }\n  onSelectChange_(e) {\n    const selectElem = forceCast(e.currentTarget);\n    this.value.rawValue = this.props.get(\"options\")[selectElem.selectedIndex].value;\n  }\n  importProps(state) {\n    return importBladeState(state, null, (p) => ({\n      options: p.required.custom(parseListOptions)\n    }), (result) => {\n      this.props.set(\"options\", normalizeListOptions(result.options));\n      return true;\n    });\n  }\n  exportProps() {\n    return exportBladeState(null, {\n      options: this.props.get(\"options\")\n    });\n  }\n}\nvar cn$j = ClassName(\"pop\");\n\nclass PopupView {\n  constructor(doc, config) {\n    this.element = doc.createElement(\"div\");\n    this.element.classList.add(cn$j());\n    config.viewProps.bindClassModifiers(this.element);\n    bindValue(config.shows, valueToClassName(this.element, cn$j(undefined, \"v\")));\n  }\n}\n\nclass PopupController {\n  constructor(doc, config) {\n    this.shows = createValue(false);\n    this.viewProps = config.viewProps;\n    this.view = new PopupView(doc, {\n      shows: this.shows,\n      viewProps: this.viewProps\n    });\n  }\n}\nvar cn$i = ClassName(\"txt\");\n\nclass TextView {\n  constructor(doc, config) {\n    this.onChange_ = this.onChange_.bind(this);\n    this.element = doc.createElement(\"div\");\n    this.element.classList.add(cn$i());\n    config.viewProps.bindClassModifiers(this.element);\n    this.props_ = config.props;\n    this.props_.emitter.on(\"change\", this.onChange_);\n    const inputElem = doc.createElement(\"input\");\n    inputElem.classList.add(cn$i(\"i\"));\n    inputElem.type = \"text\";\n    config.viewProps.bindDisabled(inputElem);\n    this.element.appendChild(inputElem);\n    this.inputElement = inputElem;\n    config.value.emitter.on(\"change\", this.onChange_);\n    this.value_ = config.value;\n    this.refresh();\n  }\n  refresh() {\n    const formatter = this.props_.get(\"formatter\");\n    this.inputElement.value = formatter(this.value_.rawValue);\n  }\n  onChange_() {\n    this.refresh();\n  }\n}\n\nclass TextController {\n  constructor(doc, config) {\n    this.onInputChange_ = this.onInputChange_.bind(this);\n    this.parser_ = config.parser;\n    this.props = config.props;\n    this.value = config.value;\n    this.viewProps = config.viewProps;\n    this.view = new TextView(doc, {\n      props: config.props,\n      value: this.value,\n      viewProps: this.viewProps\n    });\n    this.view.inputElement.addEventListener(\"change\", this.onInputChange_);\n  }\n  onInputChange_(e) {\n    const inputElem = forceCast(e.currentTarget);\n    const value = inputElem.value;\n    const parsedValue = this.parser_(value);\n    if (!isEmpty(parsedValue)) {\n      this.value.rawValue = parsedValue;\n    }\n    this.view.refresh();\n  }\n}\nfunction boolToString(value) {\n  return String(value);\n}\nfunction boolFromUnknown(value) {\n  if (value === \"false\") {\n    return false;\n  }\n  return !!value;\n}\nfunction BooleanFormatter(value) {\n  return boolToString(value);\n}\nfunction composeParsers(parsers) {\n  return (text) => {\n    return parsers.reduce((result, parser) => {\n      if (result !== null) {\n        return result;\n      }\n      return parser(text);\n    }, null);\n  };\n}\nvar innerFormatter = createNumberFormatter(0);\nfunction formatPercentage(value) {\n  return innerFormatter(value) + \"%\";\n}\nfunction stringFromUnknown(value) {\n  return String(value);\n}\nfunction formatString(value) {\n  return value;\n}\nfunction connectValues({ primary, secondary, forward, backward }) {\n  let changing = false;\n  function preventFeedback(callback) {\n    if (changing) {\n      return;\n    }\n    changing = true;\n    callback();\n    changing = false;\n  }\n  primary.emitter.on(\"change\", (ev) => {\n    preventFeedback(() => {\n      secondary.setRawValue(forward(primary.rawValue, secondary.rawValue), ev.options);\n    });\n  });\n  secondary.emitter.on(\"change\", (ev) => {\n    preventFeedback(() => {\n      primary.setRawValue(backward(primary.rawValue, secondary.rawValue), ev.options);\n    });\n    preventFeedback(() => {\n      secondary.setRawValue(forward(primary.rawValue, secondary.rawValue), ev.options);\n    });\n  });\n  preventFeedback(() => {\n    secondary.setRawValue(forward(primary.rawValue, secondary.rawValue), {\n      forceEmit: false,\n      last: true\n    });\n  });\n}\nfunction getStepForKey(keyScale, keys) {\n  const step = keyScale * (keys.altKey ? 0.1 : 1) * (keys.shiftKey ? 10 : 1);\n  if (keys.upKey) {\n    return +step;\n  } else if (keys.downKey) {\n    return -step;\n  }\n  return 0;\n}\nfunction getVerticalStepKeys(ev) {\n  return {\n    altKey: ev.altKey,\n    downKey: ev.key === \"ArrowDown\",\n    shiftKey: ev.shiftKey,\n    upKey: ev.key === \"ArrowUp\"\n  };\n}\nfunction getHorizontalStepKeys(ev) {\n  return {\n    altKey: ev.altKey,\n    downKey: ev.key === \"ArrowLeft\",\n    shiftKey: ev.shiftKey,\n    upKey: ev.key === \"ArrowRight\"\n  };\n}\nfunction isVerticalArrowKey(key) {\n  return key === \"ArrowUp\" || key === \"ArrowDown\";\n}\nfunction isArrowKey(key) {\n  return isVerticalArrowKey(key) || key === \"ArrowLeft\" || key === \"ArrowRight\";\n}\nfunction computeOffset$1(ev, elem) {\n  var _a, _b;\n  const win = elem.ownerDocument.defaultView;\n  const rect = elem.getBoundingClientRect();\n  return {\n    x: ev.pageX - (((_a = win && win.scrollX) !== null && _a !== undefined ? _a : 0) + rect.left),\n    y: ev.pageY - (((_b = win && win.scrollY) !== null && _b !== undefined ? _b : 0) + rect.top)\n  };\n}\n\nclass PointerHandler {\n  constructor(element) {\n    this.lastTouch_ = null;\n    this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this);\n    this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this);\n    this.onMouseDown_ = this.onMouseDown_.bind(this);\n    this.onTouchEnd_ = this.onTouchEnd_.bind(this);\n    this.onTouchMove_ = this.onTouchMove_.bind(this);\n    this.onTouchStart_ = this.onTouchStart_.bind(this);\n    this.elem_ = element;\n    this.emitter = new Emitter;\n    element.addEventListener(\"touchstart\", this.onTouchStart_, {\n      passive: false\n    });\n    element.addEventListener(\"touchmove\", this.onTouchMove_, {\n      passive: true\n    });\n    element.addEventListener(\"touchend\", this.onTouchEnd_);\n    element.addEventListener(\"mousedown\", this.onMouseDown_);\n  }\n  computePosition_(offset) {\n    const rect = this.elem_.getBoundingClientRect();\n    return {\n      bounds: {\n        width: rect.width,\n        height: rect.height\n      },\n      point: offset ? {\n        x: offset.x,\n        y: offset.y\n      } : null\n    };\n  }\n  onMouseDown_(ev) {\n    var _a;\n    ev.preventDefault();\n    (_a = ev.currentTarget) === null || _a === undefined || _a.focus();\n    const doc = this.elem_.ownerDocument;\n    doc.addEventListener(\"mousemove\", this.onDocumentMouseMove_);\n    doc.addEventListener(\"mouseup\", this.onDocumentMouseUp_);\n    this.emitter.emit(\"down\", {\n      altKey: ev.altKey,\n      data: this.computePosition_(computeOffset$1(ev, this.elem_)),\n      sender: this,\n      shiftKey: ev.shiftKey\n    });\n  }\n  onDocumentMouseMove_(ev) {\n    this.emitter.emit(\"move\", {\n      altKey: ev.altKey,\n      data: this.computePosition_(computeOffset$1(ev, this.elem_)),\n      sender: this,\n      shiftKey: ev.shiftKey\n    });\n  }\n  onDocumentMouseUp_(ev) {\n    const doc = this.elem_.ownerDocument;\n    doc.removeEventListener(\"mousemove\", this.onDocumentMouseMove_);\n    doc.removeEventListener(\"mouseup\", this.onDocumentMouseUp_);\n    this.emitter.emit(\"up\", {\n      altKey: ev.altKey,\n      data: this.computePosition_(computeOffset$1(ev, this.elem_)),\n      sender: this,\n      shiftKey: ev.shiftKey\n    });\n  }\n  onTouchStart_(ev) {\n    ev.preventDefault();\n    const touch = ev.targetTouches.item(0);\n    const rect = this.elem_.getBoundingClientRect();\n    this.emitter.emit(\"down\", {\n      altKey: ev.altKey,\n      data: this.computePosition_(touch ? {\n        x: touch.clientX - rect.left,\n        y: touch.clientY - rect.top\n      } : undefined),\n      sender: this,\n      shiftKey: ev.shiftKey\n    });\n    this.lastTouch_ = touch;\n  }\n  onTouchMove_(ev) {\n    const touch = ev.targetTouches.item(0);\n    const rect = this.elem_.getBoundingClientRect();\n    this.emitter.emit(\"move\", {\n      altKey: ev.altKey,\n      data: this.computePosition_(touch ? {\n        x: touch.clientX - rect.left,\n        y: touch.clientY - rect.top\n      } : undefined),\n      sender: this,\n      shiftKey: ev.shiftKey\n    });\n    this.lastTouch_ = touch;\n  }\n  onTouchEnd_(ev) {\n    var _a;\n    const touch = (_a = ev.targetTouches.item(0)) !== null && _a !== undefined ? _a : this.lastTouch_;\n    const rect = this.elem_.getBoundingClientRect();\n    this.emitter.emit(\"up\", {\n      altKey: ev.altKey,\n      data: this.computePosition_(touch ? {\n        x: touch.clientX - rect.left,\n        y: touch.clientY - rect.top\n      } : undefined),\n      sender: this,\n      shiftKey: ev.shiftKey\n    });\n  }\n}\nvar cn$h = ClassName(\"txt\");\n\nclass NumberTextView {\n  constructor(doc, config) {\n    this.onChange_ = this.onChange_.bind(this);\n    this.props_ = config.props;\n    this.props_.emitter.on(\"change\", this.onChange_);\n    this.element = doc.createElement(\"div\");\n    this.element.classList.add(cn$h(), cn$h(undefined, \"num\"));\n    if (config.arrayPosition) {\n      this.element.classList.add(cn$h(undefined, config.arrayPosition));\n    }\n    config.viewProps.bindClassModifiers(this.element);\n    const inputElem = doc.createElement(\"input\");\n    inputElem.classList.add(cn$h(\"i\"));\n    inputElem.type = \"text\";\n    config.viewProps.bindDisabled(inputElem);\n    this.element.appendChild(inputElem);\n    this.inputElement = inputElem;\n    this.onDraggingChange_ = this.onDraggingChange_.bind(this);\n    this.dragging_ = config.dragging;\n    this.dragging_.emitter.on(\"change\", this.onDraggingChange_);\n    this.element.classList.add(cn$h());\n    this.inputElement.classList.add(cn$h(\"i\"));\n    const knobElem = doc.createElement(\"div\");\n    knobElem.classList.add(cn$h(\"k\"));\n    this.element.appendChild(knobElem);\n    this.knobElement = knobElem;\n    const guideElem = doc.createElementNS(SVG_NS, \"svg\");\n    guideElem.classList.add(cn$h(\"g\"));\n    this.knobElement.appendChild(guideElem);\n    const bodyElem = doc.createElementNS(SVG_NS, \"path\");\n    bodyElem.classList.add(cn$h(\"gb\"));\n    guideElem.appendChild(bodyElem);\n    this.guideBodyElem_ = bodyElem;\n    const headElem = doc.createElementNS(SVG_NS, \"path\");\n    headElem.classList.add(cn$h(\"gh\"));\n    guideElem.appendChild(headElem);\n    this.guideHeadElem_ = headElem;\n    const tooltipElem = doc.createElement(\"div\");\n    tooltipElem.classList.add(ClassName(\"tt\")());\n    this.knobElement.appendChild(tooltipElem);\n    this.tooltipElem_ = tooltipElem;\n    config.value.emitter.on(\"change\", this.onChange_);\n    this.value = config.value;\n    this.refresh();\n  }\n  onDraggingChange_(ev) {\n    if (ev.rawValue === null) {\n      this.element.classList.remove(cn$h(undefined, \"drg\"));\n      return;\n    }\n    this.element.classList.add(cn$h(undefined, \"drg\"));\n    const x = ev.rawValue / this.props_.get(\"pointerScale\");\n    const aox = x + (x > 0 ? -1 : x < 0 ? 1 : 0);\n    const adx = constrainRange(-aox, -4, 4);\n    this.guideHeadElem_.setAttributeNS(null, \"d\", [`M ${aox + adx},0 L${aox},4 L${aox + adx},8`, `M ${x},-1 L${x},9`].join(\" \"));\n    this.guideBodyElem_.setAttributeNS(null, \"d\", `M 0,4 L${x},4`);\n    const formatter = this.props_.get(\"formatter\");\n    this.tooltipElem_.textContent = formatter(this.value.rawValue);\n    this.tooltipElem_.style.left = `${x}px`;\n  }\n  refresh() {\n    const formatter = this.props_.get(\"formatter\");\n    this.inputElement.value = formatter(this.value.rawValue);\n  }\n  onChange_() {\n    this.refresh();\n  }\n}\n\nclass NumberTextController {\n  constructor(doc, config) {\n    var _a;\n    this.originRawValue_ = 0;\n    this.onInputChange_ = this.onInputChange_.bind(this);\n    this.onInputKeyDown_ = this.onInputKeyDown_.bind(this);\n    this.onInputKeyUp_ = this.onInputKeyUp_.bind(this);\n    this.onPointerDown_ = this.onPointerDown_.bind(this);\n    this.onPointerMove_ = this.onPointerMove_.bind(this);\n    this.onPointerUp_ = this.onPointerUp_.bind(this);\n    this.parser_ = config.parser;\n    this.props = config.props;\n    this.sliderProps_ = (_a = config.sliderProps) !== null && _a !== undefined ? _a : null;\n    this.value = config.value;\n    this.viewProps = config.viewProps;\n    this.dragging_ = createValue(null);\n    this.view = new NumberTextView(doc, {\n      arrayPosition: config.arrayPosition,\n      dragging: this.dragging_,\n      props: this.props,\n      value: this.value,\n      viewProps: this.viewProps\n    });\n    this.view.inputElement.addEventListener(\"change\", this.onInputChange_);\n    this.view.inputElement.addEventListener(\"keydown\", this.onInputKeyDown_);\n    this.view.inputElement.addEventListener(\"keyup\", this.onInputKeyUp_);\n    const ph = new PointerHandler(this.view.knobElement);\n    ph.emitter.on(\"down\", this.onPointerDown_);\n    ph.emitter.on(\"move\", this.onPointerMove_);\n    ph.emitter.on(\"up\", this.onPointerUp_);\n  }\n  constrainValue_(value) {\n    var _a, _b;\n    const min = (_a = this.sliderProps_) === null || _a === undefined ? undefined : _a.get(\"min\");\n    const max = (_b = this.sliderProps_) === null || _b === undefined ? undefined : _b.get(\"max\");\n    let v = value;\n    if (min !== undefined) {\n      v = Math.max(v, min);\n    }\n    if (max !== undefined) {\n      v = Math.min(v, max);\n    }\n    return v;\n  }\n  onInputChange_(e) {\n    const inputElem = forceCast(e.currentTarget);\n    const value = inputElem.value;\n    const parsedValue = this.parser_(value);\n    if (!isEmpty(parsedValue)) {\n      this.value.rawValue = this.constrainValue_(parsedValue);\n    }\n    this.view.refresh();\n  }\n  onInputKeyDown_(ev) {\n    const step = getStepForKey(this.props.get(\"keyScale\"), getVerticalStepKeys(ev));\n    if (step === 0) {\n      return;\n    }\n    this.value.setRawValue(this.constrainValue_(this.value.rawValue + step), {\n      forceEmit: false,\n      last: false\n    });\n  }\n  onInputKeyUp_(ev) {\n    const step = getStepForKey(this.props.get(\"keyScale\"), getVerticalStepKeys(ev));\n    if (step === 0) {\n      return;\n    }\n    this.value.setRawValue(this.value.rawValue, {\n      forceEmit: true,\n      last: true\n    });\n  }\n  onPointerDown_() {\n    this.originRawValue_ = this.value.rawValue;\n    this.dragging_.rawValue = 0;\n  }\n  computeDraggingValue_(data) {\n    if (!data.point) {\n      return null;\n    }\n    const dx = data.point.x - data.bounds.width / 2;\n    return this.constrainValue_(this.originRawValue_ + dx * this.props.get(\"pointerScale\"));\n  }\n  onPointerMove_(ev) {\n    const v = this.computeDraggingValue_(ev.data);\n    if (v === null) {\n      return;\n    }\n    this.value.setRawValue(v, {\n      forceEmit: false,\n      last: false\n    });\n    this.dragging_.rawValue = this.value.rawValue - this.originRawValue_;\n  }\n  onPointerUp_(ev) {\n    const v = this.computeDraggingValue_(ev.data);\n    if (v === null) {\n      return;\n    }\n    this.value.setRawValue(v, {\n      forceEmit: true,\n      last: true\n    });\n    this.dragging_.rawValue = null;\n  }\n}\nvar cn$g = ClassName(\"sld\");\n\nclass SliderView {\n  constructor(doc, config) {\n    this.onChange_ = this.onChange_.bind(this);\n    this.props_ = config.props;\n    this.props_.emitter.on(\"change\", this.onChange_);\n    this.element = doc.createElement(\"div\");\n    this.element.classList.add(cn$g());\n    config.viewProps.bindClassModifiers(this.element);\n    const trackElem = doc.createElement(\"div\");\n    trackElem.classList.add(cn$g(\"t\"));\n    config.viewProps.bindTabIndex(trackElem);\n    this.element.appendChild(trackElem);\n    this.trackElement = trackElem;\n    const knobElem = doc.createElement(\"div\");\n    knobElem.classList.add(cn$g(\"k\"));\n    this.trackElement.appendChild(knobElem);\n    this.knobElement = knobElem;\n    config.value.emitter.on(\"change\", this.onChange_);\n    this.value = config.value;\n    this.update_();\n  }\n  update_() {\n    const p = constrainRange(mapRange(this.value.rawValue, this.props_.get(\"min\"), this.props_.get(\"max\"), 0, 100), 0, 100);\n    this.knobElement.style.width = `${p}%`;\n  }\n  onChange_() {\n    this.update_();\n  }\n}\n\nclass SliderController {\n  constructor(doc, config) {\n    this.onKeyDown_ = this.onKeyDown_.bind(this);\n    this.onKeyUp_ = this.onKeyUp_.bind(this);\n    this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this);\n    this.onPointerUp_ = this.onPointerUp_.bind(this);\n    this.value = config.value;\n    this.viewProps = config.viewProps;\n    this.props = config.props;\n    this.view = new SliderView(doc, {\n      props: this.props,\n      value: this.value,\n      viewProps: this.viewProps\n    });\n    this.ptHandler_ = new PointerHandler(this.view.trackElement);\n    this.ptHandler_.emitter.on(\"down\", this.onPointerDownOrMove_);\n    this.ptHandler_.emitter.on(\"move\", this.onPointerDownOrMove_);\n    this.ptHandler_.emitter.on(\"up\", this.onPointerUp_);\n    this.view.trackElement.addEventListener(\"keydown\", this.onKeyDown_);\n    this.view.trackElement.addEventListener(\"keyup\", this.onKeyUp_);\n  }\n  handlePointerEvent_(d, opts) {\n    if (!d.point) {\n      return;\n    }\n    this.value.setRawValue(mapRange(constrainRange(d.point.x, 0, d.bounds.width), 0, d.bounds.width, this.props.get(\"min\"), this.props.get(\"max\")), opts);\n  }\n  onPointerDownOrMove_(ev) {\n    this.handlePointerEvent_(ev.data, {\n      forceEmit: false,\n      last: false\n    });\n  }\n  onPointerUp_(ev) {\n    this.handlePointerEvent_(ev.data, {\n      forceEmit: true,\n      last: true\n    });\n  }\n  onKeyDown_(ev) {\n    const step = getStepForKey(this.props.get(\"keyScale\"), getHorizontalStepKeys(ev));\n    if (step === 0) {\n      return;\n    }\n    this.value.setRawValue(this.value.rawValue + step, {\n      forceEmit: false,\n      last: false\n    });\n  }\n  onKeyUp_(ev) {\n    const step = getStepForKey(this.props.get(\"keyScale\"), getHorizontalStepKeys(ev));\n    if (step === 0) {\n      return;\n    }\n    this.value.setRawValue(this.value.rawValue, {\n      forceEmit: true,\n      last: true\n    });\n  }\n}\nvar cn$f = ClassName(\"sldtxt\");\n\nclass SliderTextView {\n  constructor(doc, config) {\n    this.element = doc.createElement(\"div\");\n    this.element.classList.add(cn$f());\n    const sliderElem = doc.createElement(\"div\");\n    sliderElem.classList.add(cn$f(\"s\"));\n    this.sliderView_ = config.sliderView;\n    sliderElem.appendChild(this.sliderView_.element);\n    this.element.appendChild(sliderElem);\n    const textElem = doc.createElement(\"div\");\n    textElem.classList.add(cn$f(\"t\"));\n    this.textView_ = config.textView;\n    textElem.appendChild(this.textView_.element);\n    this.element.appendChild(textElem);\n  }\n}\n\nclass SliderTextController {\n  constructor(doc, config) {\n    this.value = config.value;\n    this.viewProps = config.viewProps;\n    this.sliderC_ = new SliderController(doc, {\n      props: config.sliderProps,\n      value: config.value,\n      viewProps: this.viewProps\n    });\n    this.textC_ = new NumberTextController(doc, {\n      parser: config.parser,\n      props: config.textProps,\n      sliderProps: config.sliderProps,\n      value: config.value,\n      viewProps: config.viewProps\n    });\n    this.view = new SliderTextView(doc, {\n      sliderView: this.sliderC_.view,\n      textView: this.textC_.view\n    });\n  }\n  get sliderController() {\n    return this.sliderC_;\n  }\n  get textController() {\n    return this.textC_;\n  }\n  importProps(state) {\n    return importBladeState(state, null, (p) => ({\n      max: p.required.number,\n      min: p.required.number\n    }), (result) => {\n      const sliderProps = this.sliderC_.props;\n      sliderProps.set(\"max\", result.max);\n      sliderProps.set(\"min\", result.min);\n      return true;\n    });\n  }\n  exportProps() {\n    const sliderProps = this.sliderC_.props;\n    return exportBladeState(null, {\n      max: sliderProps.get(\"max\"),\n      min: sliderProps.get(\"min\")\n    });\n  }\n}\nfunction createSliderTextProps(config) {\n  return {\n    sliderProps: new ValueMap({\n      keyScale: config.keyScale,\n      max: config.max,\n      min: config.min\n    }),\n    textProps: new ValueMap({\n      formatter: createValue(config.formatter),\n      keyScale: config.keyScale,\n      pointerScale: createValue(config.pointerScale)\n    })\n  };\n}\nvar CSS_VAR_MAP = {\n  containerUnitSize: \"cnt-usz\"\n};\nfunction getCssVar(key) {\n  return `--${CSS_VAR_MAP[key]}`;\n}\nfunction createPointDimensionParser(p) {\n  return createNumberTextInputParamsParser(p);\n}\nfunction parsePointDimensionParams(value) {\n  if (!isRecord(value)) {\n    return;\n  }\n  return parseRecord(value, createPointDimensionParser);\n}\nfunction createDimensionConstraint(params, initialValue) {\n  if (!params) {\n    return;\n  }\n  const constraints = [];\n  const cs = createStepConstraint(params, initialValue);\n  if (cs) {\n    constraints.push(cs);\n  }\n  const rs = createRangeConstraint(params);\n  if (rs) {\n    constraints.push(rs);\n  }\n  return new CompositeConstraint(constraints);\n}\nfunction isCompatible(ver) {\n  if (!ver) {\n    return false;\n  }\n  return ver.major === VERSION$1.major;\n}\nfunction parsePickerLayout(value) {\n  if (value === \"inline\" || value === \"popup\") {\n    return value;\n  }\n  return;\n}\nfunction writePrimitive(target, value) {\n  target.write(value);\n}\nvar cn$e = ClassName(\"ckb\");\n\nclass CheckboxView {\n  constructor(doc, config) {\n    this.onValueChange_ = this.onValueChange_.bind(this);\n    this.element = doc.createElement(\"div\");\n    this.element.classList.add(cn$e());\n    config.viewProps.bindClassModifiers(this.element);\n    const labelElem = doc.createElement(\"label\");\n    labelElem.classList.add(cn$e(\"l\"));\n    this.element.appendChild(labelElem);\n    this.labelElement = labelElem;\n    const inputElem = doc.createElement(\"input\");\n    inputElem.classList.add(cn$e(\"i\"));\n    inputElem.type = \"checkbox\";\n    this.labelElement.appendChild(inputElem);\n    this.inputElement = inputElem;\n    config.viewProps.bindDisabled(this.inputElement);\n    const wrapperElem = doc.createElement(\"div\");\n    wrapperElem.classList.add(cn$e(\"w\"));\n    this.labelElement.appendChild(wrapperElem);\n    const markElem = createSvgIconElement(doc, \"check\");\n    wrapperElem.appendChild(markElem);\n    config.value.emitter.on(\"change\", this.onValueChange_);\n    this.value = config.value;\n    this.update_();\n  }\n  update_() {\n    this.inputElement.checked = this.value.rawValue;\n  }\n  onValueChange_() {\n    this.update_();\n  }\n}\n\nclass CheckboxController {\n  constructor(doc, config) {\n    this.onInputChange_ = this.onInputChange_.bind(this);\n    this.onLabelMouseDown_ = this.onLabelMouseDown_.bind(this);\n    this.value = config.value;\n    this.viewProps = config.viewProps;\n    this.view = new CheckboxView(doc, {\n      value: this.value,\n      viewProps: this.viewProps\n    });\n    this.view.inputElement.addEventListener(\"change\", this.onInputChange_);\n    this.view.labelElement.addEventListener(\"mousedown\", this.onLabelMouseDown_);\n  }\n  onInputChange_(ev) {\n    const inputElem = forceCast(ev.currentTarget);\n    this.value.rawValue = inputElem.checked;\n    ev.preventDefault();\n    ev.stopPropagation();\n  }\n  onLabelMouseDown_(ev) {\n    ev.preventDefault();\n  }\n}\nfunction createConstraint$6(params) {\n  const constraints = [];\n  const lc = createListConstraint(params.options);\n  if (lc) {\n    constraints.push(lc);\n  }\n  return new CompositeConstraint(constraints);\n}\nvar BooleanInputPlugin = createPlugin({\n  id: \"input-bool\",\n  type: \"input\",\n  accept: (value, params) => {\n    if (typeof value !== \"boolean\") {\n      return null;\n    }\n    const result = parseRecord(params, (p) => ({\n      options: p.optional.custom(parseListOptions),\n      readonly: p.optional.constant(false)\n    }));\n    return result ? {\n      initialValue: value,\n      params: result\n    } : null;\n  },\n  binding: {\n    reader: (_args) => boolFromUnknown,\n    constraint: (args) => createConstraint$6(args.params),\n    writer: (_args) => writePrimitive\n  },\n  controller: (args) => {\n    const doc = args.document;\n    const value = args.value;\n    const c = args.constraint;\n    const lc = c && findConstraint(c, ListConstraint);\n    if (lc) {\n      return new ListController(doc, {\n        props: new ValueMap({\n          options: lc.values.value(\"options\")\n        }),\n        value,\n        viewProps: args.viewProps\n      });\n    }\n    return new CheckboxController(doc, {\n      value,\n      viewProps: args.viewProps\n    });\n  },\n  api(args) {\n    if (typeof args.controller.value.rawValue !== \"boolean\") {\n      return null;\n    }\n    if (args.controller.valueController instanceof ListController) {\n      return new ListInputBindingApi(args.controller);\n    }\n    return null;\n  }\n});\nvar cn$d = ClassName(\"col\");\n\nclass ColorView {\n  constructor(doc, config) {\n    this.element = doc.createElement(\"div\");\n    this.element.classList.add(cn$d());\n    config.foldable.bindExpandedClass(this.element, cn$d(undefined, \"expanded\"));\n    bindValueMap(config.foldable, \"completed\", valueToClassName(this.element, cn$d(undefined, \"cpl\")));\n    const headElem = doc.createElement(\"div\");\n    headElem.classList.add(cn$d(\"h\"));\n    this.element.appendChild(headElem);\n    const swatchElem = doc.createElement(\"div\");\n    swatchElem.classList.add(cn$d(\"s\"));\n    headElem.appendChild(swatchElem);\n    this.swatchElement = swatchElem;\n    const textElem = doc.createElement(\"div\");\n    textElem.classList.add(cn$d(\"t\"));\n    headElem.appendChild(textElem);\n    this.textElement = textElem;\n    if (config.pickerLayout === \"inline\") {\n      const pickerElem = doc.createElement(\"div\");\n      pickerElem.classList.add(cn$d(\"p\"));\n      this.element.appendChild(pickerElem);\n      this.pickerElement = pickerElem;\n    } else {\n      this.pickerElement = null;\n    }\n  }\n}\nfunction rgbToHslInt(r, g, b) {\n  const rp = constrainRange(r / 255, 0, 1);\n  const gp = constrainRange(g / 255, 0, 1);\n  const bp = constrainRange(b / 255, 0, 1);\n  const cmax = Math.max(rp, gp, bp);\n  const cmin = Math.min(rp, gp, bp);\n  const c = cmax - cmin;\n  let h = 0;\n  let s = 0;\n  const l = (cmin + cmax) / 2;\n  if (c !== 0) {\n    s = c / (1 - Math.abs(cmax + cmin - 1));\n    if (rp === cmax) {\n      h = (gp - bp) / c;\n    } else if (gp === cmax) {\n      h = 2 + (bp - rp) / c;\n    } else {\n      h = 4 + (rp - gp) / c;\n    }\n    h = h / 6 + (h < 0 ? 1 : 0);\n  }\n  return [h * 360, s * 100, l * 100];\n}\nfunction hslToRgbInt(h, s, l) {\n  const hp = (h % 360 + 360) % 360;\n  const sp = constrainRange(s / 100, 0, 1);\n  const lp = constrainRange(l / 100, 0, 1);\n  const c = (1 - Math.abs(2 * lp - 1)) * sp;\n  const x = c * (1 - Math.abs(hp / 60 % 2 - 1));\n  const m = lp - c / 2;\n  let rp, gp, bp;\n  if (hp >= 0 && hp < 60) {\n    [rp, gp, bp] = [c, x, 0];\n  } else if (hp >= 60 && hp < 120) {\n    [rp, gp, bp] = [x, c, 0];\n  } else if (hp >= 120 && hp < 180) {\n    [rp, gp, bp] = [0, c, x];\n  } else if (hp >= 180 && hp < 240) {\n    [rp, gp, bp] = [0, x, c];\n  } else if (hp >= 240 && hp < 300) {\n    [rp, gp, bp] = [x, 0, c];\n  } else {\n    [rp, gp, bp] = [c, 0, x];\n  }\n  return [(rp + m) * 255, (gp + m) * 255, (bp + m) * 255];\n}\nfunction rgbToHsvInt(r, g, b) {\n  const rp = constrainRange(r / 255, 0, 1);\n  const gp = constrainRange(g / 255, 0, 1);\n  const bp = constrainRange(b / 255, 0, 1);\n  const cmax = Math.max(rp, gp, bp);\n  const cmin = Math.min(rp, gp, bp);\n  const d = cmax - cmin;\n  let h;\n  if (d === 0) {\n    h = 0;\n  } else if (cmax === rp) {\n    h = 60 * (((gp - bp) / d % 6 + 6) % 6);\n  } else if (cmax === gp) {\n    h = 60 * ((bp - rp) / d + 2);\n  } else {\n    h = 60 * ((rp - gp) / d + 4);\n  }\n  const s = cmax === 0 ? 0 : d / cmax;\n  const v = cmax;\n  return [h, s * 100, v * 100];\n}\nfunction hsvToRgbInt(h, s, v) {\n  const hp = loopRange(h, 360);\n  const sp = constrainRange(s / 100, 0, 1);\n  const vp = constrainRange(v / 100, 0, 1);\n  const c = vp * sp;\n  const x = c * (1 - Math.abs(hp / 60 % 2 - 1));\n  const m = vp - c;\n  let rp, gp, bp;\n  if (hp >= 0 && hp < 60) {\n    [rp, gp, bp] = [c, x, 0];\n  } else if (hp >= 60 && hp < 120) {\n    [rp, gp, bp] = [x, c, 0];\n  } else if (hp >= 120 && hp < 180) {\n    [rp, gp, bp] = [0, c, x];\n  } else if (hp >= 180 && hp < 240) {\n    [rp, gp, bp] = [0, x, c];\n  } else if (hp >= 240 && hp < 300) {\n    [rp, gp, bp] = [x, 0, c];\n  } else {\n    [rp, gp, bp] = [c, 0, x];\n  }\n  return [(rp + m) * 255, (gp + m) * 255, (bp + m) * 255];\n}\nfunction hslToHsvInt(h, s, l) {\n  const sd = l + s * (100 - Math.abs(2 * l - 100)) / (2 * 100);\n  return [\n    h,\n    sd !== 0 ? s * (100 - Math.abs(2 * l - 100)) / sd : 0,\n    l + s * (100 - Math.abs(2 * l - 100)) / (2 * 100)\n  ];\n}\nfunction hsvToHslInt(h, s, v) {\n  const sd = 100 - Math.abs(v * (200 - s) / 100 - 100);\n  return [h, sd !== 0 ? s * v / sd : 0, v * (200 - s) / (2 * 100)];\n}\nfunction removeAlphaComponent(comps) {\n  return [comps[0], comps[1], comps[2]];\n}\nfunction appendAlphaComponent(comps, alpha) {\n  return [comps[0], comps[1], comps[2], alpha];\n}\nvar MODE_CONVERTER_MAP = {\n  hsl: {\n    hsl: (h, s, l) => [h, s, l],\n    hsv: hslToHsvInt,\n    rgb: hslToRgbInt\n  },\n  hsv: {\n    hsl: hsvToHslInt,\n    hsv: (h, s, v) => [h, s, v],\n    rgb: hsvToRgbInt\n  },\n  rgb: {\n    hsl: rgbToHslInt,\n    hsv: rgbToHsvInt,\n    rgb: (r, g, b) => [r, g, b]\n  }\n};\nfunction getColorMaxComponents(mode, type) {\n  return [\n    type === \"float\" ? 1 : mode === \"rgb\" ? 255 : 360,\n    type === \"float\" ? 1 : mode === \"rgb\" ? 255 : 100,\n    type === \"float\" ? 1 : mode === \"rgb\" ? 255 : 100\n  ];\n}\nfunction loopHueRange(hue, max) {\n  return hue === max ? max : loopRange(hue, max);\n}\nfunction constrainColorComponents(components, mode, type) {\n  var _a;\n  const ms = getColorMaxComponents(mode, type);\n  return [\n    mode === \"rgb\" ? constrainRange(components[0], 0, ms[0]) : loopHueRange(components[0], ms[0]),\n    constrainRange(components[1], 0, ms[1]),\n    constrainRange(components[2], 0, ms[2]),\n    constrainRange((_a = components[3]) !== null && _a !== undefined ? _a : 1, 0, 1)\n  ];\n}\nfunction convertColorType(comps, mode, from, to) {\n  const fms = getColorMaxComponents(mode, from);\n  const tms = getColorMaxComponents(mode, to);\n  return comps.map((c, index) => c / fms[index] * tms[index]);\n}\nfunction convertColor(components, from, to) {\n  const intComps = convertColorType(components, from.mode, from.type, \"int\");\n  const result = MODE_CONVERTER_MAP[from.mode][to.mode](...intComps);\n  return convertColorType(result, to.mode, \"int\", to.type);\n}\n\nclass IntColor {\n  static black() {\n    return new IntColor([0, 0, 0], \"rgb\");\n  }\n  constructor(comps, mode) {\n    this.type = \"int\";\n    this.mode = mode;\n    this.comps_ = constrainColorComponents(comps, mode, this.type);\n  }\n  getComponents(opt_mode) {\n    return appendAlphaComponent(convertColor(removeAlphaComponent(this.comps_), { mode: this.mode, type: this.type }, { mode: opt_mode !== null && opt_mode !== undefined ? opt_mode : this.mode, type: this.type }), this.comps_[3]);\n  }\n  toRgbaObject() {\n    const rgbComps = this.getComponents(\"rgb\");\n    return {\n      r: rgbComps[0],\n      g: rgbComps[1],\n      b: rgbComps[2],\n      a: rgbComps[3]\n    };\n  }\n}\nvar cn$c = ClassName(\"colp\");\n\nclass ColorPickerView {\n  constructor(doc, config) {\n    this.alphaViews_ = null;\n    this.element = doc.createElement(\"div\");\n    this.element.classList.add(cn$c());\n    config.viewProps.bindClassModifiers(this.element);\n    const hsvElem = doc.createElement(\"div\");\n    hsvElem.classList.add(cn$c(\"hsv\"));\n    const svElem = doc.createElement(\"div\");\n    svElem.classList.add(cn$c(\"sv\"));\n    this.svPaletteView_ = config.svPaletteView;\n    svElem.appendChild(this.svPaletteView_.element);\n    hsvElem.appendChild(svElem);\n    const hElem = doc.createElement(\"div\");\n    hElem.classList.add(cn$c(\"h\"));\n    this.hPaletteView_ = config.hPaletteView;\n    hElem.appendChild(this.hPaletteView_.element);\n    hsvElem.appendChild(hElem);\n    this.element.appendChild(hsvElem);\n    const rgbElem = doc.createElement(\"div\");\n    rgbElem.classList.add(cn$c(\"rgb\"));\n    this.textsView_ = config.textsView;\n    rgbElem.appendChild(this.textsView_.element);\n    this.element.appendChild(rgbElem);\n    if (config.alphaViews) {\n      this.alphaViews_ = {\n        palette: config.alphaViews.palette,\n        text: config.alphaViews.text\n      };\n      const aElem = doc.createElement(\"div\");\n      aElem.classList.add(cn$c(\"a\"));\n      const apElem = doc.createElement(\"div\");\n      apElem.classList.add(cn$c(\"ap\"));\n      apElem.appendChild(this.alphaViews_.palette.element);\n      aElem.appendChild(apElem);\n      const atElem = doc.createElement(\"div\");\n      atElem.classList.add(cn$c(\"at\"));\n      atElem.appendChild(this.alphaViews_.text.element);\n      aElem.appendChild(atElem);\n      this.element.appendChild(aElem);\n    }\n  }\n  get allFocusableElements() {\n    const elems = [\n      this.svPaletteView_.element,\n      this.hPaletteView_.element,\n      this.textsView_.modeSelectElement,\n      ...this.textsView_.inputViews.map((v) => v.inputElement)\n    ];\n    if (this.alphaViews_) {\n      elems.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement);\n    }\n    return elems;\n  }\n}\nfunction parseColorType(value) {\n  return value === \"int\" ? \"int\" : value === \"float\" ? \"float\" : undefined;\n}\nfunction parseColorInputParams(params) {\n  return parseRecord(params, (p) => ({\n    color: p.optional.object({\n      alpha: p.optional.boolean,\n      type: p.optional.custom(parseColorType)\n    }),\n    expanded: p.optional.boolean,\n    picker: p.optional.custom(parsePickerLayout),\n    readonly: p.optional.constant(false)\n  }));\n}\nfunction getKeyScaleForColor(forAlpha) {\n  return forAlpha ? 0.1 : 1;\n}\nfunction extractColorType(params) {\n  var _a;\n  return (_a = params.color) === null || _a === undefined ? undefined : _a.type;\n}\n\nclass FloatColor {\n  constructor(comps, mode) {\n    this.type = \"float\";\n    this.mode = mode;\n    this.comps_ = constrainColorComponents(comps, mode, this.type);\n  }\n  getComponents(opt_mode) {\n    return appendAlphaComponent(convertColor(removeAlphaComponent(this.comps_), { mode: this.mode, type: this.type }, { mode: opt_mode !== null && opt_mode !== undefined ? opt_mode : this.mode, type: this.type }), this.comps_[3]);\n  }\n  toRgbaObject() {\n    const rgbComps = this.getComponents(\"rgb\");\n    return {\n      r: rgbComps[0],\n      g: rgbComps[1],\n      b: rgbComps[2],\n      a: rgbComps[3]\n    };\n  }\n}\nvar TYPE_TO_CONSTRUCTOR_MAP = {\n  int: (comps, mode) => new IntColor(comps, mode),\n  float: (comps, mode) => new FloatColor(comps, mode)\n};\nfunction createColor(comps, mode, type) {\n  return TYPE_TO_CONSTRUCTOR_MAP[type](comps, mode);\n}\nfunction isFloatColor(c) {\n  return c.type === \"float\";\n}\nfunction isIntColor(c) {\n  return c.type === \"int\";\n}\nfunction convertFloatToInt(cf) {\n  const comps = cf.getComponents();\n  const ms = getColorMaxComponents(cf.mode, \"int\");\n  return new IntColor([\n    Math.round(mapRange(comps[0], 0, 1, 0, ms[0])),\n    Math.round(mapRange(comps[1], 0, 1, 0, ms[1])),\n    Math.round(mapRange(comps[2], 0, 1, 0, ms[2])),\n    comps[3]\n  ], cf.mode);\n}\nfunction convertIntToFloat(ci) {\n  const comps = ci.getComponents();\n  const ms = getColorMaxComponents(ci.mode, \"int\");\n  return new FloatColor([\n    mapRange(comps[0], 0, ms[0], 0, 1),\n    mapRange(comps[1], 0, ms[1], 0, 1),\n    mapRange(comps[2], 0, ms[2], 0, 1),\n    comps[3]\n  ], ci.mode);\n}\nfunction mapColorType(c, type) {\n  if (c.type === type) {\n    return c;\n  }\n  if (isIntColor(c) && type === \"float\") {\n    return convertIntToFloat(c);\n  }\n  if (isFloatColor(c) && type === \"int\") {\n    return convertFloatToInt(c);\n  }\n  throw TpError.shouldNeverHappen();\n}\nfunction equalsStringColorFormat(f1, f2) {\n  return f1.alpha === f2.alpha && f1.mode === f2.mode && f1.notation === f2.notation && f1.type === f2.type;\n}\nfunction parseCssNumberOrPercentage(text, max) {\n  const m = text.match(/^(.+)%$/);\n  if (!m) {\n    return Math.min(parseFloat(text), max);\n  }\n  return Math.min(parseFloat(m[1]) * 0.01 * max, max);\n}\nvar ANGLE_TO_DEG_MAP = {\n  deg: (angle) => angle,\n  grad: (angle) => angle * 360 / 400,\n  rad: (angle) => angle * 360 / (2 * Math.PI),\n  turn: (angle) => angle * 360\n};\nfunction parseCssNumberOrAngle(text) {\n  const m = text.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);\n  if (!m) {\n    return parseFloat(text);\n  }\n  const angle = parseFloat(m[1]);\n  const unit = m[2];\n  return ANGLE_TO_DEG_MAP[unit](angle);\n}\nfunction parseFunctionalRgbColorComponents(text) {\n  const m = text.match(/^rgb\\(\\s*([0-9A-Fa-f.]+%?)\\s*,\\s*([0-9A-Fa-f.]+%?)\\s*,\\s*([0-9A-Fa-f.]+%?)\\s*\\)$/);\n  if (!m) {\n    return null;\n  }\n  const comps = [\n    parseCssNumberOrPercentage(m[1], 255),\n    parseCssNumberOrPercentage(m[2], 255),\n    parseCssNumberOrPercentage(m[3], 255)\n  ];\n  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {\n    return null;\n  }\n  return comps;\n}\nfunction parseFunctionalRgbColor(text) {\n  const comps = parseFunctionalRgbColorComponents(text);\n  return comps ? new IntColor(comps, \"rgb\") : null;\n}\nfunction parseFunctionalRgbaColorComponents(text) {\n  const m = text.match(/^rgba\\(\\s*([0-9A-Fa-f.]+%?)\\s*,\\s*([0-9A-Fa-f.]+%?)\\s*,\\s*([0-9A-Fa-f.]+%?)\\s*,\\s*([0-9A-Fa-f.]+%?)\\s*\\)$/);\n  if (!m) {\n    return null;\n  }\n  const comps = [\n    parseCssNumberOrPercentage(m[1], 255),\n    parseCssNumberOrPercentage(m[2], 255),\n    parseCssNumberOrPercentage(m[3], 255),\n    parseCssNumberOrPercentage(m[4], 1)\n  ];\n  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2]) || isNaN(comps[3])) {\n    return null;\n  }\n  return comps;\n}\nfunction parseFunctionalRgbaColor(text) {\n  const comps = parseFunctionalRgbaColorComponents(text);\n  return comps ? new IntColor(comps, \"rgb\") : null;\n}\nfunction parseFunctionalHslColorComponents(text) {\n  const m = text.match(/^hsl\\(\\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\\s*,\\s*([0-9A-Fa-f.]+%?)\\s*,\\s*([0-9A-Fa-f.]+%?)\\s*\\)$/);\n  if (!m) {\n    return null;\n  }\n  const comps = [\n    parseCssNumberOrAngle(m[1]),\n    parseCssNumberOrPercentage(m[2], 100),\n    parseCssNumberOrPercentage(m[3], 100)\n  ];\n  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {\n    return null;\n  }\n  return comps;\n}\nfunction parseFunctionalHslColor(text) {\n  const comps = parseFunctionalHslColorComponents(text);\n  return comps ? new IntColor(comps, \"hsl\") : null;\n}\nfunction parseHslaColorComponents(text) {\n  const m = text.match(/^hsla\\(\\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\\s*,\\s*([0-9A-Fa-f.]+%?)\\s*,\\s*([0-9A-Fa-f.]+%?)\\s*,\\s*([0-9A-Fa-f.]+%?)\\s*\\)$/);\n  if (!m) {\n    return null;\n  }\n  const comps = [\n    parseCssNumberOrAngle(m[1]),\n    parseCssNumberOrPercentage(m[2], 100),\n    parseCssNumberOrPercentage(m[3], 100),\n    parseCssNumberOrPercentage(m[4], 1)\n  ];\n  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2]) || isNaN(comps[3])) {\n    return null;\n  }\n  return comps;\n}\nfunction parseFunctionalHslaColor(text) {\n  const comps = parseHslaColorComponents(text);\n  return comps ? new IntColor(comps, \"hsl\") : null;\n}\nfunction parseHexRgbColorComponents(text) {\n  const mRgb = text.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);\n  if (mRgb) {\n    return [\n      parseInt(mRgb[1] + mRgb[1], 16),\n      parseInt(mRgb[2] + mRgb[2], 16),\n      parseInt(mRgb[3] + mRgb[3], 16)\n    ];\n  }\n  const mRrggbb = text.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);\n  if (mRrggbb) {\n    return [\n      parseInt(mRrggbb[1], 16),\n      parseInt(mRrggbb[2], 16),\n      parseInt(mRrggbb[3], 16)\n    ];\n  }\n  return null;\n}\nfunction parseHexRgbColor(text) {\n  const comps = parseHexRgbColorComponents(text);\n  return comps ? new IntColor(comps, \"rgb\") : null;\n}\nfunction parseHexRgbaColorComponents(text) {\n  const mRgb = text.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);\n  if (mRgb) {\n    return [\n      parseInt(mRgb[1] + mRgb[1], 16),\n      parseInt(mRgb[2] + mRgb[2], 16),\n      parseInt(mRgb[3] + mRgb[3], 16),\n      mapRange(parseInt(mRgb[4] + mRgb[4], 16), 0, 255, 0, 1)\n    ];\n  }\n  const mRrggbb = text.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);\n  if (mRrggbb) {\n    return [\n      parseInt(mRrggbb[1], 16),\n      parseInt(mRrggbb[2], 16),\n      parseInt(mRrggbb[3], 16),\n      mapRange(parseInt(mRrggbb[4], 16), 0, 255, 0, 1)\n    ];\n  }\n  return null;\n}\nfunction parseHexRgbaColor(text) {\n  const comps = parseHexRgbaColorComponents(text);\n  return comps ? new IntColor(comps, \"rgb\") : null;\n}\nfunction parseObjectRgbColorComponents(text) {\n  const m = text.match(/^\\{\\s*r\\s*:\\s*([0-9A-Fa-f.]+%?)\\s*,\\s*g\\s*:\\s*([0-9A-Fa-f.]+%?)\\s*,\\s*b\\s*:\\s*([0-9A-Fa-f.]+%?)\\s*\\}$/);\n  if (!m) {\n    return null;\n  }\n  const comps = [\n    parseFloat(m[1]),\n    parseFloat(m[2]),\n    parseFloat(m[3])\n  ];\n  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {\n    return null;\n  }\n  return comps;\n}\nfunction createObjectRgbColorParser(type) {\n  return (text) => {\n    const comps = parseObjectRgbColorComponents(text);\n    return comps ? createColor(comps, \"rgb\", type) : null;\n  };\n}\nfunction parseObjectRgbaColorComponents(text) {\n  const m = text.match(/^\\{\\s*r\\s*:\\s*([0-9A-Fa-f.]+%?)\\s*,\\s*g\\s*:\\s*([0-9A-Fa-f.]+%?)\\s*,\\s*b\\s*:\\s*([0-9A-Fa-f.]+%?)\\s*,\\s*a\\s*:\\s*([0-9A-Fa-f.]+%?)\\s*\\}$/);\n  if (!m) {\n    return null;\n  }\n  const comps = [\n    parseFloat(m[1]),\n    parseFloat(m[2]),\n    parseFloat(m[3]),\n    parseFloat(m[4])\n  ];\n  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2]) || isNaN(comps[3])) {\n    return null;\n  }\n  return comps;\n}\nfunction createObjectRgbaColorParser(type) {\n  return (text) => {\n    const comps = parseObjectRgbaColorComponents(text);\n    return comps ? createColor(comps, \"rgb\", type) : null;\n  };\n}\nvar PARSER_AND_RESULT = [\n  {\n    parser: parseHexRgbColorComponents,\n    result: {\n      alpha: false,\n      mode: \"rgb\",\n      notation: \"hex\"\n    }\n  },\n  {\n    parser: parseHexRgbaColorComponents,\n    result: {\n      alpha: true,\n      mode: \"rgb\",\n      notation: \"hex\"\n    }\n  },\n  {\n    parser: parseFunctionalRgbColorComponents,\n    result: {\n      alpha: false,\n      mode: \"rgb\",\n      notation: \"func\"\n    }\n  },\n  {\n    parser: parseFunctionalRgbaColorComponents,\n    result: {\n      alpha: true,\n      mode: \"rgb\",\n      notation: \"func\"\n    }\n  },\n  {\n    parser: parseFunctionalHslColorComponents,\n    result: {\n      alpha: false,\n      mode: \"hsl\",\n      notation: \"func\"\n    }\n  },\n  {\n    parser: parseHslaColorComponents,\n    result: {\n      alpha: true,\n      mode: \"hsl\",\n      notation: \"func\"\n    }\n  },\n  {\n    parser: parseObjectRgbColorComponents,\n    result: {\n      alpha: false,\n      mode: \"rgb\",\n      notation: \"object\"\n    }\n  },\n  {\n    parser: parseObjectRgbaColorComponents,\n    result: {\n      alpha: true,\n      mode: \"rgb\",\n      notation: \"object\"\n    }\n  }\n];\nfunction detectStringColor(text) {\n  return PARSER_AND_RESULT.reduce((prev, { parser, result: detection }) => {\n    if (prev) {\n      return prev;\n    }\n    return parser(text) ? detection : null;\n  }, null);\n}\nfunction detectStringColorFormat(text, type = \"int\") {\n  const r = detectStringColor(text);\n  if (!r) {\n    return null;\n  }\n  if (r.notation === \"hex\" && type !== \"float\") {\n    return Object.assign(Object.assign({}, r), { type: \"int\" });\n  }\n  if (r.notation === \"func\") {\n    return Object.assign(Object.assign({}, r), { type });\n  }\n  return null;\n}\nfunction createColorStringParser(type) {\n  const parsers = [\n    parseHexRgbColor,\n    parseHexRgbaColor,\n    parseFunctionalRgbColor,\n    parseFunctionalRgbaColor,\n    parseFunctionalHslColor,\n    parseFunctionalHslaColor\n  ];\n  if (type === \"int\") {\n    parsers.push(createObjectRgbColorParser(\"int\"), createObjectRgbaColorParser(\"int\"));\n  }\n  if (type === \"float\") {\n    parsers.push(createObjectRgbColorParser(\"float\"), createObjectRgbaColorParser(\"float\"));\n  }\n  const parser = composeParsers(parsers);\n  return (text) => {\n    const result = parser(text);\n    return result ? mapColorType(result, type) : null;\n  };\n}\nfunction readIntColorString(value) {\n  const parser = createColorStringParser(\"int\");\n  if (typeof value !== \"string\") {\n    return IntColor.black();\n  }\n  const result = parser(value);\n  return result !== null && result !== undefined ? result : IntColor.black();\n}\nfunction zerofill(comp) {\n  const hex = constrainRange(Math.floor(comp), 0, 255).toString(16);\n  return hex.length === 1 ? `0${hex}` : hex;\n}\nfunction colorToHexRgbString(value, prefix = \"#\") {\n  const hexes = removeAlphaComponent(value.getComponents(\"rgb\")).map(zerofill).join(\"\");\n  return `${prefix}${hexes}`;\n}\nfunction colorToHexRgbaString(value, prefix = \"#\") {\n  const rgbaComps = value.getComponents(\"rgb\");\n  const hexes = [rgbaComps[0], rgbaComps[1], rgbaComps[2], rgbaComps[3] * 255].map(zerofill).join(\"\");\n  return `${prefix}${hexes}`;\n}\nfunction colorToFunctionalRgbString(value) {\n  const formatter = createNumberFormatter(0);\n  const ci = mapColorType(value, \"int\");\n  const comps = removeAlphaComponent(ci.getComponents(\"rgb\")).map((comp) => formatter(comp));\n  return `rgb(${comps.join(\", \")})`;\n}\nfunction colorToFunctionalRgbaString(value) {\n  const aFormatter = createNumberFormatter(2);\n  const rgbFormatter = createNumberFormatter(0);\n  const ci = mapColorType(value, \"int\");\n  const comps = ci.getComponents(\"rgb\").map((comp, index) => {\n    const formatter = index === 3 ? aFormatter : rgbFormatter;\n    return formatter(comp);\n  });\n  return `rgba(${comps.join(\", \")})`;\n}\nfunction colorToFunctionalHslString(value) {\n  const formatters = [\n    createNumberFormatter(0),\n    formatPercentage,\n    formatPercentage\n  ];\n  const ci = mapColorType(value, \"int\");\n  const comps = removeAlphaComponent(ci.getComponents(\"hsl\")).map((comp, index) => formatters[index](comp));\n  return `hsl(${comps.join(\", \")})`;\n}\nfunction colorToFunctionalHslaString(value) {\n  const formatters = [\n    createNumberFormatter(0),\n    formatPercentage,\n    formatPercentage,\n    createNumberFormatter(2)\n  ];\n  const ci = mapColorType(value, \"int\");\n  const comps = ci.getComponents(\"hsl\").map((comp, index) => formatters[index](comp));\n  return `hsla(${comps.join(\", \")})`;\n}\nfunction colorToObjectRgbString(value, type) {\n  const formatter = createNumberFormatter(type === \"float\" ? 2 : 0);\n  const names = [\"r\", \"g\", \"b\"];\n  const cc = mapColorType(value, type);\n  const comps = removeAlphaComponent(cc.getComponents(\"rgb\")).map((comp, index) => `${names[index]}: ${formatter(comp)}`);\n  return `{${comps.join(\", \")}}`;\n}\nfunction createObjectRgbColorFormatter(type) {\n  return (value) => colorToObjectRgbString(value, type);\n}\nfunction colorToObjectRgbaString(value, type) {\n  const aFormatter = createNumberFormatter(2);\n  const rgbFormatter = createNumberFormatter(type === \"float\" ? 2 : 0);\n  const names = [\"r\", \"g\", \"b\", \"a\"];\n  const cc = mapColorType(value, type);\n  const comps = cc.getComponents(\"rgb\").map((comp, index) => {\n    const formatter = index === 3 ? aFormatter : rgbFormatter;\n    return `${names[index]}: ${formatter(comp)}`;\n  });\n  return `{${comps.join(\", \")}}`;\n}\nfunction createObjectRgbaColorFormatter(type) {\n  return (value) => colorToObjectRgbaString(value, type);\n}\nvar FORMAT_AND_STRINGIFIERS = [\n  {\n    format: {\n      alpha: false,\n      mode: \"rgb\",\n      notation: \"hex\",\n      type: \"int\"\n    },\n    stringifier: colorToHexRgbString\n  },\n  {\n    format: {\n      alpha: true,\n      mode: \"rgb\",\n      notation: \"hex\",\n      type: \"int\"\n    },\n    stringifier: colorToHexRgbaString\n  },\n  {\n    format: {\n      alpha: false,\n      mode: \"rgb\",\n      notation: \"func\",\n      type: \"int\"\n    },\n    stringifier: colorToFunctionalRgbString\n  },\n  {\n    format: {\n      alpha: true,\n      mode: \"rgb\",\n      notation: \"func\",\n      type: \"int\"\n    },\n    stringifier: colorToFunctionalRgbaString\n  },\n  {\n    format: {\n      alpha: false,\n      mode: \"hsl\",\n      notation: \"func\",\n      type: \"int\"\n    },\n    stringifier: colorToFunctionalHslString\n  },\n  {\n    format: {\n      alpha: true,\n      mode: \"hsl\",\n      notation: \"func\",\n      type: \"int\"\n    },\n    stringifier: colorToFunctionalHslaString\n  },\n  ...[\"int\", \"float\"].reduce((prev, type) => {\n    return [\n      ...prev,\n      {\n        format: {\n          alpha: false,\n          mode: \"rgb\",\n          notation: \"object\",\n          type\n        },\n        stringifier: createObjectRgbColorFormatter(type)\n      },\n      {\n        format: {\n          alpha: true,\n          mode: \"rgb\",\n          notation: \"object\",\n          type\n        },\n        stringifier: createObjectRgbaColorFormatter(type)\n      }\n    ];\n  }, [])\n];\nfunction findColorStringifier(format) {\n  return FORMAT_AND_STRINGIFIERS.reduce((prev, fas) => {\n    if (prev) {\n      return prev;\n    }\n    return equalsStringColorFormat(fas.format, format) ? fas.stringifier : null;\n  }, null);\n}\nvar cn$b = ClassName(\"apl\");\n\nclass APaletteView {\n  constructor(doc, config) {\n    this.onValueChange_ = this.onValueChange_.bind(this);\n    this.value = config.value;\n    this.value.emitter.on(\"change\", this.onValueChange_);\n    this.element = doc.createElement(\"div\");\n    this.element.classList.add(cn$b());\n    config.viewProps.bindClassModifiers(this.element);\n    config.viewProps.bindTabIndex(this.element);\n    const barElem = doc.createElement(\"div\");\n    barElem.classList.add(cn$b(\"b\"));\n    this.element.appendChild(barElem);\n    const colorElem = doc.createElement(\"div\");\n    colorElem.classList.add(cn$b(\"c\"));\n    barElem.appendChild(colorElem);\n    this.colorElem_ = colorElem;\n    const markerElem = doc.createElement(\"div\");\n    markerElem.classList.add(cn$b(\"m\"));\n    this.element.appendChild(markerElem);\n    this.markerElem_ = markerElem;\n    const previewElem = doc.createElement(\"div\");\n    previewElem.classList.add(cn$b(\"p\"));\n    this.markerElem_.appendChild(previewElem);\n    this.previewElem_ = previewElem;\n    this.update_();\n  }\n  update_() {\n    const c = this.value.rawValue;\n    const rgbaComps = c.getComponents(\"rgb\");\n    const leftColor = new IntColor([rgbaComps[0], rgbaComps[1], rgbaComps[2], 0], \"rgb\");\n    const rightColor = new IntColor([rgbaComps[0], rgbaComps[1], rgbaComps[2], 255], \"rgb\");\n    const gradientComps = [\n      \"to right\",\n      colorToFunctionalRgbaString(leftColor),\n      colorToFunctionalRgbaString(rightColor)\n    ];\n    this.colorElem_.style.background = `linear-gradient(${gradientComps.join(\",\")})`;\n    this.previewElem_.style.backgroundColor = colorToFunctionalRgbaString(c);\n    const left = mapRange(rgbaComps[3], 0, 1, 0, 100);\n    this.markerElem_.style.left = `${left}%`;\n  }\n  onValueChange_() {\n    this.update_();\n  }\n}\n\nclass APaletteController {\n  constructor(doc, config) {\n    this.onKeyDown_ = this.onKeyDown_.bind(this);\n    this.onKeyUp_ = this.onKeyUp_.bind(this);\n    this.onPointerDown_ = this.onPointerDown_.bind(this);\n    this.onPointerMove_ = this.onPointerMove_.bind(this);\n    this.onPointerUp_ = this.onPointerUp_.bind(this);\n    this.value = config.value;\n    this.viewProps = config.viewProps;\n    this.view = new APaletteView(doc, {\n      value: this.value,\n      viewProps: this.viewProps\n    });\n    this.ptHandler_ = new PointerHandler(this.view.element);\n    this.ptHandler_.emitter.on(\"down\", this.onPointerDown_);\n    this.ptHandler_.emitter.on(\"move\", this.onPointerMove_);\n    this.ptHandler_.emitter.on(\"up\", this.onPointerUp_);\n    this.view.element.addEventListener(\"keydown\", this.onKeyDown_);\n    this.view.element.addEventListener(\"keyup\", this.onKeyUp_);\n  }\n  handlePointerEvent_(d, opts) {\n    if (!d.point) {\n      return;\n    }\n    const alpha = d.point.x / d.bounds.width;\n    const c = this.value.rawValue;\n    const [h, s, v] = c.getComponents(\"hsv\");\n    this.value.setRawValue(new IntColor([h, s, v, alpha], \"hsv\"), opts);\n  }\n  onPointerDown_(ev) {\n    this.handlePointerEvent_(ev.data, {\n      forceEmit: false,\n      last: false\n    });\n  }\n  onPointerMove_(ev) {\n    this.handlePointerEvent_(ev.data, {\n      forceEmit: false,\n      last: false\n    });\n  }\n  onPointerUp_(ev) {\n    this.handlePointerEvent_(ev.data, {\n      forceEmit: true,\n      last: true\n    });\n  }\n  onKeyDown_(ev) {\n    const step = getStepForKey(getKeyScaleForColor(true), getHorizontalStepKeys(ev));\n    if (step === 0) {\n      return;\n    }\n    const c = this.value.rawValue;\n    const [h, s, v, a] = c.getComponents(\"hsv\");\n    this.value.setRawValue(new IntColor([h, s, v, a + step], \"hsv\"), {\n      forceEmit: false,\n      last: false\n    });\n  }\n  onKeyUp_(ev) {\n    const step = getStepForKey(getKeyScaleForColor(true), getHorizontalStepKeys(ev));\n    if (step === 0) {\n      return;\n    }\n    this.value.setRawValue(this.value.rawValue, {\n      forceEmit: true,\n      last: true\n    });\n  }\n}\nvar cn$a = ClassName(\"coltxt\");\nfunction createModeSelectElement(doc) {\n  const selectElem = doc.createElement(\"select\");\n  const items = [\n    { text: \"RGB\", value: \"rgb\" },\n    { text: \"HSL\", value: \"hsl\" },\n    { text: \"HSV\", value: \"hsv\" },\n    { text: \"HEX\", value: \"hex\" }\n  ];\n  selectElem.appendChild(items.reduce((frag, item) => {\n    const optElem = doc.createElement(\"option\");\n    optElem.textContent = item.text;\n    optElem.value = item.value;\n    frag.appendChild(optElem);\n    return frag;\n  }, doc.createDocumentFragment()));\n  return selectElem;\n}\n\nclass ColorTextsView {\n  constructor(doc, config) {\n    this.element = doc.createElement(\"div\");\n    this.element.classList.add(cn$a());\n    config.viewProps.bindClassModifiers(this.element);\n    const modeElem = doc.createElement(\"div\");\n    modeElem.classList.add(cn$a(\"m\"));\n    this.modeElem_ = createModeSelectElement(doc);\n    this.modeElem_.classList.add(cn$a(\"ms\"));\n    modeElem.appendChild(this.modeSelectElement);\n    config.viewProps.bindDisabled(this.modeElem_);\n    const modeMarkerElem = doc.createElement(\"div\");\n    modeMarkerElem.classList.add(cn$a(\"mm\"));\n    modeMarkerElem.appendChild(createSvgIconElement(doc, \"dropdown\"));\n    modeElem.appendChild(modeMarkerElem);\n    this.element.appendChild(modeElem);\n    const inputsElem = doc.createElement(\"div\");\n    inputsElem.classList.add(cn$a(\"w\"));\n    this.element.appendChild(inputsElem);\n    this.inputsElem_ = inputsElem;\n    this.inputViews_ = config.inputViews;\n    this.applyInputViews_();\n    bindValue(config.mode, (mode) => {\n      this.modeElem_.value = mode;\n    });\n  }\n  get modeSelectElement() {\n    return this.modeElem_;\n  }\n  get inputViews() {\n    return this.inputViews_;\n  }\n  set inputViews(inputViews) {\n    this.inputViews_ = inputViews;\n    this.applyInputViews_();\n  }\n  applyInputViews_() {\n    removeChildElements(this.inputsElem_);\n    const doc = this.element.ownerDocument;\n    this.inputViews_.forEach((v) => {\n      const compElem = doc.createElement(\"div\");\n      compElem.classList.add(cn$a(\"c\"));\n      compElem.appendChild(v.element);\n      this.inputsElem_.appendChild(compElem);\n    });\n  }\n}\nfunction createFormatter$2(type) {\n  return createNumberFormatter(type === \"float\" ? 2 : 0);\n}\nfunction createConstraint$5(mode, type, index) {\n  const max = getColorMaxComponents(mode, type)[index];\n  return new DefiniteRangeConstraint({\n    min: 0,\n    max\n  });\n}\nfunction createComponentController(doc, config, index) {\n  return new NumberTextController(doc, {\n    arrayPosition: index === 0 ? \"fst\" : index === 3 - 1 ? \"lst\" : \"mid\",\n    parser: config.parser,\n    props: ValueMap.fromObject({\n      formatter: createFormatter$2(config.colorType),\n      keyScale: getKeyScaleForColor(false),\n      pointerScale: config.colorType === \"float\" ? 0.01 : 1\n    }),\n    value: createValue(0, {\n      constraint: createConstraint$5(config.colorMode, config.colorType, index)\n    }),\n    viewProps: config.viewProps\n  });\n}\nfunction createComponentControllers(doc, config) {\n  const cc = {\n    colorMode: config.colorMode,\n    colorType: config.colorType,\n    parser: parseNumber,\n    viewProps: config.viewProps\n  };\n  return [0, 1, 2].map((i) => {\n    const c = createComponentController(doc, cc, i);\n    connectValues({\n      primary: config.value,\n      secondary: c.value,\n      forward(p) {\n        const mc = mapColorType(p, config.colorType);\n        return mc.getComponents(config.colorMode)[i];\n      },\n      backward(p, s) {\n        const pickedMode = config.colorMode;\n        const mc = mapColorType(p, config.colorType);\n        const comps = mc.getComponents(pickedMode);\n        comps[i] = s;\n        const c2 = createColor(appendAlphaComponent(removeAlphaComponent(comps), comps[3]), pickedMode, config.colorType);\n        return mapColorType(c2, \"int\");\n      }\n    });\n    return c;\n  });\n}\nfunction createHexController(doc, config) {\n  const c = new TextController(doc, {\n    parser: createColorStringParser(\"int\"),\n    props: ValueMap.fromObject({\n      formatter: colorToHexRgbString\n    }),\n    value: createValue(IntColor.black()),\n    viewProps: config.viewProps\n  });\n  connectValues({\n    primary: config.value,\n    secondary: c.value,\n    forward: (p) => new IntColor(removeAlphaComponent(p.getComponents()), p.mode),\n    backward: (p, s) => new IntColor(appendAlphaComponent(removeAlphaComponent(s.getComponents(p.mode)), p.getComponents()[3]), p.mode)\n  });\n  return [c];\n}\nfunction isColorMode(mode) {\n  return mode !== \"hex\";\n}\n\nclass ColorTextsController {\n  constructor(doc, config) {\n    this.onModeSelectChange_ = this.onModeSelectChange_.bind(this);\n    this.colorType_ = config.colorType;\n    this.value = config.value;\n    this.viewProps = config.viewProps;\n    this.colorMode = createValue(this.value.rawValue.mode);\n    this.ccs_ = this.createComponentControllers_(doc);\n    this.view = new ColorTextsView(doc, {\n      mode: this.colorMode,\n      inputViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view],\n      viewProps: this.viewProps\n    });\n    this.view.modeSelectElement.addEventListener(\"change\", this.onModeSelectChange_);\n  }\n  createComponentControllers_(doc) {\n    const mode = this.colorMode.rawValue;\n    if (isColorMode(mode)) {\n      return createComponentControllers(doc, {\n        colorMode: mode,\n        colorType: this.colorType_,\n        value: this.value,\n        viewProps: this.viewProps\n      });\n    }\n    return createHexController(doc, {\n      value: this.value,\n      viewProps: this.viewProps\n    });\n  }\n  onModeSelectChange_(ev) {\n    const selectElem = ev.currentTarget;\n    this.colorMode.rawValue = selectElem.value;\n    this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument);\n    this.view.inputViews = this.ccs_.map((cc) => cc.view);\n  }\n}\nvar cn$9 = ClassName(\"hpl\");\n\nclass HPaletteView {\n  constructor(doc, config) {\n    this.onValueChange_ = this.onValueChange_.bind(this);\n    this.value = config.value;\n    this.value.emitter.on(\"change\", this.onValueChange_);\n    this.element = doc.createElement(\"div\");\n    this.element.classList.add(cn$9());\n    config.viewProps.bindClassModifiers(this.element);\n    config.viewProps.bindTabIndex(this.element);\n    const colorElem = doc.createElement(\"div\");\n    colorElem.classList.add(cn$9(\"c\"));\n    this.element.appendChild(colorElem);\n    const markerElem = doc.createElement(\"div\");\n    markerElem.classList.add(cn$9(\"m\"));\n    this.element.appendChild(markerElem);\n    this.markerElem_ = markerElem;\n    this.update_();\n  }\n  update_() {\n    const c = this.value.rawValue;\n    const [h] = c.getComponents(\"hsv\");\n    this.markerElem_.style.backgroundColor = colorToFunctionalRgbString(new IntColor([h, 100, 100], \"hsv\"));\n    const left = mapRange(h, 0, 360, 0, 100);\n    this.markerElem_.style.left = `${left}%`;\n  }\n  onValueChange_() {\n    this.update_();\n  }\n}\n\nclass HPaletteController {\n  constructor(doc, config) {\n    this.onKeyDown_ = this.onKeyDown_.bind(this);\n    this.onKeyUp_ = this.onKeyUp_.bind(this);\n    this.onPointerDown_ = this.onPointerDown_.bind(this);\n    this.onPointerMove_ = this.onPointerMove_.bind(this);\n    this.onPointerUp_ = this.onPointerUp_.bind(this);\n    this.value = config.value;\n    this.viewProps = config.viewProps;\n    this.view = new HPaletteView(doc, {\n      value: this.value,\n      viewProps: this.viewProps\n    });\n    this.ptHandler_ = new PointerHandler(this.view.element);\n    this.ptHandler_.emitter.on(\"down\", this.onPointerDown_);\n    this.ptHandler_.emitter.on(\"move\", this.onPointerMove_);\n    this.ptHandler_.emitter.on(\"up\", this.onPointerUp_);\n    this.view.element.addEventListener(\"keydown\", this.onKeyDown_);\n    this.view.element.addEventListener(\"keyup\", this.onKeyUp_);\n  }\n  handlePointerEvent_(d, opts) {\n    if (!d.point) {\n      return;\n    }\n    const hue = mapRange(constrainRange(d.point.x, 0, d.bounds.width), 0, d.bounds.width, 0, 360);\n    const c = this.value.rawValue;\n    const [, s, v, a] = c.getComponents(\"hsv\");\n    this.value.setRawValue(new IntColor([hue, s, v, a], \"hsv\"), opts);\n  }\n  onPointerDown_(ev) {\n    this.handlePointerEvent_(ev.data, {\n      forceEmit: false,\n      last: false\n    });\n  }\n  onPointerMove_(ev) {\n    this.handlePointerEvent_(ev.data, {\n      forceEmit: false,\n      last: false\n    });\n  }\n  onPointerUp_(ev) {\n    this.handlePointerEvent_(ev.data, {\n      forceEmit: true,\n      last: true\n    });\n  }\n  onKeyDown_(ev) {\n    const step = getStepForKey(getKeyScaleForColor(false), getHorizontalStepKeys(ev));\n    if (step === 0) {\n      return;\n    }\n    const c = this.value.rawValue;\n    const [h, s, v, a] = c.getComponents(\"hsv\");\n    this.value.setRawValue(new IntColor([h + step, s, v, a], \"hsv\"), {\n      forceEmit: false,\n      last: false\n    });\n  }\n  onKeyUp_(ev) {\n    const step = getStepForKey(getKeyScaleForColor(false), getHorizontalStepKeys(ev));\n    if (step === 0) {\n      return;\n    }\n    this.value.setRawValue(this.value.rawValue, {\n      forceEmit: true,\n      last: true\n    });\n  }\n}\nvar cn$8 = ClassName(\"svp\");\nvar CANVAS_RESOL = 64;\n\nclass SvPaletteView {\n  constructor(doc, config) {\n    this.onValueChange_ = this.onValueChange_.bind(this);\n    this.value = config.value;\n    this.value.emitter.on(\"change\", this.onValueChange_);\n    this.element = doc.createElement(\"div\");\n    this.element.classList.add(cn$8());\n    config.viewProps.bindClassModifiers(this.element);\n    config.viewProps.bindTabIndex(this.element);\n    const canvasElem = doc.createElement(\"canvas\");\n    canvasElem.height = CANVAS_RESOL;\n    canvasElem.width = CANVAS_RESOL;\n    canvasElem.classList.add(cn$8(\"c\"));\n    this.element.appendChild(canvasElem);\n    this.canvasElement = canvasElem;\n    const markerElem = doc.createElement(\"div\");\n    markerElem.classList.add(cn$8(\"m\"));\n    this.element.appendChild(markerElem);\n    this.markerElem_ = markerElem;\n    this.update_();\n  }\n  update_() {\n    const ctx = getCanvasContext(this.canvasElement);\n    if (!ctx) {\n      return;\n    }\n    const c = this.value.rawValue;\n    const hsvComps = c.getComponents(\"hsv\");\n    const width = this.canvasElement.width;\n    const height = this.canvasElement.height;\n    const imgData = ctx.getImageData(0, 0, width, height);\n    const data = imgData.data;\n    for (let iy = 0;iy < height; iy++) {\n      for (let ix = 0;ix < width; ix++) {\n        const s = mapRange(ix, 0, width, 0, 100);\n        const v = mapRange(iy, 0, height, 100, 0);\n        const rgbComps = hsvToRgbInt(hsvComps[0], s, v);\n        const i = (iy * width + ix) * 4;\n        data[i] = rgbComps[0];\n        data[i + 1] = rgbComps[1];\n        data[i + 2] = rgbComps[2];\n        data[i + 3] = 255;\n      }\n    }\n    ctx.putImageData(imgData, 0, 0);\n    const left = mapRange(hsvComps[1], 0, 100, 0, 100);\n    this.markerElem_.style.left = `${left}%`;\n    const top = mapRange(hsvComps[2], 0, 100, 100, 0);\n    this.markerElem_.style.top = `${top}%`;\n  }\n  onValueChange_() {\n    this.update_();\n  }\n}\n\nclass SvPaletteController {\n  constructor(doc, config) {\n    this.onKeyDown_ = this.onKeyDown_.bind(this);\n    this.onKeyUp_ = this.onKeyUp_.bind(this);\n    this.onPointerDown_ = this.onPointerDown_.bind(this);\n    this.onPointerMove_ = this.onPointerMove_.bind(this);\n    this.onPointerUp_ = this.onPointerUp_.bind(this);\n    this.value = config.value;\n    this.viewProps = config.viewProps;\n    this.view = new SvPaletteView(doc, {\n      value: this.value,\n      viewProps: this.viewProps\n    });\n    this.ptHandler_ = new PointerHandler(this.view.element);\n    this.ptHandler_.emitter.on(\"down\", this.onPointerDown_);\n    this.ptHandler_.emitter.on(\"move\", this.onPointerMove_);\n    this.ptHandler_.emitter.on(\"up\", this.onPointerUp_);\n    this.view.element.addEventListener(\"keydown\", this.onKeyDown_);\n    this.view.element.addEventListener(\"keyup\", this.onKeyUp_);\n  }\n  handlePointerEvent_(d, opts) {\n    if (!d.point) {\n      return;\n    }\n    const saturation = mapRange(d.point.x, 0, d.bounds.width, 0, 100);\n    const value = mapRange(d.point.y, 0, d.bounds.height, 100, 0);\n    const [h, , , a] = this.value.rawValue.getComponents(\"hsv\");\n    this.value.setRawValue(new IntColor([h, saturation, value, a], \"hsv\"), opts);\n  }\n  onPointerDown_(ev) {\n    this.handlePointerEvent_(ev.data, {\n      forceEmit: false,\n      last: false\n    });\n  }\n  onPointerMove_(ev) {\n    this.handlePointerEvent_(ev.data, {\n      forceEmit: false,\n      last: false\n    });\n  }\n  onPointerUp_(ev) {\n    this.handlePointerEvent_(ev.data, {\n      forceEmit: true,\n      last: true\n    });\n  }\n  onKeyDown_(ev) {\n    if (isArrowKey(ev.key)) {\n      ev.preventDefault();\n    }\n    const [h, s, v, a] = this.value.rawValue.getComponents(\"hsv\");\n    const keyScale = getKeyScaleForColor(false);\n    const ds = getStepForKey(keyScale, getHorizontalStepKeys(ev));\n    const dv = getStepForKey(keyScale, getVerticalStepKeys(ev));\n    if (ds === 0 && dv === 0) {\n      return;\n    }\n    this.value.setRawValue(new IntColor([h, s + ds, v + dv, a], \"hsv\"), {\n      forceEmit: false,\n      last: false\n    });\n  }\n  onKeyUp_(ev) {\n    const keyScale = getKeyScaleForColor(false);\n    const ds = getStepForKey(keyScale, getHorizontalStepKeys(ev));\n    const dv = getStepForKey(keyScale, getVerticalStepKeys(ev));\n    if (ds === 0 && dv === 0) {\n      return;\n    }\n    this.value.setRawValue(this.value.rawValue, {\n      forceEmit: true,\n      last: true\n    });\n  }\n}\n\nclass ColorPickerController {\n  constructor(doc, config) {\n    this.value = config.value;\n    this.viewProps = config.viewProps;\n    this.hPaletteC_ = new HPaletteController(doc, {\n      value: this.value,\n      viewProps: this.viewProps\n    });\n    this.svPaletteC_ = new SvPaletteController(doc, {\n      value: this.value,\n      viewProps: this.viewProps\n    });\n    this.alphaIcs_ = config.supportsAlpha ? {\n      palette: new APaletteController(doc, {\n        value: this.value,\n        viewProps: this.viewProps\n      }),\n      text: new NumberTextController(doc, {\n        parser: parseNumber,\n        props: ValueMap.fromObject({\n          pointerScale: 0.01,\n          keyScale: 0.1,\n          formatter: createNumberFormatter(2)\n        }),\n        value: createValue(0, {\n          constraint: new DefiniteRangeConstraint({ min: 0, max: 1 })\n        }),\n        viewProps: this.viewProps\n      })\n    } : null;\n    if (this.alphaIcs_) {\n      connectValues({\n        primary: this.value,\n        secondary: this.alphaIcs_.text.value,\n        forward: (p) => p.getComponents()[3],\n        backward: (p, s) => {\n          const comps = p.getComponents();\n          comps[3] = s;\n          return new IntColor(comps, p.mode);\n        }\n      });\n    }\n    this.textsC_ = new ColorTextsController(doc, {\n      colorType: config.colorType,\n      value: this.value,\n      viewProps: this.viewProps\n    });\n    this.view = new ColorPickerView(doc, {\n      alphaViews: this.alphaIcs_ ? {\n        palette: this.alphaIcs_.palette.view,\n        text: this.alphaIcs_.text.view\n      } : null,\n      hPaletteView: this.hPaletteC_.view,\n      supportsAlpha: config.supportsAlpha,\n      svPaletteView: this.svPaletteC_.view,\n      textsView: this.textsC_.view,\n      viewProps: this.viewProps\n    });\n  }\n  get textsController() {\n    return this.textsC_;\n  }\n}\nvar cn$7 = ClassName(\"colsw\");\n\nclass ColorSwatchView {\n  constructor(doc, config) {\n    this.onValueChange_ = this.onValueChange_.bind(this);\n    config.value.emitter.on(\"change\", this.onValueChange_);\n    this.value = config.value;\n    this.element = doc.createElement(\"div\");\n    this.element.classList.add(cn$7());\n    config.viewProps.bindClassModifiers(this.element);\n    const swatchElem = doc.createElement(\"div\");\n    swatchElem.classList.add(cn$7(\"sw\"));\n    this.element.appendChild(swatchElem);\n    this.swatchElem_ = swatchElem;\n    const buttonElem = doc.createElement(\"button\");\n    buttonElem.classList.add(cn$7(\"b\"));\n    config.viewProps.bindDisabled(buttonElem);\n    this.element.appendChild(buttonElem);\n    this.buttonElement = buttonElem;\n    this.update_();\n  }\n  update_() {\n    const value = this.value.rawValue;\n    this.swatchElem_.style.backgroundColor = colorToHexRgbaString(value);\n  }\n  onValueChange_() {\n    this.update_();\n  }\n}\n\nclass ColorSwatchController {\n  constructor(doc, config) {\n    this.value = config.value;\n    this.viewProps = config.viewProps;\n    this.view = new ColorSwatchView(doc, {\n      value: this.value,\n      viewProps: this.viewProps\n    });\n  }\n}\n\nclass ColorController {\n  constructor(doc, config) {\n    this.onButtonBlur_ = this.onButtonBlur_.bind(this);\n    this.onButtonClick_ = this.onButtonClick_.bind(this);\n    this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);\n    this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);\n    this.value = config.value;\n    this.viewProps = config.viewProps;\n    this.foldable_ = Foldable.create(config.expanded);\n    this.swatchC_ = new ColorSwatchController(doc, {\n      value: this.value,\n      viewProps: this.viewProps\n    });\n    const buttonElem = this.swatchC_.view.buttonElement;\n    buttonElem.addEventListener(\"blur\", this.onButtonBlur_);\n    buttonElem.addEventListener(\"click\", this.onButtonClick_);\n    this.textC_ = new TextController(doc, {\n      parser: config.parser,\n      props: ValueMap.fromObject({\n        formatter: config.formatter\n      }),\n      value: this.value,\n      viewProps: this.viewProps\n    });\n    this.view = new ColorView(doc, {\n      foldable: this.foldable_,\n      pickerLayout: config.pickerLayout\n    });\n    this.view.swatchElement.appendChild(this.swatchC_.view.element);\n    this.view.textElement.appendChild(this.textC_.view.element);\n    this.popC_ = config.pickerLayout === \"popup\" ? new PopupController(doc, {\n      viewProps: this.viewProps\n    }) : null;\n    const pickerC = new ColorPickerController(doc, {\n      colorType: config.colorType,\n      supportsAlpha: config.supportsAlpha,\n      value: this.value,\n      viewProps: this.viewProps\n    });\n    pickerC.view.allFocusableElements.forEach((elem) => {\n      elem.addEventListener(\"blur\", this.onPopupChildBlur_);\n      elem.addEventListener(\"keydown\", this.onPopupChildKeydown_);\n    });\n    this.pickerC_ = pickerC;\n    if (this.popC_) {\n      this.view.element.appendChild(this.popC_.view.element);\n      this.popC_.view.element.appendChild(pickerC.view.element);\n      connectValues({\n        primary: this.foldable_.value(\"expanded\"),\n        secondary: this.popC_.shows,\n        forward: (p) => p,\n        backward: (_, s) => s\n      });\n    } else if (this.view.pickerElement) {\n      this.view.pickerElement.appendChild(this.pickerC_.view.element);\n      bindFoldable(this.foldable_, this.view.pickerElement);\n    }\n  }\n  get textController() {\n    return this.textC_;\n  }\n  onButtonBlur_(e) {\n    if (!this.popC_) {\n      return;\n    }\n    const elem = this.view.element;\n    const nextTarget = forceCast(e.relatedTarget);\n    if (!nextTarget || !elem.contains(nextTarget)) {\n      this.popC_.shows.rawValue = false;\n    }\n  }\n  onButtonClick_() {\n    this.foldable_.set(\"expanded\", !this.foldable_.get(\"expanded\"));\n    if (this.foldable_.get(\"expanded\")) {\n      this.pickerC_.view.allFocusableElements[0].focus();\n    }\n  }\n  onPopupChildBlur_(ev) {\n    if (!this.popC_) {\n      return;\n    }\n    const elem = this.popC_.view.element;\n    const nextTarget = findNextTarget(ev);\n    if (nextTarget && elem.contains(nextTarget)) {\n      return;\n    }\n    if (nextTarget && nextTarget === this.swatchC_.view.buttonElement && !supportsTouch(elem.ownerDocument)) {\n      return;\n    }\n    this.popC_.shows.rawValue = false;\n  }\n  onPopupChildKeydown_(ev) {\n    if (this.popC_) {\n      if (ev.key === \"Escape\") {\n        this.popC_.shows.rawValue = false;\n      }\n    } else if (this.view.pickerElement) {\n      if (ev.key === \"Escape\") {\n        this.swatchC_.view.buttonElement.focus();\n      }\n    }\n  }\n}\nfunction colorToRgbNumber(value) {\n  return removeAlphaComponent(value.getComponents(\"rgb\")).reduce((result, comp) => {\n    return result << 8 | Math.floor(comp) & 255;\n  }, 0);\n}\nfunction colorToRgbaNumber(value) {\n  return value.getComponents(\"rgb\").reduce((result, comp, index) => {\n    const hex = Math.floor(index === 3 ? comp * 255 : comp) & 255;\n    return result << 8 | hex;\n  }, 0) >>> 0;\n}\nfunction numberToRgbColor(num) {\n  return new IntColor([num >> 16 & 255, num >> 8 & 255, num & 255], \"rgb\");\n}\nfunction numberToRgbaColor(num) {\n  return new IntColor([\n    num >> 24 & 255,\n    num >> 16 & 255,\n    num >> 8 & 255,\n    mapRange(num & 255, 0, 255, 0, 1)\n  ], \"rgb\");\n}\nfunction colorFromRgbNumber(value) {\n  if (typeof value !== \"number\") {\n    return IntColor.black();\n  }\n  return numberToRgbColor(value);\n}\nfunction colorFromRgbaNumber(value) {\n  if (typeof value !== \"number\") {\n    return IntColor.black();\n  }\n  return numberToRgbaColor(value);\n}\nfunction isRgbColorComponent(obj, key) {\n  if (typeof obj !== \"object\" || isEmpty(obj)) {\n    return false;\n  }\n  return key in obj && typeof obj[key] === \"number\";\n}\nfunction isRgbColorObject(obj) {\n  return isRgbColorComponent(obj, \"r\") && isRgbColorComponent(obj, \"g\") && isRgbColorComponent(obj, \"b\");\n}\nfunction isRgbaColorObject(obj) {\n  return isRgbColorObject(obj) && isRgbColorComponent(obj, \"a\");\n}\nfunction isColorObject(obj) {\n  return isRgbColorObject(obj);\n}\nfunction equalsColor(v1, v2) {\n  if (v1.mode !== v2.mode) {\n    return false;\n  }\n  if (v1.type !== v2.type) {\n    return false;\n  }\n  const comps1 = v1.getComponents();\n  const comps2 = v2.getComponents();\n  for (let i = 0;i < comps1.length; i++) {\n    if (comps1[i] !== comps2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction createColorComponentsFromRgbObject(obj) {\n  return \"a\" in obj ? [obj.r, obj.g, obj.b, obj.a] : [obj.r, obj.g, obj.b];\n}\nfunction createColorStringWriter(format) {\n  const stringify = findColorStringifier(format);\n  return stringify ? (target, value) => {\n    writePrimitive(target, stringify(value));\n  } : null;\n}\nfunction createColorNumberWriter(supportsAlpha) {\n  const colorToNumber = supportsAlpha ? colorToRgbaNumber : colorToRgbNumber;\n  return (target, value) => {\n    writePrimitive(target, colorToNumber(value));\n  };\n}\nfunction writeRgbaColorObject(target, value, type) {\n  const cc = mapColorType(value, type);\n  const obj = cc.toRgbaObject();\n  target.writeProperty(\"r\", obj.r);\n  target.writeProperty(\"g\", obj.g);\n  target.writeProperty(\"b\", obj.b);\n  target.writeProperty(\"a\", obj.a);\n}\nfunction writeRgbColorObject(target, value, type) {\n  const cc = mapColorType(value, type);\n  const obj = cc.toRgbaObject();\n  target.writeProperty(\"r\", obj.r);\n  target.writeProperty(\"g\", obj.g);\n  target.writeProperty(\"b\", obj.b);\n}\nfunction createColorObjectWriter(supportsAlpha, type) {\n  return (target, inValue) => {\n    if (supportsAlpha) {\n      writeRgbaColorObject(target, inValue, type);\n    } else {\n      writeRgbColorObject(target, inValue, type);\n    }\n  };\n}\nfunction shouldSupportAlpha$1(inputParams) {\n  var _a;\n  if ((_a = inputParams === null || inputParams === undefined ? undefined : inputParams.color) === null || _a === undefined ? undefined : _a.alpha) {\n    return true;\n  }\n  return false;\n}\nfunction createFormatter$1(supportsAlpha) {\n  return supportsAlpha ? (v) => colorToHexRgbaString(v, \"0x\") : (v) => colorToHexRgbString(v, \"0x\");\n}\nfunction isForColor(params) {\n  if (\"color\" in params) {\n    return true;\n  }\n  if (params.view === \"color\") {\n    return true;\n  }\n  return false;\n}\nvar NumberColorInputPlugin = createPlugin({\n  id: \"input-color-number\",\n  type: \"input\",\n  accept: (value, params) => {\n    if (typeof value !== \"number\") {\n      return null;\n    }\n    if (!isForColor(params)) {\n      return null;\n    }\n    const result = parseColorInputParams(params);\n    return result ? {\n      initialValue: value,\n      params: Object.assign(Object.assign({}, result), { supportsAlpha: shouldSupportAlpha$1(params) })\n    } : null;\n  },\n  binding: {\n    reader: (args) => {\n      return args.params.supportsAlpha ? colorFromRgbaNumber : colorFromRgbNumber;\n    },\n    equals: equalsColor,\n    writer: (args) => {\n      return createColorNumberWriter(args.params.supportsAlpha);\n    }\n  },\n  controller: (args) => {\n    var _a, _b;\n    return new ColorController(args.document, {\n      colorType: \"int\",\n      expanded: (_a = args.params.expanded) !== null && _a !== undefined ? _a : false,\n      formatter: createFormatter$1(args.params.supportsAlpha),\n      parser: createColorStringParser(\"int\"),\n      pickerLayout: (_b = args.params.picker) !== null && _b !== undefined ? _b : \"popup\",\n      supportsAlpha: args.params.supportsAlpha,\n      value: args.value,\n      viewProps: args.viewProps\n    });\n  }\n});\nfunction colorFromObject(value, type) {\n  if (!isColorObject(value)) {\n    return mapColorType(IntColor.black(), type);\n  }\n  if (type === \"int\") {\n    const comps = createColorComponentsFromRgbObject(value);\n    return new IntColor(comps, \"rgb\");\n  }\n  if (type === \"float\") {\n    const comps = createColorComponentsFromRgbObject(value);\n    return new FloatColor(comps, \"rgb\");\n  }\n  return mapColorType(IntColor.black(), \"int\");\n}\nfunction shouldSupportAlpha(initialValue) {\n  return isRgbaColorObject(initialValue);\n}\nfunction createColorObjectBindingReader(type) {\n  return (value) => {\n    const c = colorFromObject(value, type);\n    return mapColorType(c, \"int\");\n  };\n}\nfunction createColorObjectFormatter(supportsAlpha, type) {\n  return (value) => {\n    if (supportsAlpha) {\n      return colorToObjectRgbaString(value, type);\n    }\n    return colorToObjectRgbString(value, type);\n  };\n}\nvar ObjectColorInputPlugin = createPlugin({\n  id: \"input-color-object\",\n  type: \"input\",\n  accept: (value, params) => {\n    var _a;\n    if (!isColorObject(value)) {\n      return null;\n    }\n    const result = parseColorInputParams(params);\n    return result ? {\n      initialValue: value,\n      params: Object.assign(Object.assign({}, result), { colorType: (_a = extractColorType(params)) !== null && _a !== undefined ? _a : \"int\" })\n    } : null;\n  },\n  binding: {\n    reader: (args) => createColorObjectBindingReader(args.params.colorType),\n    equals: equalsColor,\n    writer: (args) => createColorObjectWriter(shouldSupportAlpha(args.initialValue), args.params.colorType)\n  },\n  controller: (args) => {\n    var _a, _b;\n    const supportsAlpha = isRgbaColorObject(args.initialValue);\n    return new ColorController(args.document, {\n      colorType: args.params.colorType,\n      expanded: (_a = args.params.expanded) !== null && _a !== undefined ? _a : false,\n      formatter: createColorObjectFormatter(supportsAlpha, args.params.colorType),\n      parser: createColorStringParser(\"int\"),\n      pickerLayout: (_b = args.params.picker) !== null && _b !== undefined ? _b : \"popup\",\n      supportsAlpha,\n      value: args.value,\n      viewProps: args.viewProps\n    });\n  }\n});\nvar StringColorInputPlugin = createPlugin({\n  id: \"input-color-string\",\n  type: \"input\",\n  accept: (value, params) => {\n    if (typeof value !== \"string\") {\n      return null;\n    }\n    if (params.view === \"text\") {\n      return null;\n    }\n    const format = detectStringColorFormat(value, extractColorType(params));\n    if (!format) {\n      return null;\n    }\n    const stringifier = findColorStringifier(format);\n    if (!stringifier) {\n      return null;\n    }\n    const result = parseColorInputParams(params);\n    return result ? {\n      initialValue: value,\n      params: Object.assign(Object.assign({}, result), { format, stringifier })\n    } : null;\n  },\n  binding: {\n    reader: () => readIntColorString,\n    equals: equalsColor,\n    writer: (args) => {\n      const writer = createColorStringWriter(args.params.format);\n      if (!writer) {\n        throw TpError.notBindable();\n      }\n      return writer;\n    }\n  },\n  controller: (args) => {\n    var _a, _b;\n    return new ColorController(args.document, {\n      colorType: args.params.format.type,\n      expanded: (_a = args.params.expanded) !== null && _a !== undefined ? _a : false,\n      formatter: args.params.stringifier,\n      parser: createColorStringParser(\"int\"),\n      pickerLayout: (_b = args.params.picker) !== null && _b !== undefined ? _b : \"popup\",\n      supportsAlpha: args.params.format.alpha,\n      value: args.value,\n      viewProps: args.viewProps\n    });\n  }\n});\n\nclass PointNdConstraint {\n  constructor(config) {\n    this.components = config.components;\n    this.asm_ = config.assembly;\n  }\n  constrain(value) {\n    const comps = this.asm_.toComponents(value).map((comp, index) => {\n      var _a, _b;\n      return (_b = (_a = this.components[index]) === null || _a === undefined ? undefined : _a.constrain(comp)) !== null && _b !== undefined ? _b : comp;\n    });\n    return this.asm_.fromComponents(comps);\n  }\n}\nvar cn$6 = ClassName(\"pndtxt\");\n\nclass PointNdTextView {\n  constructor(doc, config) {\n    this.textViews = config.textViews;\n    this.element = doc.createElement(\"div\");\n    this.element.classList.add(cn$6());\n    this.textViews.forEach((v) => {\n      const axisElem = doc.createElement(\"div\");\n      axisElem.classList.add(cn$6(\"a\"));\n      axisElem.appendChild(v.element);\n      this.element.appendChild(axisElem);\n    });\n  }\n}\nfunction createAxisController(doc, config, index) {\n  return new NumberTextController(doc, {\n    arrayPosition: index === 0 ? \"fst\" : index === config.axes.length - 1 ? \"lst\" : \"mid\",\n    parser: config.parser,\n    props: config.axes[index].textProps,\n    value: createValue(0, {\n      constraint: config.axes[index].constraint\n    }),\n    viewProps: config.viewProps\n  });\n}\n\nclass PointNdTextController {\n  constructor(doc, config) {\n    this.value = config.value;\n    this.viewProps = config.viewProps;\n    this.acs_ = config.axes.map((_, index) => createAxisController(doc, config, index));\n    this.acs_.forEach((c, index) => {\n      connectValues({\n        primary: this.value,\n        secondary: c.value,\n        forward: (p) => config.assembly.toComponents(p)[index],\n        backward: (p, s) => {\n          const comps = config.assembly.toComponents(p);\n          comps[index] = s;\n          return config.assembly.fromComponents(comps);\n        }\n      });\n    });\n    this.view = new PointNdTextView(doc, {\n      textViews: this.acs_.map((ac) => ac.view)\n    });\n  }\n  get textControllers() {\n    return this.acs_;\n  }\n}\n\nclass SliderInputBindingApi extends BindingApi {\n  get max() {\n    return this.controller.valueController.sliderController.props.get(\"max\");\n  }\n  set max(max) {\n    this.controller.valueController.sliderController.props.set(\"max\", max);\n  }\n  get min() {\n    return this.controller.valueController.sliderController.props.get(\"min\");\n  }\n  set min(max) {\n    this.controller.valueController.sliderController.props.set(\"min\", max);\n  }\n}\nfunction createConstraint$4(params, initialValue) {\n  const constraints = [];\n  const sc = createStepConstraint(params, initialValue);\n  if (sc) {\n    constraints.push(sc);\n  }\n  const rc = createRangeConstraint(params);\n  if (rc) {\n    constraints.push(rc);\n  }\n  const lc = createListConstraint(params.options);\n  if (lc) {\n    constraints.push(lc);\n  }\n  return new CompositeConstraint(constraints);\n}\nvar NumberInputPlugin = createPlugin({\n  id: \"input-number\",\n  type: \"input\",\n  accept: (value, params) => {\n    if (typeof value !== \"number\") {\n      return null;\n    }\n    const result = parseRecord(params, (p) => Object.assign(Object.assign({}, createNumberTextInputParamsParser(p)), { options: p.optional.custom(parseListOptions), readonly: p.optional.constant(false) }));\n    return result ? {\n      initialValue: value,\n      params: result\n    } : null;\n  },\n  binding: {\n    reader: (_args) => numberFromUnknown,\n    constraint: (args) => createConstraint$4(args.params, args.initialValue),\n    writer: (_args) => writePrimitive\n  },\n  controller: (args) => {\n    const value = args.value;\n    const c = args.constraint;\n    const lc = c && findConstraint(c, ListConstraint);\n    if (lc) {\n      return new ListController(args.document, {\n        props: new ValueMap({\n          options: lc.values.value(\"options\")\n        }),\n        value,\n        viewProps: args.viewProps\n      });\n    }\n    const textPropsObj = createNumberTextPropsObject(args.params, value.rawValue);\n    const drc = c && findConstraint(c, DefiniteRangeConstraint);\n    if (drc) {\n      return new SliderTextController(args.document, Object.assign(Object.assign({}, createSliderTextProps(Object.assign(Object.assign({}, textPropsObj), { keyScale: createValue(textPropsObj.keyScale), max: drc.values.value(\"max\"), min: drc.values.value(\"min\") }))), { parser: parseNumber, value, viewProps: args.viewProps }));\n    }\n    return new NumberTextController(args.document, {\n      parser: parseNumber,\n      props: ValueMap.fromObject(textPropsObj),\n      value,\n      viewProps: args.viewProps\n    });\n  },\n  api(args) {\n    if (typeof args.controller.value.rawValue !== \"number\") {\n      return null;\n    }\n    if (args.controller.valueController instanceof SliderTextController) {\n      return new SliderInputBindingApi(args.controller);\n    }\n    if (args.controller.valueController instanceof ListController) {\n      return new ListInputBindingApi(args.controller);\n    }\n    return null;\n  }\n});\n\nclass Point2d {\n  constructor(x = 0, y = 0) {\n    this.x = x;\n    this.y = y;\n  }\n  getComponents() {\n    return [this.x, this.y];\n  }\n  static isObject(obj) {\n    if (isEmpty(obj)) {\n      return false;\n    }\n    const x = obj.x;\n    const y = obj.y;\n    if (typeof x !== \"number\" || typeof y !== \"number\") {\n      return false;\n    }\n    return true;\n  }\n  static equals(v1, v2) {\n    return v1.x === v2.x && v1.y === v2.y;\n  }\n  toObject() {\n    return {\n      x: this.x,\n      y: this.y\n    };\n  }\n}\nvar Point2dAssembly = {\n  toComponents: (p) => p.getComponents(),\n  fromComponents: (comps) => new Point2d(...comps)\n};\nvar cn$5 = ClassName(\"p2d\");\n\nclass Point2dView {\n  constructor(doc, config) {\n    this.element = doc.createElement(\"div\");\n    this.element.classList.add(cn$5());\n    config.viewProps.bindClassModifiers(this.element);\n    bindValue(config.expanded, valueToClassName(this.element, cn$5(undefined, \"expanded\")));\n    const headElem = doc.createElement(\"div\");\n    headElem.classList.add(cn$5(\"h\"));\n    this.element.appendChild(headElem);\n    const buttonElem = doc.createElement(\"button\");\n    buttonElem.classList.add(cn$5(\"b\"));\n    buttonElem.appendChild(createSvgIconElement(doc, \"p2dpad\"));\n    config.viewProps.bindDisabled(buttonElem);\n    headElem.appendChild(buttonElem);\n    this.buttonElement = buttonElem;\n    const textElem = doc.createElement(\"div\");\n    textElem.classList.add(cn$5(\"t\"));\n    headElem.appendChild(textElem);\n    this.textElement = textElem;\n    if (config.pickerLayout === \"inline\") {\n      const pickerElem = doc.createElement(\"div\");\n      pickerElem.classList.add(cn$5(\"p\"));\n      this.element.appendChild(pickerElem);\n      this.pickerElement = pickerElem;\n    } else {\n      this.pickerElement = null;\n    }\n  }\n}\nvar cn$4 = ClassName(\"p2dp\");\n\nclass Point2dPickerView {\n  constructor(doc, config) {\n    this.onFoldableChange_ = this.onFoldableChange_.bind(this);\n    this.onPropsChange_ = this.onPropsChange_.bind(this);\n    this.onValueChange_ = this.onValueChange_.bind(this);\n    this.props_ = config.props;\n    this.props_.emitter.on(\"change\", this.onPropsChange_);\n    this.element = doc.createElement(\"div\");\n    this.element.classList.add(cn$4());\n    if (config.layout === \"popup\") {\n      this.element.classList.add(cn$4(undefined, \"p\"));\n    }\n    config.viewProps.bindClassModifiers(this.element);\n    const padElem = doc.createElement(\"div\");\n    padElem.classList.add(cn$4(\"p\"));\n    config.viewProps.bindTabIndex(padElem);\n    this.element.appendChild(padElem);\n    this.padElement = padElem;\n    const svgElem = doc.createElementNS(SVG_NS, \"svg\");\n    svgElem.classList.add(cn$4(\"g\"));\n    this.padElement.appendChild(svgElem);\n    this.svgElem_ = svgElem;\n    const xAxisElem = doc.createElementNS(SVG_NS, \"line\");\n    xAxisElem.classList.add(cn$4(\"ax\"));\n    xAxisElem.setAttributeNS(null, \"x1\", \"0\");\n    xAxisElem.setAttributeNS(null, \"y1\", \"50%\");\n    xAxisElem.setAttributeNS(null, \"x2\", \"100%\");\n    xAxisElem.setAttributeNS(null, \"y2\", \"50%\");\n    this.svgElem_.appendChild(xAxisElem);\n    const yAxisElem = doc.createElementNS(SVG_NS, \"line\");\n    yAxisElem.classList.add(cn$4(\"ax\"));\n    yAxisElem.setAttributeNS(null, \"x1\", \"50%\");\n    yAxisElem.setAttributeNS(null, \"y1\", \"0\");\n    yAxisElem.setAttributeNS(null, \"x2\", \"50%\");\n    yAxisElem.setAttributeNS(null, \"y2\", \"100%\");\n    this.svgElem_.appendChild(yAxisElem);\n    const lineElem = doc.createElementNS(SVG_NS, \"line\");\n    lineElem.classList.add(cn$4(\"l\"));\n    lineElem.setAttributeNS(null, \"x1\", \"50%\");\n    lineElem.setAttributeNS(null, \"y1\", \"50%\");\n    this.svgElem_.appendChild(lineElem);\n    this.lineElem_ = lineElem;\n    const markerElem = doc.createElement(\"div\");\n    markerElem.classList.add(cn$4(\"m\"));\n    this.padElement.appendChild(markerElem);\n    this.markerElem_ = markerElem;\n    config.value.emitter.on(\"change\", this.onValueChange_);\n    this.value = config.value;\n    this.update_();\n  }\n  get allFocusableElements() {\n    return [this.padElement];\n  }\n  update_() {\n    const [x, y] = this.value.rawValue.getComponents();\n    const max = this.props_.get(\"max\");\n    const px = mapRange(x, -max, +max, 0, 100);\n    const py = mapRange(y, -max, +max, 0, 100);\n    const ipy = this.props_.get(\"invertsY\") ? 100 - py : py;\n    this.lineElem_.setAttributeNS(null, \"x2\", `${px}%`);\n    this.lineElem_.setAttributeNS(null, \"y2\", `${ipy}%`);\n    this.markerElem_.style.left = `${px}%`;\n    this.markerElem_.style.top = `${ipy}%`;\n  }\n  onValueChange_() {\n    this.update_();\n  }\n  onPropsChange_() {\n    this.update_();\n  }\n  onFoldableChange_() {\n    this.update_();\n  }\n}\nfunction computeOffset(ev, keyScales, invertsY) {\n  return [\n    getStepForKey(keyScales[0], getHorizontalStepKeys(ev)),\n    getStepForKey(keyScales[1], getVerticalStepKeys(ev)) * (invertsY ? 1 : -1)\n  ];\n}\n\nclass Point2dPickerController {\n  constructor(doc, config) {\n    this.onPadKeyDown_ = this.onPadKeyDown_.bind(this);\n    this.onPadKeyUp_ = this.onPadKeyUp_.bind(this);\n    this.onPointerDown_ = this.onPointerDown_.bind(this);\n    this.onPointerMove_ = this.onPointerMove_.bind(this);\n    this.onPointerUp_ = this.onPointerUp_.bind(this);\n    this.props = config.props;\n    this.value = config.value;\n    this.viewProps = config.viewProps;\n    this.view = new Point2dPickerView(doc, {\n      layout: config.layout,\n      props: this.props,\n      value: this.value,\n      viewProps: this.viewProps\n    });\n    this.ptHandler_ = new PointerHandler(this.view.padElement);\n    this.ptHandler_.emitter.on(\"down\", this.onPointerDown_);\n    this.ptHandler_.emitter.on(\"move\", this.onPointerMove_);\n    this.ptHandler_.emitter.on(\"up\", this.onPointerUp_);\n    this.view.padElement.addEventListener(\"keydown\", this.onPadKeyDown_);\n    this.view.padElement.addEventListener(\"keyup\", this.onPadKeyUp_);\n  }\n  handlePointerEvent_(d, opts) {\n    if (!d.point) {\n      return;\n    }\n    const max = this.props.get(\"max\");\n    const px = mapRange(d.point.x, 0, d.bounds.width, -max, +max);\n    const py = mapRange(this.props.get(\"invertsY\") ? d.bounds.height - d.point.y : d.point.y, 0, d.bounds.height, -max, +max);\n    this.value.setRawValue(new Point2d(px, py), opts);\n  }\n  onPointerDown_(ev) {\n    this.handlePointerEvent_(ev.data, {\n      forceEmit: false,\n      last: false\n    });\n  }\n  onPointerMove_(ev) {\n    this.handlePointerEvent_(ev.data, {\n      forceEmit: false,\n      last: false\n    });\n  }\n  onPointerUp_(ev) {\n    this.handlePointerEvent_(ev.data, {\n      forceEmit: true,\n      last: true\n    });\n  }\n  onPadKeyDown_(ev) {\n    if (isArrowKey(ev.key)) {\n      ev.preventDefault();\n    }\n    const [dx, dy] = computeOffset(ev, [this.props.get(\"xKeyScale\"), this.props.get(\"yKeyScale\")], this.props.get(\"invertsY\"));\n    if (dx === 0 && dy === 0) {\n      return;\n    }\n    this.value.setRawValue(new Point2d(this.value.rawValue.x + dx, this.value.rawValue.y + dy), {\n      forceEmit: false,\n      last: false\n    });\n  }\n  onPadKeyUp_(ev) {\n    const [dx, dy] = computeOffset(ev, [this.props.get(\"xKeyScale\"), this.props.get(\"yKeyScale\")], this.props.get(\"invertsY\"));\n    if (dx === 0 && dy === 0) {\n      return;\n    }\n    this.value.setRawValue(this.value.rawValue, {\n      forceEmit: true,\n      last: true\n    });\n  }\n}\n\nclass Point2dController {\n  constructor(doc, config) {\n    var _a, _b;\n    this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);\n    this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);\n    this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this);\n    this.onPadButtonClick_ = this.onPadButtonClick_.bind(this);\n    this.value = config.value;\n    this.viewProps = config.viewProps;\n    this.foldable_ = Foldable.create(config.expanded);\n    this.popC_ = config.pickerLayout === \"popup\" ? new PopupController(doc, {\n      viewProps: this.viewProps\n    }) : null;\n    const padC = new Point2dPickerController(doc, {\n      layout: config.pickerLayout,\n      props: new ValueMap({\n        invertsY: createValue(config.invertsY),\n        max: createValue(config.max),\n        xKeyScale: config.axes[0].textProps.value(\"keyScale\"),\n        yKeyScale: config.axes[1].textProps.value(\"keyScale\")\n      }),\n      value: this.value,\n      viewProps: this.viewProps\n    });\n    padC.view.allFocusableElements.forEach((elem) => {\n      elem.addEventListener(\"blur\", this.onPopupChildBlur_);\n      elem.addEventListener(\"keydown\", this.onPopupChildKeydown_);\n    });\n    this.pickerC_ = padC;\n    this.textC_ = new PointNdTextController(doc, {\n      assembly: Point2dAssembly,\n      axes: config.axes,\n      parser: config.parser,\n      value: this.value,\n      viewProps: this.viewProps\n    });\n    this.view = new Point2dView(doc, {\n      expanded: this.foldable_.value(\"expanded\"),\n      pickerLayout: config.pickerLayout,\n      viewProps: this.viewProps\n    });\n    this.view.textElement.appendChild(this.textC_.view.element);\n    (_a = this.view.buttonElement) === null || _a === undefined || _a.addEventListener(\"blur\", this.onPadButtonBlur_);\n    (_b = this.view.buttonElement) === null || _b === undefined || _b.addEventListener(\"click\", this.onPadButtonClick_);\n    if (this.popC_) {\n      this.view.element.appendChild(this.popC_.view.element);\n      this.popC_.view.element.appendChild(this.pickerC_.view.element);\n      connectValues({\n        primary: this.foldable_.value(\"expanded\"),\n        secondary: this.popC_.shows,\n        forward: (p) => p,\n        backward: (_, s) => s\n      });\n    } else if (this.view.pickerElement) {\n      this.view.pickerElement.appendChild(this.pickerC_.view.element);\n      bindFoldable(this.foldable_, this.view.pickerElement);\n    }\n  }\n  get textController() {\n    return this.textC_;\n  }\n  onPadButtonBlur_(e) {\n    if (!this.popC_) {\n      return;\n    }\n    const elem = this.view.element;\n    const nextTarget = forceCast(e.relatedTarget);\n    if (!nextTarget || !elem.contains(nextTarget)) {\n      this.popC_.shows.rawValue = false;\n    }\n  }\n  onPadButtonClick_() {\n    this.foldable_.set(\"expanded\", !this.foldable_.get(\"expanded\"));\n    if (this.foldable_.get(\"expanded\")) {\n      this.pickerC_.view.allFocusableElements[0].focus();\n    }\n  }\n  onPopupChildBlur_(ev) {\n    if (!this.popC_) {\n      return;\n    }\n    const elem = this.popC_.view.element;\n    const nextTarget = findNextTarget(ev);\n    if (nextTarget && elem.contains(nextTarget)) {\n      return;\n    }\n    if (nextTarget && nextTarget === this.view.buttonElement && !supportsTouch(elem.ownerDocument)) {\n      return;\n    }\n    this.popC_.shows.rawValue = false;\n  }\n  onPopupChildKeydown_(ev) {\n    if (this.popC_) {\n      if (ev.key === \"Escape\") {\n        this.popC_.shows.rawValue = false;\n      }\n    } else if (this.view.pickerElement) {\n      if (ev.key === \"Escape\") {\n        this.view.buttonElement.focus();\n      }\n    }\n  }\n}\nfunction point2dFromUnknown(value) {\n  return Point2d.isObject(value) ? new Point2d(value.x, value.y) : new Point2d;\n}\nfunction writePoint2d(target, value) {\n  target.writeProperty(\"x\", value.x);\n  target.writeProperty(\"y\", value.y);\n}\nfunction createConstraint$3(params, initialValue) {\n  return new PointNdConstraint({\n    assembly: Point2dAssembly,\n    components: [\n      createDimensionConstraint(Object.assign(Object.assign({}, params), params.x), initialValue.x),\n      createDimensionConstraint(Object.assign(Object.assign({}, params), params.y), initialValue.y)\n    ]\n  });\n}\nfunction getSuitableMaxDimensionValue(params, rawValue) {\n  var _a, _b;\n  if (!isEmpty(params.min) || !isEmpty(params.max)) {\n    return Math.max(Math.abs((_a = params.min) !== null && _a !== undefined ? _a : 0), Math.abs((_b = params.max) !== null && _b !== undefined ? _b : 0));\n  }\n  const step = getSuitableKeyScale(params);\n  return Math.max(Math.abs(step) * 10, Math.abs(rawValue) * 10);\n}\nfunction getSuitableMax(params, initialValue) {\n  var _a, _b;\n  const xr = getSuitableMaxDimensionValue(deepMerge(params, (_a = params.x) !== null && _a !== undefined ? _a : {}), initialValue.x);\n  const yr = getSuitableMaxDimensionValue(deepMerge(params, (_b = params.y) !== null && _b !== undefined ? _b : {}), initialValue.y);\n  return Math.max(xr, yr);\n}\nfunction shouldInvertY(params) {\n  if (!(\"y\" in params)) {\n    return false;\n  }\n  const yParams = params.y;\n  if (!yParams) {\n    return false;\n  }\n  return \"inverted\" in yParams ? !!yParams.inverted : false;\n}\nvar Point2dInputPlugin = createPlugin({\n  id: \"input-point2d\",\n  type: \"input\",\n  accept: (value, params) => {\n    if (!Point2d.isObject(value)) {\n      return null;\n    }\n    const result = parseRecord(params, (p) => Object.assign(Object.assign({}, createPointDimensionParser(p)), { expanded: p.optional.boolean, picker: p.optional.custom(parsePickerLayout), readonly: p.optional.constant(false), x: p.optional.custom(parsePointDimensionParams), y: p.optional.object(Object.assign(Object.assign({}, createPointDimensionParser(p)), { inverted: p.optional.boolean })) }));\n    return result ? {\n      initialValue: value,\n      params: result\n    } : null;\n  },\n  binding: {\n    reader: () => point2dFromUnknown,\n    constraint: (args) => createConstraint$3(args.params, args.initialValue),\n    equals: Point2d.equals,\n    writer: () => writePoint2d\n  },\n  controller: (args) => {\n    var _a, _b;\n    const doc = args.document;\n    const value = args.value;\n    const c = args.constraint;\n    const dParams = [args.params.x, args.params.y];\n    return new Point2dController(doc, {\n      axes: value.rawValue.getComponents().map((comp, i) => {\n        var _a2;\n        return createPointAxis({\n          constraint: c.components[i],\n          initialValue: comp,\n          params: deepMerge(args.params, (_a2 = dParams[i]) !== null && _a2 !== undefined ? _a2 : {})\n        });\n      }),\n      expanded: (_a = args.params.expanded) !== null && _a !== undefined ? _a : false,\n      invertsY: shouldInvertY(args.params),\n      max: getSuitableMax(args.params, value.rawValue),\n      parser: parseNumber,\n      pickerLayout: (_b = args.params.picker) !== null && _b !== undefined ? _b : \"popup\",\n      value,\n      viewProps: args.viewProps\n    });\n  }\n});\n\nclass Point3d {\n  constructor(x = 0, y = 0, z = 0) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n  getComponents() {\n    return [this.x, this.y, this.z];\n  }\n  static isObject(obj) {\n    if (isEmpty(obj)) {\n      return false;\n    }\n    const x = obj.x;\n    const y = obj.y;\n    const z = obj.z;\n    if (typeof x !== \"number\" || typeof y !== \"number\" || typeof z !== \"number\") {\n      return false;\n    }\n    return true;\n  }\n  static equals(v1, v2) {\n    return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z;\n  }\n  toObject() {\n    return {\n      x: this.x,\n      y: this.y,\n      z: this.z\n    };\n  }\n}\nvar Point3dAssembly = {\n  toComponents: (p) => p.getComponents(),\n  fromComponents: (comps) => new Point3d(...comps)\n};\nfunction point3dFromUnknown(value) {\n  return Point3d.isObject(value) ? new Point3d(value.x, value.y, value.z) : new Point3d;\n}\nfunction writePoint3d(target, value) {\n  target.writeProperty(\"x\", value.x);\n  target.writeProperty(\"y\", value.y);\n  target.writeProperty(\"z\", value.z);\n}\nfunction createConstraint$2(params, initialValue) {\n  return new PointNdConstraint({\n    assembly: Point3dAssembly,\n    components: [\n      createDimensionConstraint(Object.assign(Object.assign({}, params), params.x), initialValue.x),\n      createDimensionConstraint(Object.assign(Object.assign({}, params), params.y), initialValue.y),\n      createDimensionConstraint(Object.assign(Object.assign({}, params), params.z), initialValue.z)\n    ]\n  });\n}\nvar Point3dInputPlugin = createPlugin({\n  id: \"input-point3d\",\n  type: \"input\",\n  accept: (value, params) => {\n    if (!Point3d.isObject(value)) {\n      return null;\n    }\n    const result = parseRecord(params, (p) => Object.assign(Object.assign({}, createPointDimensionParser(p)), { readonly: p.optional.constant(false), x: p.optional.custom(parsePointDimensionParams), y: p.optional.custom(parsePointDimensionParams), z: p.optional.custom(parsePointDimensionParams) }));\n    return result ? {\n      initialValue: value,\n      params: result\n    } : null;\n  },\n  binding: {\n    reader: (_args) => point3dFromUnknown,\n    constraint: (args) => createConstraint$2(args.params, args.initialValue),\n    equals: Point3d.equals,\n    writer: (_args) => writePoint3d\n  },\n  controller: (args) => {\n    const value = args.value;\n    const c = args.constraint;\n    const dParams = [args.params.x, args.params.y, args.params.z];\n    return new PointNdTextController(args.document, {\n      assembly: Point3dAssembly,\n      axes: value.rawValue.getComponents().map((comp, i) => {\n        var _a;\n        return createPointAxis({\n          constraint: c.components[i],\n          initialValue: comp,\n          params: deepMerge(args.params, (_a = dParams[i]) !== null && _a !== undefined ? _a : {})\n        });\n      }),\n      parser: parseNumber,\n      value,\n      viewProps: args.viewProps\n    });\n  }\n});\n\nclass Point4d {\n  constructor(x = 0, y = 0, z = 0, w = 0) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n  }\n  getComponents() {\n    return [this.x, this.y, this.z, this.w];\n  }\n  static isObject(obj) {\n    if (isEmpty(obj)) {\n      return false;\n    }\n    const x = obj.x;\n    const y = obj.y;\n    const z = obj.z;\n    const w = obj.w;\n    if (typeof x !== \"number\" || typeof y !== \"number\" || typeof z !== \"number\" || typeof w !== \"number\") {\n      return false;\n    }\n    return true;\n  }\n  static equals(v1, v2) {\n    return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z && v1.w === v2.w;\n  }\n  toObject() {\n    return {\n      x: this.x,\n      y: this.y,\n      z: this.z,\n      w: this.w\n    };\n  }\n}\nvar Point4dAssembly = {\n  toComponents: (p) => p.getComponents(),\n  fromComponents: (comps) => new Point4d(...comps)\n};\nfunction point4dFromUnknown(value) {\n  return Point4d.isObject(value) ? new Point4d(value.x, value.y, value.z, value.w) : new Point4d;\n}\nfunction writePoint4d(target, value) {\n  target.writeProperty(\"x\", value.x);\n  target.writeProperty(\"y\", value.y);\n  target.writeProperty(\"z\", value.z);\n  target.writeProperty(\"w\", value.w);\n}\nfunction createConstraint$1(params, initialValue) {\n  return new PointNdConstraint({\n    assembly: Point4dAssembly,\n    components: [\n      createDimensionConstraint(Object.assign(Object.assign({}, params), params.x), initialValue.x),\n      createDimensionConstraint(Object.assign(Object.assign({}, params), params.y), initialValue.y),\n      createDimensionConstraint(Object.assign(Object.assign({}, params), params.z), initialValue.z),\n      createDimensionConstraint(Object.assign(Object.assign({}, params), params.w), initialValue.w)\n    ]\n  });\n}\nvar Point4dInputPlugin = createPlugin({\n  id: \"input-point4d\",\n  type: \"input\",\n  accept: (value, params) => {\n    if (!Point4d.isObject(value)) {\n      return null;\n    }\n    const result = parseRecord(params, (p) => Object.assign(Object.assign({}, createPointDimensionParser(p)), { readonly: p.optional.constant(false), w: p.optional.custom(parsePointDimensionParams), x: p.optional.custom(parsePointDimensionParams), y: p.optional.custom(parsePointDimensionParams), z: p.optional.custom(parsePointDimensionParams) }));\n    return result ? {\n      initialValue: value,\n      params: result\n    } : null;\n  },\n  binding: {\n    reader: (_args) => point4dFromUnknown,\n    constraint: (args) => createConstraint$1(args.params, args.initialValue),\n    equals: Point4d.equals,\n    writer: (_args) => writePoint4d\n  },\n  controller: (args) => {\n    const value = args.value;\n    const c = args.constraint;\n    const dParams = [\n      args.params.x,\n      args.params.y,\n      args.params.z,\n      args.params.w\n    ];\n    return new PointNdTextController(args.document, {\n      assembly: Point4dAssembly,\n      axes: value.rawValue.getComponents().map((comp, i) => {\n        var _a;\n        return createPointAxis({\n          constraint: c.components[i],\n          initialValue: comp,\n          params: deepMerge(args.params, (_a = dParams[i]) !== null && _a !== undefined ? _a : {})\n        });\n      }),\n      parser: parseNumber,\n      value,\n      viewProps: args.viewProps\n    });\n  }\n});\nfunction createConstraint(params) {\n  const constraints = [];\n  const lc = createListConstraint(params.options);\n  if (lc) {\n    constraints.push(lc);\n  }\n  return new CompositeConstraint(constraints);\n}\nvar StringInputPlugin = createPlugin({\n  id: \"input-string\",\n  type: \"input\",\n  accept: (value, params) => {\n    if (typeof value !== \"string\") {\n      return null;\n    }\n    const result = parseRecord(params, (p) => ({\n      readonly: p.optional.constant(false),\n      options: p.optional.custom(parseListOptions)\n    }));\n    return result ? {\n      initialValue: value,\n      params: result\n    } : null;\n  },\n  binding: {\n    reader: (_args) => stringFromUnknown,\n    constraint: (args) => createConstraint(args.params),\n    writer: (_args) => writePrimitive\n  },\n  controller: (args) => {\n    const doc = args.document;\n    const value = args.value;\n    const c = args.constraint;\n    const lc = c && findConstraint(c, ListConstraint);\n    if (lc) {\n      return new ListController(doc, {\n        props: new ValueMap({\n          options: lc.values.value(\"options\")\n        }),\n        value,\n        viewProps: args.viewProps\n      });\n    }\n    return new TextController(doc, {\n      parser: (v) => v,\n      props: ValueMap.fromObject({\n        formatter: formatString\n      }),\n      value,\n      viewProps: args.viewProps\n    });\n  },\n  api(args) {\n    if (typeof args.controller.value.rawValue !== \"string\") {\n      return null;\n    }\n    if (args.controller.valueController instanceof ListController) {\n      return new ListInputBindingApi(args.controller);\n    }\n    return null;\n  }\n});\nvar Constants = {\n  monitor: {\n    defaultInterval: 200,\n    defaultRows: 3\n  }\n};\nvar cn$3 = ClassName(\"mll\");\n\nclass MultiLogView {\n  constructor(doc, config) {\n    this.onValueUpdate_ = this.onValueUpdate_.bind(this);\n    this.formatter_ = config.formatter;\n    this.element = doc.createElement(\"div\");\n    this.element.classList.add(cn$3());\n    config.viewProps.bindClassModifiers(this.element);\n    const textareaElem = doc.createElement(\"textarea\");\n    textareaElem.classList.add(cn$3(\"i\"));\n    textareaElem.style.height = `calc(var(${getCssVar(\"containerUnitSize\")}) * ${config.rows})`;\n    textareaElem.readOnly = true;\n    config.viewProps.bindDisabled(textareaElem);\n    this.element.appendChild(textareaElem);\n    this.textareaElem_ = textareaElem;\n    config.value.emitter.on(\"change\", this.onValueUpdate_);\n    this.value = config.value;\n    this.update_();\n  }\n  update_() {\n    const elem = this.textareaElem_;\n    const shouldScroll = elem.scrollTop === elem.scrollHeight - elem.clientHeight;\n    const lines = [];\n    this.value.rawValue.forEach((value) => {\n      if (value !== undefined) {\n        lines.push(this.formatter_(value));\n      }\n    });\n    elem.textContent = lines.join(`\n`);\n    if (shouldScroll) {\n      elem.scrollTop = elem.scrollHeight;\n    }\n  }\n  onValueUpdate_() {\n    this.update_();\n  }\n}\n\nclass MultiLogController {\n  constructor(doc, config) {\n    this.value = config.value;\n    this.viewProps = config.viewProps;\n    this.view = new MultiLogView(doc, {\n      formatter: config.formatter,\n      rows: config.rows,\n      value: this.value,\n      viewProps: this.viewProps\n    });\n  }\n}\nvar cn$2 = ClassName(\"sgl\");\n\nclass SingleLogView {\n  constructor(doc, config) {\n    this.onValueUpdate_ = this.onValueUpdate_.bind(this);\n    this.formatter_ = config.formatter;\n    this.element = doc.createElement(\"div\");\n    this.element.classList.add(cn$2());\n    config.viewProps.bindClassModifiers(this.element);\n    const inputElem = doc.createElement(\"input\");\n    inputElem.classList.add(cn$2(\"i\"));\n    inputElem.readOnly = true;\n    inputElem.type = \"text\";\n    config.viewProps.bindDisabled(inputElem);\n    this.element.appendChild(inputElem);\n    this.inputElement = inputElem;\n    config.value.emitter.on(\"change\", this.onValueUpdate_);\n    this.value = config.value;\n    this.update_();\n  }\n  update_() {\n    const values = this.value.rawValue;\n    const lastValue = values[values.length - 1];\n    this.inputElement.value = lastValue !== undefined ? this.formatter_(lastValue) : \"\";\n  }\n  onValueUpdate_() {\n    this.update_();\n  }\n}\n\nclass SingleLogController {\n  constructor(doc, config) {\n    this.value = config.value;\n    this.viewProps = config.viewProps;\n    this.view = new SingleLogView(doc, {\n      formatter: config.formatter,\n      value: this.value,\n      viewProps: this.viewProps\n    });\n  }\n}\nvar BooleanMonitorPlugin = createPlugin({\n  id: \"monitor-bool\",\n  type: \"monitor\",\n  accept: (value, params) => {\n    if (typeof value !== \"boolean\") {\n      return null;\n    }\n    const result = parseRecord(params, (p) => ({\n      readonly: p.required.constant(true),\n      rows: p.optional.number\n    }));\n    return result ? {\n      initialValue: value,\n      params: result\n    } : null;\n  },\n  binding: {\n    reader: (_args) => boolFromUnknown\n  },\n  controller: (args) => {\n    var _a;\n    if (args.value.rawValue.length === 1) {\n      return new SingleLogController(args.document, {\n        formatter: BooleanFormatter,\n        value: args.value,\n        viewProps: args.viewProps\n      });\n    }\n    return new MultiLogController(args.document, {\n      formatter: BooleanFormatter,\n      rows: (_a = args.params.rows) !== null && _a !== undefined ? _a : Constants.monitor.defaultRows,\n      value: args.value,\n      viewProps: args.viewProps\n    });\n  }\n});\n\nclass GraphLogMonitorBindingApi extends BindingApi {\n  get max() {\n    return this.controller.valueController.props.get(\"max\");\n  }\n  set max(max) {\n    this.controller.valueController.props.set(\"max\", max);\n  }\n  get min() {\n    return this.controller.valueController.props.get(\"min\");\n  }\n  set min(min) {\n    this.controller.valueController.props.set(\"min\", min);\n  }\n}\nvar cn$1 = ClassName(\"grl\");\n\nclass GraphLogView {\n  constructor(doc, config) {\n    this.onCursorChange_ = this.onCursorChange_.bind(this);\n    this.onValueUpdate_ = this.onValueUpdate_.bind(this);\n    this.element = doc.createElement(\"div\");\n    this.element.classList.add(cn$1());\n    config.viewProps.bindClassModifiers(this.element);\n    this.formatter_ = config.formatter;\n    this.props_ = config.props;\n    this.cursor_ = config.cursor;\n    this.cursor_.emitter.on(\"change\", this.onCursorChange_);\n    const svgElem = doc.createElementNS(SVG_NS, \"svg\");\n    svgElem.classList.add(cn$1(\"g\"));\n    svgElem.style.height = `calc(var(${getCssVar(\"containerUnitSize\")}) * ${config.rows})`;\n    this.element.appendChild(svgElem);\n    this.svgElem_ = svgElem;\n    const lineElem = doc.createElementNS(SVG_NS, \"polyline\");\n    this.svgElem_.appendChild(lineElem);\n    this.lineElem_ = lineElem;\n    const tooltipElem = doc.createElement(\"div\");\n    tooltipElem.classList.add(cn$1(\"t\"), ClassName(\"tt\")());\n    this.element.appendChild(tooltipElem);\n    this.tooltipElem_ = tooltipElem;\n    config.value.emitter.on(\"change\", this.onValueUpdate_);\n    this.value = config.value;\n    this.update_();\n  }\n  get graphElement() {\n    return this.svgElem_;\n  }\n  update_() {\n    const { clientWidth: w, clientHeight: h } = this.element;\n    const maxIndex = this.value.rawValue.length - 1;\n    const min = this.props_.get(\"min\");\n    const max = this.props_.get(\"max\");\n    const points = [];\n    this.value.rawValue.forEach((v, index) => {\n      if (v === undefined) {\n        return;\n      }\n      const x = mapRange(index, 0, maxIndex, 0, w);\n      const y = mapRange(v, min, max, h, 0);\n      points.push([x, y].join(\",\"));\n    });\n    this.lineElem_.setAttributeNS(null, \"points\", points.join(\" \"));\n    const tooltipElem = this.tooltipElem_;\n    const value = this.value.rawValue[this.cursor_.rawValue];\n    if (value === undefined) {\n      tooltipElem.classList.remove(cn$1(\"t\", \"a\"));\n      return;\n    }\n    const tx = mapRange(this.cursor_.rawValue, 0, maxIndex, 0, w);\n    const ty = mapRange(value, min, max, h, 0);\n    tooltipElem.style.left = `${tx}px`;\n    tooltipElem.style.top = `${ty}px`;\n    tooltipElem.textContent = `${this.formatter_(value)}`;\n    if (!tooltipElem.classList.contains(cn$1(\"t\", \"a\"))) {\n      tooltipElem.classList.add(cn$1(\"t\", \"a\"), cn$1(\"t\", \"in\"));\n      forceReflow(tooltipElem);\n      tooltipElem.classList.remove(cn$1(\"t\", \"in\"));\n    }\n  }\n  onValueUpdate_() {\n    this.update_();\n  }\n  onCursorChange_() {\n    this.update_();\n  }\n}\n\nclass GraphLogController {\n  constructor(doc, config) {\n    this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this);\n    this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this);\n    this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this);\n    this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this);\n    this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this);\n    this.props = config.props;\n    this.value = config.value;\n    this.viewProps = config.viewProps;\n    this.cursor_ = createValue(-1);\n    this.view = new GraphLogView(doc, {\n      cursor: this.cursor_,\n      formatter: config.formatter,\n      rows: config.rows,\n      props: this.props,\n      value: this.value,\n      viewProps: this.viewProps\n    });\n    if (!supportsTouch(doc)) {\n      this.view.element.addEventListener(\"mousemove\", this.onGraphMouseMove_);\n      this.view.element.addEventListener(\"mouseleave\", this.onGraphMouseLeave_);\n    } else {\n      const ph = new PointerHandler(this.view.element);\n      ph.emitter.on(\"down\", this.onGraphPointerDown_);\n      ph.emitter.on(\"move\", this.onGraphPointerMove_);\n      ph.emitter.on(\"up\", this.onGraphPointerUp_);\n    }\n  }\n  importProps(state) {\n    return importBladeState(state, null, (p) => ({\n      max: p.required.number,\n      min: p.required.number\n    }), (result) => {\n      this.props.set(\"max\", result.max);\n      this.props.set(\"min\", result.min);\n      return true;\n    });\n  }\n  exportProps() {\n    return exportBladeState(null, {\n      max: this.props.get(\"max\"),\n      min: this.props.get(\"min\")\n    });\n  }\n  onGraphMouseLeave_() {\n    this.cursor_.rawValue = -1;\n  }\n  onGraphMouseMove_(ev) {\n    const { clientWidth: w } = this.view.element;\n    this.cursor_.rawValue = Math.floor(mapRange(ev.offsetX, 0, w, 0, this.value.rawValue.length));\n  }\n  onGraphPointerDown_(ev) {\n    this.onGraphPointerMove_(ev);\n  }\n  onGraphPointerMove_(ev) {\n    if (!ev.data.point) {\n      this.cursor_.rawValue = -1;\n      return;\n    }\n    this.cursor_.rawValue = Math.floor(mapRange(ev.data.point.x, 0, ev.data.bounds.width, 0, this.value.rawValue.length));\n  }\n  onGraphPointerUp_() {\n    this.cursor_.rawValue = -1;\n  }\n}\nfunction createFormatter(params) {\n  return !isEmpty(params.format) ? params.format : createNumberFormatter(2);\n}\nfunction createTextMonitor(args) {\n  var _a;\n  if (args.value.rawValue.length === 1) {\n    return new SingleLogController(args.document, {\n      formatter: createFormatter(args.params),\n      value: args.value,\n      viewProps: args.viewProps\n    });\n  }\n  return new MultiLogController(args.document, {\n    formatter: createFormatter(args.params),\n    rows: (_a = args.params.rows) !== null && _a !== undefined ? _a : Constants.monitor.defaultRows,\n    value: args.value,\n    viewProps: args.viewProps\n  });\n}\nfunction createGraphMonitor(args) {\n  var _a, _b, _c;\n  return new GraphLogController(args.document, {\n    formatter: createFormatter(args.params),\n    rows: (_a = args.params.rows) !== null && _a !== undefined ? _a : Constants.monitor.defaultRows,\n    props: ValueMap.fromObject({\n      max: (_b = args.params.max) !== null && _b !== undefined ? _b : 100,\n      min: (_c = args.params.min) !== null && _c !== undefined ? _c : 0\n    }),\n    value: args.value,\n    viewProps: args.viewProps\n  });\n}\nfunction shouldShowGraph(params) {\n  return params.view === \"graph\";\n}\nvar NumberMonitorPlugin = createPlugin({\n  id: \"monitor-number\",\n  type: \"monitor\",\n  accept: (value, params) => {\n    if (typeof value !== \"number\") {\n      return null;\n    }\n    const result = parseRecord(params, (p) => ({\n      format: p.optional.function,\n      max: p.optional.number,\n      min: p.optional.number,\n      readonly: p.required.constant(true),\n      rows: p.optional.number,\n      view: p.optional.string\n    }));\n    return result ? {\n      initialValue: value,\n      params: result\n    } : null;\n  },\n  binding: {\n    defaultBufferSize: (params) => shouldShowGraph(params) ? 64 : 1,\n    reader: (_args) => numberFromUnknown\n  },\n  controller: (args) => {\n    if (shouldShowGraph(args.params)) {\n      return createGraphMonitor(args);\n    }\n    return createTextMonitor(args);\n  },\n  api: (args) => {\n    if (args.controller.valueController instanceof GraphLogController) {\n      return new GraphLogMonitorBindingApi(args.controller);\n    }\n    return null;\n  }\n});\nvar StringMonitorPlugin = createPlugin({\n  id: \"monitor-string\",\n  type: \"monitor\",\n  accept: (value, params) => {\n    if (typeof value !== \"string\") {\n      return null;\n    }\n    const result = parseRecord(params, (p) => ({\n      multiline: p.optional.boolean,\n      readonly: p.required.constant(true),\n      rows: p.optional.number\n    }));\n    return result ? {\n      initialValue: value,\n      params: result\n    } : null;\n  },\n  binding: {\n    reader: (_args) => stringFromUnknown\n  },\n  controller: (args) => {\n    var _a;\n    const value = args.value;\n    const multiline = value.rawValue.length > 1 || args.params.multiline;\n    if (multiline) {\n      return new MultiLogController(args.document, {\n        formatter: formatString,\n        rows: (_a = args.params.rows) !== null && _a !== undefined ? _a : Constants.monitor.defaultRows,\n        value,\n        viewProps: args.viewProps\n      });\n    }\n    return new SingleLogController(args.document, {\n      formatter: formatString,\n      value,\n      viewProps: args.viewProps\n    });\n  }\n});\n\nclass BladeApiCache {\n  constructor() {\n    this.map_ = new Map;\n  }\n  get(bc) {\n    var _a;\n    return (_a = this.map_.get(bc)) !== null && _a !== undefined ? _a : null;\n  }\n  has(bc) {\n    return this.map_.has(bc);\n  }\n  add(bc, api) {\n    this.map_.set(bc, api);\n    bc.viewProps.handleDispose(() => {\n      this.map_.delete(bc);\n    });\n    return api;\n  }\n}\n\nclass ReadWriteBinding {\n  constructor(config) {\n    this.target = config.target;\n    this.reader_ = config.reader;\n    this.writer_ = config.writer;\n  }\n  read() {\n    return this.reader_(this.target.read());\n  }\n  write(value) {\n    this.writer_(this.target, value);\n  }\n  inject(value) {\n    this.write(this.reader_(value));\n  }\n}\nfunction createInputBindingController(plugin, args) {\n  var _a;\n  const result = plugin.accept(args.target.read(), args.params);\n  if (isEmpty(result)) {\n    return null;\n  }\n  const valueArgs = {\n    target: args.target,\n    initialValue: result.initialValue,\n    params: result.params\n  };\n  const params = parseRecord(args.params, (p) => ({\n    disabled: p.optional.boolean,\n    hidden: p.optional.boolean,\n    label: p.optional.string,\n    tag: p.optional.string\n  }));\n  const reader = plugin.binding.reader(valueArgs);\n  const constraint = plugin.binding.constraint ? plugin.binding.constraint(valueArgs) : undefined;\n  const binding = new ReadWriteBinding({\n    reader,\n    target: args.target,\n    writer: plugin.binding.writer(valueArgs)\n  });\n  const value = new InputBindingValue(createValue(reader(result.initialValue), {\n    constraint,\n    equals: plugin.binding.equals\n  }), binding);\n  const controller = plugin.controller({\n    constraint,\n    document: args.document,\n    initialValue: result.initialValue,\n    params: result.params,\n    value,\n    viewProps: ViewProps.create({\n      disabled: params === null || params === undefined ? undefined : params.disabled,\n      hidden: params === null || params === undefined ? undefined : params.hidden\n    })\n  });\n  return new InputBindingController(args.document, {\n    blade: createBlade(),\n    props: ValueMap.fromObject({\n      label: \"label\" in args.params ? (_a = params === null || params === undefined ? undefined : params.label) !== null && _a !== undefined ? _a : null : args.target.key\n    }),\n    tag: params === null || params === undefined ? undefined : params.tag,\n    value,\n    valueController: controller\n  });\n}\n\nclass ReadonlyBinding {\n  constructor(config) {\n    this.target = config.target;\n    this.reader_ = config.reader;\n  }\n  read() {\n    return this.reader_(this.target.read());\n  }\n}\nfunction createTicker(document2, interval) {\n  return interval === 0 ? new ManualTicker : new IntervalTicker(document2, interval !== null && interval !== undefined ? interval : Constants.monitor.defaultInterval);\n}\nfunction createMonitorBindingController(plugin, args) {\n  var _a, _b, _c;\n  const result = plugin.accept(args.target.read(), args.params);\n  if (isEmpty(result)) {\n    return null;\n  }\n  const bindingArgs = {\n    target: args.target,\n    initialValue: result.initialValue,\n    params: result.params\n  };\n  const params = parseRecord(args.params, (p) => ({\n    bufferSize: p.optional.number,\n    disabled: p.optional.boolean,\n    hidden: p.optional.boolean,\n    interval: p.optional.number,\n    label: p.optional.string\n  }));\n  const reader = plugin.binding.reader(bindingArgs);\n  const bufferSize = (_b = (_a = params === null || params === undefined ? undefined : params.bufferSize) !== null && _a !== undefined ? _a : plugin.binding.defaultBufferSize && plugin.binding.defaultBufferSize(result.params)) !== null && _b !== undefined ? _b : 1;\n  const value = new MonitorBindingValue({\n    binding: new ReadonlyBinding({\n      reader,\n      target: args.target\n    }),\n    bufferSize,\n    ticker: createTicker(args.document, params === null || params === undefined ? undefined : params.interval)\n  });\n  const controller = plugin.controller({\n    document: args.document,\n    params: result.params,\n    value,\n    viewProps: ViewProps.create({\n      disabled: params === null || params === undefined ? undefined : params.disabled,\n      hidden: params === null || params === undefined ? undefined : params.hidden\n    })\n  });\n  controller.viewProps.bindDisabled(value.ticker);\n  controller.viewProps.handleDispose(() => {\n    value.ticker.dispose();\n  });\n  return new MonitorBindingController(args.document, {\n    blade: createBlade(),\n    props: ValueMap.fromObject({\n      label: \"label\" in args.params ? (_c = params === null || params === undefined ? undefined : params.label) !== null && _c !== undefined ? _c : null : args.target.key\n    }),\n    value,\n    valueController: controller\n  });\n}\n\nclass PluginPool {\n  constructor(apiCache) {\n    this.pluginsMap_ = {\n      blades: [],\n      inputs: [],\n      monitors: []\n    };\n    this.apiCache_ = apiCache;\n  }\n  getAll() {\n    return [\n      ...this.pluginsMap_.blades,\n      ...this.pluginsMap_.inputs,\n      ...this.pluginsMap_.monitors\n    ];\n  }\n  register(bundleId, r) {\n    if (!isCompatible(r.core)) {\n      throw TpError.notCompatible(bundleId, r.id);\n    }\n    if (r.type === \"blade\") {\n      this.pluginsMap_.blades.unshift(r);\n    } else if (r.type === \"input\") {\n      this.pluginsMap_.inputs.unshift(r);\n    } else if (r.type === \"monitor\") {\n      this.pluginsMap_.monitors.unshift(r);\n    }\n  }\n  createInput_(document2, target, params) {\n    return this.pluginsMap_.inputs.reduce((result, plugin) => result !== null && result !== undefined ? result : createInputBindingController(plugin, {\n      document: document2,\n      target,\n      params\n    }), null);\n  }\n  createMonitor_(document2, target, params) {\n    return this.pluginsMap_.monitors.reduce((result, plugin) => result !== null && result !== undefined ? result : createMonitorBindingController(plugin, {\n      document: document2,\n      params,\n      target\n    }), null);\n  }\n  createBinding(doc, target, params) {\n    const initialValue = target.read();\n    if (isEmpty(initialValue)) {\n      throw new TpError({\n        context: {\n          key: target.key\n        },\n        type: \"nomatchingcontroller\"\n      });\n    }\n    const ic = this.createInput_(doc, target, params);\n    if (ic) {\n      return ic;\n    }\n    const mc = this.createMonitor_(doc, target, params);\n    if (mc) {\n      return mc;\n    }\n    throw new TpError({\n      context: {\n        key: target.key\n      },\n      type: \"nomatchingcontroller\"\n    });\n  }\n  createBlade(document2, params) {\n    const bc = this.pluginsMap_.blades.reduce((result, plugin) => result !== null && result !== undefined ? result : createBladeController(plugin, {\n      document: document2,\n      params\n    }), null);\n    if (!bc) {\n      throw new TpError({\n        type: \"nomatchingview\",\n        context: {\n          params\n        }\n      });\n    }\n    return bc;\n  }\n  createInputBindingApi_(bc) {\n    const api = this.pluginsMap_.inputs.reduce((result, plugin) => {\n      var _a, _b;\n      if (result) {\n        return result;\n      }\n      return (_b = (_a = plugin.api) === null || _a === undefined ? undefined : _a.call(plugin, {\n        controller: bc\n      })) !== null && _b !== undefined ? _b : null;\n    }, null);\n    return this.apiCache_.add(bc, api !== null && api !== undefined ? api : new BindingApi(bc));\n  }\n  createMonitorBindingApi_(bc) {\n    const api = this.pluginsMap_.monitors.reduce((result, plugin) => {\n      var _a, _b;\n      if (result) {\n        return result;\n      }\n      return (_b = (_a = plugin.api) === null || _a === undefined ? undefined : _a.call(plugin, {\n        controller: bc\n      })) !== null && _b !== undefined ? _b : null;\n    }, null);\n    return this.apiCache_.add(bc, api !== null && api !== undefined ? api : new BindingApi(bc));\n  }\n  createBindingApi(bc) {\n    if (this.apiCache_.has(bc)) {\n      return this.apiCache_.get(bc);\n    }\n    if (isInputBindingController(bc)) {\n      return this.createInputBindingApi_(bc);\n    }\n    if (isMonitorBindingController(bc)) {\n      return this.createMonitorBindingApi_(bc);\n    }\n    throw TpError.shouldNeverHappen();\n  }\n  createApi(bc) {\n    if (this.apiCache_.has(bc)) {\n      return this.apiCache_.get(bc);\n    }\n    if (isBindingController(bc)) {\n      return this.createBindingApi(bc);\n    }\n    const api = this.pluginsMap_.blades.reduce((result, plugin) => result !== null && result !== undefined ? result : plugin.api({\n      controller: bc,\n      pool: this\n    }), null);\n    if (!api) {\n      throw TpError.shouldNeverHappen();\n    }\n    return this.apiCache_.add(bc, api);\n  }\n}\nvar sharedCache = new BladeApiCache;\nfunction createDefaultPluginPool() {\n  const pool = new PluginPool(sharedCache);\n  [\n    Point2dInputPlugin,\n    Point3dInputPlugin,\n    Point4dInputPlugin,\n    StringInputPlugin,\n    NumberInputPlugin,\n    StringColorInputPlugin,\n    ObjectColorInputPlugin,\n    NumberColorInputPlugin,\n    BooleanInputPlugin,\n    BooleanMonitorPlugin,\n    StringMonitorPlugin,\n    NumberMonitorPlugin,\n    ButtonBladePlugin,\n    FolderBladePlugin,\n    TabBladePlugin\n  ].forEach((p) => {\n    pool.register(\"core\", p);\n  });\n  return pool;\n}\n\nclass ListBladeApi extends BladeApi {\n  constructor(controller) {\n    super(controller);\n    this.emitter_ = new Emitter;\n    this.controller.value.emitter.on(\"change\", (ev) => {\n      this.emitter_.emit(\"change\", new TpChangeEvent(this, ev.rawValue));\n    });\n  }\n  get label() {\n    return this.controller.labelController.props.get(\"label\");\n  }\n  set label(label) {\n    this.controller.labelController.props.set(\"label\", label);\n  }\n  get options() {\n    return this.controller.valueController.props.get(\"options\");\n  }\n  set options(options) {\n    this.controller.valueController.props.set(\"options\", options);\n  }\n  get value() {\n    return this.controller.value.rawValue;\n  }\n  set value(value) {\n    this.controller.value.rawValue = value;\n  }\n  on(eventName, handler) {\n    const bh = handler.bind(this);\n    this.emitter_.on(eventName, (ev) => {\n      bh(ev);\n    }, {\n      key: handler\n    });\n    return this;\n  }\n  off(eventName, handler) {\n    this.emitter_.off(eventName, handler);\n    return this;\n  }\n}\n\nclass SeparatorBladeApi extends BladeApi {\n}\n\nclass SliderBladeApi extends BladeApi {\n  constructor(controller) {\n    super(controller);\n    this.emitter_ = new Emitter;\n    this.controller.value.emitter.on(\"change\", (ev) => {\n      this.emitter_.emit(\"change\", new TpChangeEvent(this, ev.rawValue));\n    });\n  }\n  get label() {\n    return this.controller.labelController.props.get(\"label\");\n  }\n  set label(label) {\n    this.controller.labelController.props.set(\"label\", label);\n  }\n  get max() {\n    return this.controller.valueController.sliderController.props.get(\"max\");\n  }\n  set max(max) {\n    this.controller.valueController.sliderController.props.set(\"max\", max);\n  }\n  get min() {\n    return this.controller.valueController.sliderController.props.get(\"min\");\n  }\n  set min(min) {\n    this.controller.valueController.sliderController.props.set(\"min\", min);\n  }\n  get value() {\n    return this.controller.value.rawValue;\n  }\n  set value(value) {\n    this.controller.value.rawValue = value;\n  }\n  on(eventName, handler) {\n    const bh = handler.bind(this);\n    this.emitter_.on(eventName, (ev) => {\n      bh(ev);\n    }, {\n      key: handler\n    });\n    return this;\n  }\n  off(eventName, handler) {\n    this.emitter_.off(eventName, handler);\n    return this;\n  }\n}\n\nclass TextBladeApi extends BladeApi {\n  constructor(controller) {\n    super(controller);\n    this.emitter_ = new Emitter;\n    this.controller.value.emitter.on(\"change\", (ev) => {\n      this.emitter_.emit(\"change\", new TpChangeEvent(this, ev.rawValue));\n    });\n  }\n  get label() {\n    return this.controller.labelController.props.get(\"label\");\n  }\n  set label(label) {\n    this.controller.labelController.props.set(\"label\", label);\n  }\n  get formatter() {\n    return this.controller.valueController.props.get(\"formatter\");\n  }\n  set formatter(formatter) {\n    this.controller.valueController.props.set(\"formatter\", formatter);\n  }\n  get value() {\n    return this.controller.value.rawValue;\n  }\n  set value(value) {\n    this.controller.value.rawValue = value;\n  }\n  on(eventName, handler) {\n    const bh = handler.bind(this);\n    this.emitter_.on(eventName, (ev) => {\n      bh(ev);\n    }, {\n      key: handler\n    });\n    return this;\n  }\n  off(eventName, handler) {\n    this.emitter_.off(eventName, handler);\n    return this;\n  }\n}\nvar ListBladePlugin = function() {\n  return {\n    id: \"list\",\n    type: \"blade\",\n    core: VERSION$1,\n    accept(params) {\n      const result = parseRecord(params, (p) => ({\n        options: p.required.custom(parseListOptions),\n        value: p.required.raw,\n        view: p.required.constant(\"list\"),\n        label: p.optional.string\n      }));\n      return result ? { params: result } : null;\n    },\n    controller(args) {\n      const lc = new ListConstraint(normalizeListOptions(args.params.options));\n      const value = createValue(args.params.value, {\n        constraint: lc\n      });\n      const ic = new ListController(args.document, {\n        props: new ValueMap({\n          options: lc.values.value(\"options\")\n        }),\n        value,\n        viewProps: args.viewProps\n      });\n      return new LabeledValueBladeController(args.document, {\n        blade: args.blade,\n        props: ValueMap.fromObject({\n          label: args.params.label\n        }),\n        value,\n        valueController: ic\n      });\n    },\n    api(args) {\n      if (!(args.controller instanceof LabeledValueBladeController)) {\n        return null;\n      }\n      if (!(args.controller.valueController instanceof ListController)) {\n        return null;\n      }\n      return new ListBladeApi(args.controller);\n    }\n  };\n}();\n\nclass RootApi extends FolderApi {\n  constructor(controller, pool) {\n    super(controller, pool);\n  }\n  get element() {\n    return this.controller.view.element;\n  }\n}\n\nclass RootController extends FolderController {\n  constructor(doc, config) {\n    super(doc, {\n      expanded: config.expanded,\n      blade: config.blade,\n      props: config.props,\n      root: true,\n      viewProps: config.viewProps\n    });\n  }\n}\nvar cn = ClassName(\"spr\");\n\nclass SeparatorView {\n  constructor(doc, config) {\n    this.element = doc.createElement(\"div\");\n    this.element.classList.add(cn());\n    config.viewProps.bindClassModifiers(this.element);\n    const hrElem = doc.createElement(\"hr\");\n    hrElem.classList.add(cn(\"r\"));\n    this.element.appendChild(hrElem);\n  }\n}\n\nclass SeparatorController extends BladeController {\n  constructor(doc, config) {\n    super(Object.assign(Object.assign({}, config), { view: new SeparatorView(doc, {\n      viewProps: config.viewProps\n    }) }));\n  }\n}\nvar SeparatorBladePlugin = {\n  id: \"separator\",\n  type: \"blade\",\n  core: VERSION$1,\n  accept(params) {\n    const result = parseRecord(params, (p) => ({\n      view: p.required.constant(\"separator\")\n    }));\n    return result ? { params: result } : null;\n  },\n  controller(args) {\n    return new SeparatorController(args.document, {\n      blade: args.blade,\n      viewProps: args.viewProps\n    });\n  },\n  api(args) {\n    if (!(args.controller instanceof SeparatorController)) {\n      return null;\n    }\n    return new SeparatorBladeApi(args.controller);\n  }\n};\nvar SliderBladePlugin = {\n  id: \"slider\",\n  type: \"blade\",\n  core: VERSION$1,\n  accept(params) {\n    const result = parseRecord(params, (p) => ({\n      max: p.required.number,\n      min: p.required.number,\n      view: p.required.constant(\"slider\"),\n      format: p.optional.function,\n      label: p.optional.string,\n      value: p.optional.number\n    }));\n    return result ? { params: result } : null;\n  },\n  controller(args) {\n    var _a, _b;\n    const initialValue = (_a = args.params.value) !== null && _a !== undefined ? _a : 0;\n    const drc = new DefiniteRangeConstraint({\n      max: args.params.max,\n      min: args.params.min\n    });\n    const v = createValue(initialValue, {\n      constraint: drc\n    });\n    const vc = new SliderTextController(args.document, Object.assign(Object.assign({}, createSliderTextProps({\n      formatter: (_b = args.params.format) !== null && _b !== undefined ? _b : numberToString,\n      keyScale: createValue(1),\n      max: drc.values.value(\"max\"),\n      min: drc.values.value(\"min\"),\n      pointerScale: getSuitablePointerScale(args.params, initialValue)\n    })), { parser: parseNumber, value: v, viewProps: args.viewProps }));\n    return new LabeledValueBladeController(args.document, {\n      blade: args.blade,\n      props: ValueMap.fromObject({\n        label: args.params.label\n      }),\n      value: v,\n      valueController: vc\n    });\n  },\n  api(args) {\n    if (!(args.controller instanceof LabeledValueBladeController)) {\n      return null;\n    }\n    if (!(args.controller.valueController instanceof SliderTextController)) {\n      return null;\n    }\n    return new SliderBladeApi(args.controller);\n  }\n};\nvar TextBladePlugin = function() {\n  return {\n    id: \"text\",\n    type: \"blade\",\n    core: VERSION$1,\n    accept(params) {\n      const result = parseRecord(params, (p) => ({\n        parse: p.required.function,\n        value: p.required.raw,\n        view: p.required.constant(\"text\"),\n        format: p.optional.function,\n        label: p.optional.string\n      }));\n      return result ? { params: result } : null;\n    },\n    controller(args) {\n      var _a;\n      const v = createValue(args.params.value);\n      const ic = new TextController(args.document, {\n        parser: args.params.parse,\n        props: ValueMap.fromObject({\n          formatter: (_a = args.params.format) !== null && _a !== undefined ? _a : (v2) => String(v2)\n        }),\n        value: v,\n        viewProps: args.viewProps\n      });\n      return new LabeledValueBladeController(args.document, {\n        blade: args.blade,\n        props: ValueMap.fromObject({\n          label: args.params.label\n        }),\n        value: v,\n        valueController: ic\n      });\n    },\n    api(args) {\n      if (!(args.controller instanceof LabeledValueBladeController)) {\n        return null;\n      }\n      if (!(args.controller.valueController instanceof TextController)) {\n        return null;\n      }\n      return new TextBladeApi(args.controller);\n    }\n  };\n}();\nfunction createDefaultWrapperElement(doc) {\n  const elem = doc.createElement(\"div\");\n  elem.classList.add(ClassName(\"dfw\")());\n  if (doc.body) {\n    doc.body.appendChild(elem);\n  }\n  return elem;\n}\nfunction embedStyle(doc, id, css) {\n  if (doc.querySelector(`style[data-tp-style=${id}]`)) {\n    return;\n  }\n  const styleElem = doc.createElement(\"style\");\n  styleElem.dataset.tpStyle = id;\n  styleElem.textContent = css;\n  doc.head.appendChild(styleElem);\n}\n\nclass Pane extends RootApi {\n  constructor(opt_config) {\n    var _a, _b;\n    const config = opt_config !== null && opt_config !== undefined ? opt_config : {};\n    const doc = (_a = config.document) !== null && _a !== undefined ? _a : getWindowDocument();\n    const pool = createDefaultPluginPool();\n    const rootController = new RootController(doc, {\n      expanded: config.expanded,\n      blade: createBlade(),\n      props: ValueMap.fromObject({\n        title: config.title\n      }),\n      viewProps: ViewProps.create()\n    });\n    super(rootController, pool);\n    this.pool_ = pool;\n    this.containerElem_ = (_b = config.container) !== null && _b !== undefined ? _b : createDefaultWrapperElement(doc);\n    this.containerElem_.appendChild(this.element);\n    this.doc_ = doc;\n    this.usesDefaultWrapper_ = !config.container;\n    this.setUpDefaultPlugins_();\n  }\n  get document() {\n    if (!this.doc_) {\n      throw TpError.alreadyDisposed();\n    }\n    return this.doc_;\n  }\n  dispose() {\n    const containerElem = this.containerElem_;\n    if (!containerElem) {\n      throw TpError.alreadyDisposed();\n    }\n    if (this.usesDefaultWrapper_) {\n      const parentElem = containerElem.parentElement;\n      if (parentElem) {\n        parentElem.removeChild(containerElem);\n      }\n    }\n    this.containerElem_ = null;\n    this.doc_ = null;\n    super.dispose();\n  }\n  registerPlugin(bundle) {\n    if (bundle.css) {\n      embedStyle(this.document, `plugin-${bundle.id}`, bundle.css);\n    }\n    const plugins = \"plugin\" in bundle ? [bundle.plugin] : (\"plugins\" in bundle) ? bundle.plugins : [];\n    plugins.forEach((p) => {\n      this.pool_.register(bundle.id, p);\n    });\n  }\n  setUpDefaultPlugins_() {\n    this.registerPlugin({\n      id: \"default\",\n      css: \".tp-tbiv_b,.tp-coltxtv_ms,.tp-colswv_b,.tp-ckbv_i,.tp-sglv_i,.tp-mllv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-rotv_b,.tp-fldv_b,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--bld-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--cnt-usz);line-height:var(--cnt-usz);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tbpv_c>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-vp))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tbpv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tbpv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tbpv_c>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--cnt-usp)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tbpv_c>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tbpv_c>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-vp)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tbpv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tbpv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-vp)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tbpv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tbpv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tbpv_c>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tbpv_c>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--bld-br);border-bottom-left-radius:var(--bld-br)}.tp-tbpv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tbpv_c .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--bld-br)}.tp-tbpv_c>.tp-cntv+.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-cntv+.tp-fldv>.tp-fldv_b{border-top-left-radius:0}.tp-tbpv_c>.tp-cntv+.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-cntv+.tp-tabv>.tp-tabv_t{border-top-left-radius:0}.tp-tbpv_c>.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-tabv>.tp-tabv_t{border-top-left-radius:var(--bld-br)}.tp-tbpv_c .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--bld-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--cnt-usz) + 4px);line-height:calc(var(--cnt-usz) + 4px);overflow:hidden;padding-left:var(--cnt-hp);padding-right:calc(4px + var(--cnt-usz) + var(--cnt-hp));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:\\\"\\\";display:block;height:6px;right:calc(var(--cnt-hp) + (var(--cnt-usz) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-vp);padding-top:var(--cnt-vp);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--bld-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--cnt-usz);line-height:var(--cnt-usz);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-sglv_i,.tp-mllv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--bld-br);box-sizing:border-box;color:var(--mo-fg);height:var(--cnt-usz);scrollbar-color:currentColor rgba(0,0,0,0);scrollbar-width:thin;width:100%}.tp-sglv_i::-webkit-scrollbar,.tp-mllv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-sglv_i::-webkit-scrollbar-corner,.tp-mllv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:rgba(0,0,0,0)}.tp-sglv_i::-webkit-scrollbar-thumb,.tp-mllv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:rgba(0,0,0,0) solid 2px;border-radius:4px}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-rotv{--bs-bg: var(--tp-base-background-color, hsl(230, 7%, 17%));--bs-br: var(--tp-base-border-radius, 6px);--bs-ff: var(--tp-base-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--bld-br: var(--tp-blade-border-radius, 2px);--bld-hp: var(--tp-blade-horizontal-padding, 4px);--bld-vw: var(--tp-blade-value-width, 160px);--btn-bg: var(--tp-button-background-color, hsl(230, 7%, 70%));--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, hsl(230, 7%, 17%));--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, hsl(230, 7%, 75%));--cnt-hp: var(--tp-container-horizontal-padding, 4px);--cnt-vp: var(--tp-container-vertical-padding, 4px);--cnt-usp: var(--tp-container-unit-spacing, 4px);--cnt-usz: var(--tp-container-unit-size, 20px);--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, hsl(230, 7%, 75%));--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--bld-br);cursor:pointer;display:block;height:var(--cnt-usz);position:relative;width:var(--cnt-usz)}.tp-ckbv_w svg{display:block;height:16px;inset:0;margin:auto;opacity:0;position:absolute;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--cnt-usz)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-expanded.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--cnt-usp);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-hp));right:calc(-1*var(--cnt-hp));top:var(--cnt-usz)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--cnt-usp)}.tp-colpv_rgb{display:flex;margin-top:var(--cnt-usp);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-vp);padding-top:calc(var(--cnt-vp) + 2px);position:relative}.tp-colpv_a::before{background-color:var(--grv-fg);content:\\\"\\\";height:2px;left:calc(-1*var(--cnt-hp));position:absolute;right:calc(-1*var(--cnt-hp));top:0}.tp-colpv.tp-v-disabled .tp-colpv_a::before{opacity:.5}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--bld-br);outline:none;overflow:hidden;position:relative}.tp-svpv.tp-v-disabled{opacity:.5}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--cnt-usz)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--cnt-usz);outline:none;position:relative}.tp-hplv.tp-v-disabled{opacity:.5}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--bld-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--cnt-usz);outline:none;position:relative;width:100%}.tp-aplv.tp-v-disabled{opacity:.5}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{inset:0;position:absolute}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--bld-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--bld-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;inset:0;position:absolute}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--bld-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{cursor:pointer;display:block;height:var(--cnt-usz);left:0;position:absolute;top:0;width:var(--cnt-usz)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--bld-br);content:\\\"\\\";display:block;inset:0;position:absolute}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--bld-br);color:var(--lbl-fg);cursor:pointer;height:var(--cnt-usz);line-height:var(--cnt-usz);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv.tp-v-disabled .tp-coltxtv_mm{opacity:.5}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv{position:relative}.tp-fldv_t{padding-left:4px}.tp-fldv_b:disabled .tp-fldv_m{display:none}.tp-fldv_c{padding-left:4px}.tp-fldv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--cnt-usz) + 4px);width:max(var(--bs-br),4px)}.tp-fldv_i::before{background-color:currentColor;bottom:0;content:\\\"\\\";left:0;position:absolute;top:0;width:4px}.tp-fldv_b:hover+.tp-fldv_i{color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_i{color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_i{color:var(--cnt-bg-a)}.tp-fldv.tp-v-disabled>.tp-fldv_i{opacity:.5}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--cnt-usz)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-hp);padding-right:var(--cnt-hp)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:var(--bld-vw)}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 var(--bld-hp);width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding-left:var(--bld-hp);padding-right:var(--bld-hp)}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--cnt-usz)*3);line-height:var(--cnt-usz);padding-left:var(--bld-hp);padding-right:var(--bld-hp);resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--cnt-usz);margin-right:4px;position:relative;width:var(--cnt-usz)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--cnt-usp);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-hp));right:calc(-1*var(--cnt-hp));top:var(--cnt-usz)}.tp-p2dpv{padding-left:calc(var(--cnt-usz) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv.tp-v-disabled .tp-p2dpv_p{opacity:.5}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:var(--bld-vw);padding:var(--cnt-vp) var(--cnt-hp);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--cnt-usz);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;content:\\\"\\\";display:block;height:2px;inset:0;margin:auto;position:absolute}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;content:\\\"\\\";display:block;height:2px;inset:0;margin-bottom:auto;margin-top:auto;position:absolute}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--bld-br);bottom:0;content:\\\"\\\";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv{position:relative}.tp-tabv_t{align-items:flex-end;color:var(--cnt-bg);display:flex;overflow:hidden;position:relative}.tp-tabv_t:hover{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus){color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active){color:var(--cnt-bg-a)}.tp-tabv_t::before{background-color:currentColor;bottom:0;content:\\\"\\\";height:2px;left:0;pointer-events:none;position:absolute;right:0}.tp-tabv.tp-v-disabled .tp-tabv_t::before{opacity:.5}.tp-tabv.tp-tabv-nop .tp-tabv_t{height:calc(var(--cnt-usz) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_t::before{background-color:var(--cnt-bg);bottom:0;content:\\\"\\\";height:2px;left:0;position:absolute;right:0}.tp-tabv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--cnt-usz) + 4px);width:max(var(--bs-br),4px)}.tp-tabv_i::before{background-color:currentColor;bottom:0;content:\\\"\\\";left:0;position:absolute;top:0;width:4px}.tp-tabv_t:hover+.tp-tabv_i{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus)+.tp-tabv_i{color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active)+.tp-tabv_i{color:var(--cnt-bg-a)}.tp-tabv.tp-v-disabled>.tp-tabv_i{opacity:.5}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv.tp-v-disabled::before{opacity:.5}.tp-tbiv_b{display:block;padding-left:calc(var(--cnt-hp) + 4px);padding-right:calc(var(--cnt-hp) + 4px);position:relative;width:100%}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_b::before{background-color:var(--cnt-bg);content:\\\"\\\";inset:0 0 2px;pointer-events:none;position:absolute}.tp-tbiv_b:hover::before{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus::before{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active::before{background-color:var(--cnt-bg-a)}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--cnt-usz) + 4px);line-height:calc(var(--cnt-usz) + 4px);opacity:.5;overflow:hidden;position:relative;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-tbpv_c{padding-bottom:var(--cnt-vp);padding-left:4px;padding-top:var(--cnt-vp)}.tp-txtv{position:relative}.tp-txtv_i{padding-left:var(--bld-hp);padding-right:var(--bld-hp)}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:calc(var(--bld-hp) - 5px);position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:\\\"\\\";height:calc(var(--cnt-usz) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--bld-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) rgba(0,0,0,0) rgba(0,0,0,0) rgba(0,0,0,0);border-style:solid;border-width:2px;box-sizing:border-box;content:\\\"\\\";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--bs-ff);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--cnt-usz) + var(--cnt-hp));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0;transition-delay:0s;transition-duration:0s}.tp-rotv.tp-rotv-not>.tp-rotv_b{display:none}.tp-rotv_b:disabled .tp-rotv_m{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst.tp-fldv-expanded>.tp-fldv_b{transition-delay:0s;transition-duration:0s}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-vp))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-vp))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_t{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sprv.tp-v-disabled .tp-sprv_r{opacity:.5}\",\n      plugins: [\n        ListBladePlugin,\n        SeparatorBladePlugin,\n        SliderBladePlugin,\n        TabBladePlugin,\n        TextBladePlugin\n      ]\n    });\n  }\n}\nvar VERSION = new Semver(\"4.0.5\");\n\n// src/controls/theme.ts\nvar studioTheme = {\n  cssVariables: {\n    \"--bg\": \"#0a0e14\",\n    \"--bg-elevated\": \"#0f1419\",\n    \"--muted\": \"#1a2332\",\n    \"--text\": \"#e6edf3\",\n    \"--text-secondary\": \"#8b949e\",\n    \"--accent\": \"#58d5ff\",\n    \"--accent-2\": \"#42a5cc\",\n    \"--border\": \"#21262d\",\n    \"--border-hover\": \"#30363d\",\n    \"--success\": \"#3fb950\",\n    \"--error\": \"#f85149\",\n    \"--ht-text-color-main-200\": \"#00ffd4\",\n    \"--ht-text-color-main-300\": \"#6ff3dd\",\n    \"--ht-text-color-main-500\": \"#4b8e85\",\n    \"--ht-text-color-grey-200\": \"#8c8d8f\",\n    \"--ht-bg-color-200\": \"#8c8d8f\",\n    \"--ht-bg-color-200-active\": \"#7a7b7d\",\n    \"--ht-bg-color-200-focus\": \"#7e7f81\",\n    \"--ht-bg-color-200-hover\": \"#828384\",\n    \"--ht-bg-color-300\": \"#5e6068\",\n    \"--ht-bg-color-300-active\": \"#4c4e56\",\n    \"--ht-bg-color-300-focus\": \"#55575f\",\n    \"--ht-bg-color-300-hover\": \"#595b63\",\n    \"--ht-bg-color-400\": \"#cccccc\",\n    \"--ht-bg-color-400-active\": \"#b3b3b3\",\n    \"--ht-bg-color-400-focus\": \"#c0c0c0\",\n    \"--ht-bg-color-400-hover\": \"#c6c6c6\",\n    \"--ht-bg-color-500\": \"#1C1D20\",\n    \"--ht-bg-color-500-active\": \"#0a0b0e\",\n    \"--ht-bg-color-500-focus\": \"#131417\",\n    \"--ht-bg-color-500-hover\": \"#16171a\",\n    \"--ht-bg-color-600\": \"#37383D\",\n    \"--ht-bg-color-600-active\": \"#25262b\",\n    \"--ht-bg-color-600-focus\": \"#2e2f34\",\n    \"--ht-bg-color-600-hover\": \"#323338\",\n    \"--ht-bg-color-700\": \"#0f1419\",\n    \"--ht-bg-color-700-active\": \"#16171c\",\n    \"--ht-bg-color-700-focus\": \"#1f2025\",\n    \"--ht-bg-color-700-hover\": \"#232429\",\n    \"--ht-border-radius\": \"8px\",\n    \"--ht-base-font-family-base\": '\"HydrogenType400\", ui-sans-serif, system-ui, sans-serif',\n    \"--ht-base-font-family-display\": '\"Departure Mono\", Roboto Mono, Source Code Pro, Menlo, Courier, monospace',\n    \"--ht-base-font-family-sans\": '\"Routed Gothic\", ui-sans-serif, system-ui, sans-serif',\n    \"--ht-base-font-family-mono\": '\"Routed Gothic Narrow\", ui-monospace, SFMono-Regular, SF Mono, Consolas, Liberation Mono, Menlo, monospace'\n  },\n  tweakpane: {\n    \"--tp-base-background-color\": \"var(--ht-bg-color-700)\",\n    \"--tp-base-shadow-color\": \"hsla(0, 0%, 0%, 0.2)\",\n    \"--tp-container-background-color\": \"var(--ht-bg-color-600)\",\n    \"--tp-container-background-color-active\": \"var(--ht-bg-color-600-active)\",\n    \"--tp-container-background-color-focus\": \"var(--ht-bg-color-600-focus)\",\n    \"--tp-container-background-color-hover\": \"var(--ht-bg-color-600-hover)\",\n    \"--tp-container-foreground-color\": \"var(--ht-text-color-main-300)\",\n    \"--tp-button-background-color\": \"var(--ht-bg-color-400)\",\n    \"--tp-button-background-color-active\": \"color-mix(in srgb, var(--ht-bg-color-400-active) 80%, white)\",\n    \"--tp-button-background-color-focus\": \"color-mix(in srgb, var(--ht-bg-color-400-focus) 85%, white)\",\n    \"--tp-button-background-color-hover\": \"color-mix(in srgb, var(--ht-bg-color-400-hover) 90%, white)\",\n    \"--tp-button-foreground-color\": \"var(--ht-text-color-main-300)\",\n    \"--tp-groove-foreground-color\": \"var(--ht-bg-color-300)\",\n    \"--tp-input-background-color\": \"var(--ht-bg-color-500)\",\n    \"--tp-input-background-color-active\": \"var(--ht-bg-color-500-active)\",\n    \"--tp-input-background-color-focus\": \"var(--ht-bg-color-500-focus)\",\n    \"--tp-input-background-color-hover\": \"var(--ht-bg-color-500-hover)\",\n    \"--tp-input-foreground-color\": \"var(--ht-text-color-main-300)\",\n    \"--tp-label-foreground-color\": \"var(--ht-text-color-main-300)\",\n    \"--tp-monitor-background-color\": \"var(--ht-bg-color-500)\",\n    \"--tp-monitor-foreground-color\": \"var(--ht-text-color-main-300)\"\n  }\n};\nfunction injectThemeVariables() {\n  const style = document.createElement(\"style\");\n  style.id = \"hypertool-theme\";\n  const cssVars = Object.entries({\n    ...studioTheme.cssVariables,\n    ...studioTheme.tweakpane\n  }).map(([key, value]) => `  ${key}: ${value};`).join(`\n`);\n  style.textContent = `\n  body {\n   margin: 0;\n   padding: 0;\n  }\n  \n:root {\n${cssVars}\n}\n\n\n`;\n  document.head.appendChild(style);\n}\n\n// src/controls/HypertoolControls.ts\nclass HypertoolControls {\n  constructor(definitions, options = {}) {\n    this.pane = null;\n    this.definitions = definitions;\n    this.options = {\n      title: options.title || \"Controls\",\n      position: options.position || \"top-right\",\n      expanded: options.expanded !== undefined ? options.expanded : true,\n      container: options.container !== undefined ? options.container : null,\n      onChange: options.onChange || (() => {}),\n      onReady: options.onReady || (() => {})\n    };\n    this.params = this.extractInitialValues(definitions);\n    this.init();\n  }\n  isFolder(definition) {\n    return definition && typeof definition === \"object\" && (definition.type === \"folder\" || definition.type === \"group\");\n  }\n  isButton(definition) {\n    return definition && typeof definition === \"object\" && definition.type === \"button\";\n  }\n  isTab(definition) {\n    return definition && typeof definition === \"object\" && definition.type === \"tab\";\n  }\n  extractInitialValues(definitions) {\n    const params = {};\n    for (const [key, definition] of Object.entries(definitions)) {\n      const def = definition;\n      if (this.isFolder(def)) {\n        params[key] = this.extractInitialValues(def.controls);\n      } else if (this.isTab(def)) {\n        params[key] = def.pages.map((page) => this.extractInitialValues(page.controls));\n      } else if (this.isButton(def)) {\n        continue;\n      } else {\n        params[key] = def.value;\n      }\n    }\n    return params;\n  }\n  async init() {\n    try {\n      injectThemeVariables();\n      await new Promise((resolve) => setTimeout(resolve, 50));\n      this.createPane();\n      this.addControls();\n      this.options.onReady();\n      console.log(\"[HypertoolControls] Initialized successfully\");\n    } catch (error) {\n      console.error(\"[HypertoolControls] Initialization error:\", error);\n    }\n  }\n  createPane() {\n    const container = this.resolveContainer();\n    const paneOptions = {\n      title: this.options.title,\n      expanded: this.options.expanded\n    };\n    if (container) {\n      paneOptions.container = container;\n    }\n    this.pane = new Pane(paneOptions);\n    this.pane.element.parentElement?.classList.add(\"controls-container\");\n  }\n  resolveContainer() {\n    if (typeof document === \"undefined\")\n      return null;\n    const containerOption = this.options.container;\n    if (!containerOption)\n      return null;\n    if (containerOption instanceof HTMLElement) {\n      return containerOption;\n    }\n    const element = document.querySelector(containerOption);\n    if (!element) {\n      console.warn(`[HypertoolControls] Container selector \"${containerOption}\" did not match any elements`);\n      return null;\n    }\n    return element;\n  }\n  addControls() {\n    if (!this.pane)\n      return;\n    this.addControlsToTarget(this.pane, this.definitions, this.params);\n  }\n  addControlsToTarget(target, definitions, params) {\n    for (const [key, definition] of Object.entries(definitions)) {\n      try {\n        if (this.isFolder(definition)) {\n          const folderConfig = {\n            title: definition.label || key\n          };\n          if (definition.expanded !== undefined) {\n            folderConfig.expanded = definition.expanded;\n          }\n          const folder = target.addFolder(folderConfig);\n          this.addControlsToTarget(folder, definition.controls, params[key]);\n        } else if (this.isButton(definition)) {\n          const buttonConfig = {\n            title: definition.title\n          };\n          if (definition.label) {\n            buttonConfig.label = definition.label;\n          }\n          const button = target.addButton(buttonConfig);\n          if (definition.onClick) {\n            button.on(\"click\", definition.onClick);\n          }\n        } else if (this.isTab(definition)) {\n          const tabConfig = {\n            pages: definition.pages.map((page) => ({ title: page.title }))\n          };\n          const tab = target.addTab(tabConfig);\n          definition.pages.forEach((page, index) => {\n            this.addControlsToTarget(tab.pages[index], page.controls, params[key][index]);\n          });\n        } else {\n          this.addControlToTarget(target, key, definition, params);\n        }\n      } catch (error) {\n        console.error(`[HypertoolControls] Error adding control/folder/button/tab \"${key}\":`, error);\n      }\n    }\n  }\n  addControlToTarget(target, key, definition, params) {\n    if (this.isFolder(definition))\n      return;\n    const config = {\n      label: definition.label || key\n    };\n    console.log(definition);\n    if (definition.readonly !== undefined) {\n      config.readonly = definition.readonly;\n    }\n    if (definition.interval !== undefined) {\n      config.interval = definition.interval;\n    }\n    if (definition.bufferSize !== undefined) {\n      config.bufferSize = definition.bufferSize;\n    }\n    if (definition.multiline !== undefined) {\n      config.multiline = definition.multiline;\n    }\n    if (definition.rows !== undefined) {\n      config.rows = definition.rows;\n    }\n    if (definition.view !== undefined) {\n      config.view = definition.view;\n    }\n    switch (definition.type) {\n      case \"number\":\n        if (definition.min !== undefined)\n          config.min = definition.min;\n        if (definition.max !== undefined)\n          config.max = definition.max;\n        if (definition.step !== undefined)\n          config.step = definition.step;\n        break;\n      case \"point\":\n      case \"point2d\":\n      case \"point3d\":\n      case \"point4d\":\n        if (definition.min !== undefined)\n          config.min = definition.min;\n        if (definition.max !== undefined)\n          config.max = definition.max;\n        if (definition.step !== undefined)\n          config.step = definition.step;\n        const axes = [\"x\", \"y\", \"z\", \"w\"];\n        for (const axis of axes) {\n          if (definition[axis] && typeof definition[axis] === \"object\") {\n            config[axis] = definition[axis];\n          }\n        }\n        break;\n      case \"select\":\n      case \"selector\":\n        console.log(`[HypertoolControls] Adding select control \"${key}\":`, definition);\n        if (Array.isArray(definition.options)) {\n          config.options = definition.options.map((opt) => {\n            if (typeof opt === \"object\" && opt !== null) {\n              return {\n                text: opt.label || opt.text || String(opt.value),\n                value: opt.value\n              };\n            }\n            return {\n              text: String(opt),\n              value: opt\n            };\n          });\n        } else {\n          config.options = Object.entries(definition.options).map(([text, value]) => ({\n            text,\n            value\n          }));\n        }\n        console.log(\"[HypertoolControls] Select options for\", key, \":\", config.options);\n        break;\n      case \"color\":\n      case \"boolean\":\n      case \"string\":\n      case \"text\":\n        break;\n      case \"folder\":\n      case \"group\":\n        console.warn(`[HypertoolControls] Folder/Group encountered in addControlToTarget (should be handled earlier)`);\n        return;\n      case \"button\":\n        console.warn(`[HypertoolControls] Button encountered in addControlToTarget (should be handled earlier)`);\n        return;\n      case \"tab\":\n        console.warn(`[HypertoolControls] Tab encountered in addControlToTarget (should be handled earlier)`);\n        return;\n      default:\n        console.warn(`[HypertoolControls] Unknown control type: ${definition.type}`);\n        return;\n    }\n    const binding = target.addBinding(params, key, config);\n    binding.on(\"change\", (event) => {\n      params[key] = event.value;\n      const context = {\n        key,\n        value: event.value,\n        event\n      };\n      this.options.onChange(this.values, context);\n    });\n  }\n  addFolder(title) {\n    if (!this.pane)\n      return null;\n    return this.pane.addFolder({ title });\n  }\n  set(key, value) {\n    if (key in this.params) {\n      this.params[key] = value;\n      if (this.pane) {\n        this.pane.refresh();\n      }\n    }\n  }\n  get values() {\n    return { ...this.params };\n  }\n  destroy() {\n    if (this.pane) {\n      this.pane.dispose();\n      this.pane = null;\n    }\n    const themeStyle = document.getElementById(\"hypertool-theme\");\n    if (themeStyle) {\n      themeStyle.remove();\n    }\n  }\n  setVisible(visible) {\n    if (!this.pane)\n      return;\n    this.pane.element.style.display = visible ? \"block\" : \"none\";\n  }\n  refresh() {\n    if (this.pane) {\n      this.pane.refresh();\n    }\n  }\n}\n// src/controls/simple-api.ts\nfunction createControls(definitions, options) {\n  const controls = new HypertoolControls(definitions, options);\n  return controls.params;\n}\nfunction createControlPanel(definitions, options) {\n  return new HypertoolControls(definitions, options);\n}\n// src/frame/runtime.ts\nvar import_react7 = __toESM(require_react(), 1);\nvar import_client = __toESM(require_client(), 1);\n\n// src/frame/cssBridge.ts\nvar CLONE_ATTRIBUTE = \"data-hyper-frame-clone\";\nvar SUPPORTED_NODE_NAMES = new Set([\"STYLE\", \"LINK\"]);\nvar CSS_SYNC_MESSAGE_TYPE = \"hyper-frame:css-sync\";\n\nclass CssBridge {\n  source;\n  target;\n  observer = null;\n  nodeMap = new WeakMap;\n  active = false;\n  messageListener = null;\n  usePostMessage = false;\n  cssNodesById = new Map;\n  constructor(options = {}) {\n    let sourceDoc = null;\n    if (options.sourceDocument) {\n      sourceDoc = options.sourceDocument;\n    } else if (typeof window !== \"undefined\") {\n      try {\n        sourceDoc = window.parent?.document ?? null;\n      } catch (error) {\n        console.debug(\"[hyper-frame] Using postMessage for CSS sync (cross-origin)\");\n        this.usePostMessage = true;\n        sourceDoc = null;\n      }\n    }\n    this.source = sourceDoc;\n    this.target = options.targetDocument ?? (typeof document !== \"undefined\" ? document : null);\n    this.active = Boolean(options.mirror ?? true);\n  }\n  start() {\n    if (!this.active)\n      return;\n    if (this.usePostMessage) {\n      this.startPostMessageMode();\n    } else if (this.source && this.target) {\n      this.cleanupPreviousClones();\n      this.syncAll();\n      this.attachObserver();\n    } else {\n      console.warn(\"[hyper-frame] Unable to mirror CSS  missing source or target document.\");\n    }\n  }\n  stop() {\n    this.observer?.disconnect();\n    this.observer = null;\n    this.nodeMap = new WeakMap;\n    this.cleanupPreviousClones();\n    if (this.messageListener && typeof window !== \"undefined\") {\n      window.removeEventListener(\"message\", this.messageListener);\n      this.messageListener = null;\n    }\n    this.cssNodesById.clear();\n  }\n  startPostMessageMode() {\n    if (!this.target || typeof window === \"undefined\")\n      return;\n    this.cleanupPreviousClones();\n    this.messageListener = (event) => {\n      if (!event.data || event.data.type !== CSS_SYNC_MESSAGE_TYPE)\n        return;\n      this.handleCssMessage(event.data);\n    };\n    window.addEventListener(\"message\", this.messageListener);\n    console.debug(\"[hyper-frame] CSS postMessage receiver ready\");\n  }\n  handleCssMessage(message) {\n    if (!this.target)\n      return;\n    switch (message.action) {\n      case \"init\":\n        this.cleanupPreviousClones();\n        this.cssNodesById.clear();\n        break;\n      case \"add\":\n        if (message.id && message.tagName) {\n          this.addCssNode(message.id, message.tagName, message.attributes, message.textContent);\n        }\n        break;\n      case \"remove\":\n        if (message.id) {\n          this.removeCssNode(message.id);\n        }\n        break;\n      case \"update\":\n        if (message.id) {\n          this.updateCssNode(message.id, message.attributes, message.textContent);\n        }\n        break;\n    }\n  }\n  addCssNode(id, tagName, attributes, textContent) {\n    if (!this.target)\n      return;\n    if (this.cssNodesById.has(id))\n      return;\n    const element = document.createElement(tagName);\n    element.setAttribute(CLONE_ATTRIBUTE, \"true\");\n    element.setAttribute(\"data-css-id\", id);\n    if (attributes) {\n      for (const [key, value] of Object.entries(attributes)) {\n        element.setAttribute(key, value);\n      }\n    }\n    if (textContent) {\n      element.textContent = textContent;\n    }\n    this.target.head.appendChild(element);\n    this.cssNodesById.set(id, element);\n  }\n  removeCssNode(id) {\n    const element = this.cssNodesById.get(id);\n    if (element && element.parentNode) {\n      element.parentNode.removeChild(element);\n      this.cssNodesById.delete(id);\n    }\n  }\n  updateCssNode(id, attributes, textContent) {\n    const element = this.cssNodesById.get(id);\n    if (!element)\n      return;\n    if (attributes) {\n      for (const attr of Array.from(element.attributes)) {\n        if (!attr.name.startsWith(\"data-\")) {\n          element.removeAttribute(attr.name);\n        }\n      }\n      for (const [key, value] of Object.entries(attributes)) {\n        element.setAttribute(key, value);\n      }\n    }\n    if (textContent !== undefined) {\n      element.textContent = textContent;\n    }\n  }\n  cleanupPreviousClones() {\n    if (!this.target)\n      return;\n    this.target.querySelectorAll(`[${CLONE_ATTRIBUTE}=\"true\"]`).forEach((node) => node.parentNode?.removeChild(node));\n  }\n  async syncAll() {\n    if (!this.source || !this.target)\n      return;\n    const head = this.source.head;\n    const nodes = Array.from(head.children).filter((node) => SUPPORTED_NODE_NAMES.has(node.nodeName));\n    for (const node of nodes) {\n      const clone = await this.cloneNode(node);\n      if (!clone)\n        continue;\n      this.target?.head.appendChild(clone);\n      this.nodeMap.set(node, clone);\n    }\n  }\n  attachObserver() {\n    if (!this.source || !this.target)\n      return;\n    if (this.observer)\n      return;\n    this.observer = new MutationObserver((mutations) => {\n      mutations.forEach((mutation) => {\n        switch (mutation.type) {\n          case \"childList\":\n            this.handleChildListMutation(mutation);\n            break;\n          case \"characterData\":\n            this.handleCharacterDataMutation(mutation);\n            break;\n          case \"attributes\":\n            this.handleAttributeMutation(mutation);\n            break;\n        }\n      });\n    });\n    this.observer.observe(this.source.head, {\n      childList: true,\n      subtree: true,\n      characterData: true,\n      attributes: true\n    });\n  }\n  handleChildListMutation(mutation) {\n    if (!this.target)\n      return;\n    mutation.removedNodes.forEach((node) => {\n      const mapped = this.nodeMap.get(node);\n      if (mapped && mapped.parentNode) {\n        mapped.parentNode.removeChild(mapped);\n        this.nodeMap.delete(node);\n      }\n    });\n    mutation.addedNodes.forEach(async (node) => {\n      if (!(node instanceof HTMLElement))\n        return;\n      if (!SUPPORTED_NODE_NAMES.has(node.nodeName))\n        return;\n      try {\n        const clone = await this.cloneNode(node);\n        if (!clone)\n          return;\n        const reference = mutation.nextSibling ? this.nodeMap.get(mutation.nextSibling) : null;\n        if (reference && reference.parentNode) {\n          reference.parentNode.insertBefore(clone, reference);\n        } else {\n          this.target?.head.appendChild(clone);\n        }\n        this.nodeMap.set(node, clone);\n      } catch (error) {\n        console.error(\"[CssBridge] Failed to clone node:\", error);\n      }\n    });\n  }\n  handleCharacterDataMutation(mutation) {\n    const targetNode = mutation.target;\n    const parent = targetNode.parentNode;\n    if (!parent)\n      return;\n    const mappedParent = this.nodeMap.get(parent);\n    if (!mappedParent)\n      return;\n    mappedParent.textContent = parent.textContent;\n  }\n  handleAttributeMutation(mutation) {\n    const target = mutation.target;\n    const mapped = this.nodeMap.get(target);\n    if (!mapped || !(mapped instanceof Element))\n      return;\n    if (mutation.attributeName) {\n      const value = target.getAttribute(mutation.attributeName);\n      if (value === null) {\n        mapped.removeAttribute(mutation.attributeName);\n      } else {\n        mapped.setAttribute(mutation.attributeName, value);\n      }\n    }\n  }\n  async cloneNode(node) {\n    if (!(node instanceof HTMLElement))\n      return null;\n    if (!SUPPORTED_NODE_NAMES.has(node.nodeName))\n      return null;\n    if (node.nodeName === \"LINK\" && node instanceof HTMLLinkElement) {\n      const href = node.getAttribute(\"href\");\n      const rel = node.getAttribute(\"rel\");\n      if (href) {\n        if (rel === \"stylesheet\") {\n          try {\n            const cssContent = await this.fetchCssContent(href);\n            const styleElement = document.createElement(\"STYLE\");\n            styleElement.textContent = cssContent;\n            styleElement.setAttribute(CLONE_ATTRIBUTE, \"true\");\n            return styleElement;\n          } catch (error) {\n            console.error(`[CssBridge] Failed to fetch CSS from ${href}:`, error);\n          }\n        }\n        const clone2 = node.cloneNode(true);\n        try {\n          const baseUrl = this.source ? new URL(this.source.location.href) : new URL(window.location.href);\n          const absoluteUrl = new URL(href, baseUrl).href;\n          clone2.setAttribute(\"href\", absoluteUrl);\n        } catch (error) {\n          console.error(`[CssBridge] Failed to convert URL to absolute: ${href}`, error);\n        }\n        clone2.setAttribute(CLONE_ATTRIBUTE, \"true\");\n        return clone2;\n      }\n    }\n    const clone = node.cloneNode(true);\n    clone.setAttribute(CLONE_ATTRIBUTE, \"true\");\n    return clone;\n  }\n  async fetchCssContent(href) {\n    const baseUrl = this.source ? new URL(this.source.location.href) : new URL(window.location.href);\n    const absoluteUrl = new URL(href, baseUrl).href;\n    const response = await fetch(absoluteUrl);\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n    return await response.text();\n  }\n}\n\n// src/frame/utils/dom.ts\nfunction resolveContainer(options = {}) {\n  const doc = options.documentRef ?? document;\n  if (!doc) {\n    throw new Error(\"[hyper-frame] document is not available\");\n  }\n  const className = options.containerClassName || \"hyper-frame\";\n  const target = options.target;\n  if (target instanceof HTMLElement) {\n    target.classList.add(className);\n    return { element: target, createdInternally: false };\n  }\n  if (typeof target === \"string\" && target.trim().length > 0) {\n    const node = doc.querySelector(target);\n    if (node) {\n      node.classList.add(className);\n      return { element: node, createdInternally: false };\n    }\n    console.warn(`[hyper-frame] Could not find container for selector \"${target}\", creating one instead.`);\n  }\n  const container = doc.createElement(\"div\");\n  container.classList.add(className);\n  container.classList.add(\"hyper-frame-container\");\n  doc.body.appendChild(container);\n  return { element: container, createdInternally: true };\n}\n\n// src/frame/wrapper-app/WrapperApp.tsx\nvar import_react6 = __toESM(require_react(), 1);\n\n// src/frame/wrapper-app/components/ControlsPanel.tsx\nvar import_react = __toESM(require_react(), 1);\nvar jsx_dev_runtime = __toESM(require_jsx_dev_runtime(), 1);\nvar ControlsPanel = ({\n  definitions,\n  options,\n  onChange,\n  onReady\n}) => {\n  const containerRef = import_react.useRef(null);\n  const controlsRef = import_react.useRef(null);\n  const onReadyRef = import_react.useRef(onReady);\n  import_react.useEffect(() => {\n    onReadyRef.current = onReady;\n  }, [onReady]);\n  import_react.useEffect(() => {\n    if (!containerRef.current)\n      return;\n    const hyperWindow = window;\n    if (!hyperWindow.hypertoolControls) {\n      console.warn(\"[ControlsPanel] hypertoolControls not available on window\");\n      return;\n    }\n    try {\n      const controls = hyperWindow.hypertoolControls.createControlPanel(definitions, {\n        title: options?.title,\n        position: options?.position,\n        expanded: options?.expanded,\n        container: containerRef.current,\n        onChange: (params, context) => {\n          if (onChange) {\n            onChange({\n              key: context.key,\n              value: context.value,\n              event: context.event\n            });\n          }\n        }\n      });\n      controlsRef.current = controls;\n      if (onReadyRef.current) {\n        onReadyRef.current(controls);\n      }\n    } catch (error) {\n      console.error(\"[ControlsPanel] Failed to create controls:\", error);\n    }\n    return () => {\n      if (controlsRef.current) {\n        if (typeof controlsRef.current.dispose === \"function\") {\n          controlsRef.current.dispose();\n        } else if (typeof controlsRef.current.destroy === \"function\") {\n          controlsRef.current.destroy();\n        }\n        controlsRef.current = null;\n      }\n    };\n  }, [definitions, options, onChange]);\n  return /* @__PURE__ */ jsx_dev_runtime.jsxDEV(\"div\", {\n    ref: containerRef,\n    className: \"hyper-frame-controls-panel\"\n  }, undefined, false, undefined, this);\n};\n\n// src/frame/wrapper-app/components/ExportWidget.tsx\nvar import_react2 = __toESM(require_react(), 1);\nvar jsx_dev_runtime2 = __toESM(require_jsx_dev_runtime(), 1);\nvar ExportWidget = ({\n  getContainer,\n  filename = \"hyperframe-export\",\n  useCanvasCapture = true\n}) => {\n  const [imageEnabled, setImageEnabled] = import_react2.useState(false);\n  const [videoEnabled, setVideoEnabled] = import_react2.useState(false);\n  const [recording, setRecording] = import_react2.useState(false);\n  const recorderRef = import_react2.useRef(null);\n  const recordedChunksRef = import_react2.useRef([]);\n  import_react2.useEffect(() => {\n    const checkAvailability = () => {\n      const container = getContainer();\n      if (container && useCanvasCapture) {\n        const canvas = container.querySelector(\"canvas\");\n        if (canvas) {\n          setImageEnabled(true);\n          setVideoEnabled(true);\n          return true;\n        }\n      }\n      return false;\n    };\n    if (checkAvailability()) {\n      return;\n    }\n    const interval = setInterval(() => {\n      if (checkAvailability()) {\n        clearInterval(interval);\n      }\n    }, 100);\n    return () => clearInterval(interval);\n  }, [getContainer, useCanvasCapture]);\n  const downloadBlob = import_react2.useCallback((blob, filename2) => {\n    const url = URL.createObjectURL(blob);\n    const anchor = document.createElement(\"a\");\n    anchor.href = url;\n    anchor.download = filename2;\n    anchor.rel = \"noopener\";\n    anchor.style.display = \"none\";\n    document.body.appendChild(anchor);\n    anchor.click();\n    document.body.removeChild(anchor);\n    URL.revokeObjectURL(url);\n  }, []);\n  const handleCapturePNG = import_react2.useCallback(async () => {\n    try {\n      const container = getContainer();\n      if (!container) {\n        throw new Error(\"Container not available.\");\n      }\n      const canvas = container.querySelector(\"canvas\");\n      if (!canvas || !(canvas instanceof HTMLCanvasElement)) {\n        throw new Error(\"No canvas element available for capture.\");\n      }\n      const blob = await new Promise((resolve, reject) => {\n        canvas.toBlob((blob2) => {\n          if (blob2) {\n            resolve(blob2);\n          } else {\n            reject(new Error(\"Canvas capture returned an empty blob.\"));\n          }\n        });\n      });\n      if (blob) {\n        downloadBlob(blob, `${filename}.png`);\n        console.log(\"PNG captured\");\n      }\n    } catch (error) {\n      console.error(\"[ExportWidget] Failed to capture image:\", error);\n    }\n  }, [getContainer, filename, downloadBlob]);\n  const stopRecording = import_react2.useCallback(() => {\n    if (!recorderRef.current) {\n      console.warn(\"[ExportWidget] No active recorder to stop\");\n      return;\n    }\n    console.log(\"Stopping recording\");\n    recorderRef.current.stop();\n  }, []);\n  const startRecording = import_react2.useCallback(async () => {\n    try {\n      const container = getContainer();\n      if (!container) {\n        throw new Error(\"Container not available.\");\n      }\n      const canvas = container.querySelector(\"canvas\");\n      if (!canvas || !(canvas instanceof HTMLCanvasElement)) {\n        throw new Error(\"No canvas element available for recording.\");\n      }\n      if (typeof canvas.captureStream !== \"function\") {\n        throw new Error(\"Canvas captureStream API is not supported in this browser.\");\n      }\n      const stream = canvas.captureStream(60);\n      const formats = [\n        { mimeType: \"video/mp4;codecs=avc1\", extension: \"mp4\" },\n        { mimeType: \"video/mp4;codecs=h264\", extension: \"mp4\" },\n        { mimeType: \"video/mp4;codecs=avc1.42E01E\", extension: \"mp4\" },\n        { mimeType: \"video/mp4\", extension: \"mp4\" },\n        { mimeType: \"video/webm;codecs=h264\", extension: \"webm\" },\n        { mimeType: \"video/webm;codecs=vp9\", extension: \"webm\" },\n        { mimeType: \"video/webm;codecs=vp8\", extension: \"webm\" },\n        { mimeType: \"video/webm\", extension: \"webm\" }\n      ];\n      let format = formats.find((f) => MediaRecorder.isTypeSupported(f.mimeType));\n      if (!format) {\n        format = { mimeType: \"\", extension: \"webm\" };\n      }\n      console.log(\"[ExportWidget] Using video format:\", format.mimeType || \"browser default\");\n      const recorderOptions = {\n        videoBitsPerSecond: 5000000\n      };\n      if (format.mimeType) {\n        recorderOptions.mimeType = format.mimeType;\n      }\n      const recorder = new MediaRecorder(stream, recorderOptions);\n      const chunks = [];\n      recordedChunksRef.current = chunks;\n      recorder.addEventListener(\"dataavailable\", (event) => {\n        if (event.data?.size) {\n          chunks.push(event.data);\n        }\n      });\n      recorder.addEventListener(\"stop\", () => {\n        const mimeType = format.mimeType || recorder.mimeType || \"video/webm\";\n        const blob = new Blob(chunks, { type: mimeType });\n        console.log(\"[ExportWidget] Recording complete:\", {\n          size: blob.size,\n          type: blob.type,\n          chunks: chunks.length\n        });\n        downloadBlob(blob, `${filename}.${format.extension}`);\n        stream.getTracks().forEach((track) => track.stop());\n        setRecording(false);\n        recorderRef.current = null;\n        recordedChunksRef.current = [];\n      });\n      recorder.start();\n      recorderRef.current = recorder;\n      setRecording(true);\n      console.log(\"Recording started\");\n    } catch (error) {\n      console.error(\"[ExportWidget] Failed to start recording:\", error);\n      setRecording(false);\n      recorderRef.current = null;\n    }\n  }, [getContainer, filename, downloadBlob]);\n  const handleToggleRecording = import_react2.useCallback(async () => {\n    if (recording) {\n      stopRecording();\n    } else {\n      await startRecording();\n    }\n  }, [recording, stopRecording, startRecording]);\n  return /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(\"div\", {\n    className: \"export-widget-container absolute top-0 left-0 py-2 px-2 z-[9999]\",\n    children: /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(\"div\", {\n      className: \"flex items-center gap-2\",\n      children: [\n        /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(\"button\", {\n          type: \"button\",\n          className: `inline-flex items-center gap-2 rounded-lg border border-border bg-background px-2 py-1 text-sm text-text transition hover:bg-muted/80 whitespace-nowrap ${!imageEnabled ? \"opacity-60 cursor-not-allowed\" : \"\"}`,\n          onClick: handleCapturePNG,\n          disabled: !imageEnabled,\n          title: \"Screenshot\",\n          children: [\n            /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(\"svg\", {\n              xmlns: \"http://www.w3.org/2000/svg\",\n              width: \"18\",\n              height: \"18\",\n              viewBox: \"0 0 24 24\",\n              fill: \"none\",\n              stroke: \"currentColor\",\n              strokeWidth: \"2\",\n              strokeLinecap: \"round\",\n              strokeLinejoin: \"round\",\n              children: [\n                /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(\"path\", {\n                  d: \"M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z\"\n                }, undefined, false, undefined, this),\n                /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(\"circle\", {\n                  cx: \"12\",\n                  cy: \"13\",\n                  r: \"3\"\n                }, undefined, false, undefined, this)\n              ]\n            }, undefined, true, undefined, this),\n            /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(\"span\", {\n              children: \"Screenshot\"\n            }, undefined, false, undefined, this)\n          ]\n        }, undefined, true, undefined, this),\n        /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(\"button\", {\n          type: \"button\",\n          className: `inline-flex items-center gap-2 rounded-lg border transition hover:bg-muted/80 whitespace-nowrap px-2 py-1 text-sm ${recording ? \"bg-red-500/20 text-red-400 border-red-500/30\" : \"bg-background text-text border-border\"} ${!videoEnabled ? \"opacity-60 cursor-not-allowed\" : \"\"}`,\n          onClick: handleToggleRecording,\n          disabled: !videoEnabled,\n          title: recording ? \"Stop Recording\" : \"Record Video\",\n          children: [\n            /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(\"svg\", {\n              xmlns: \"http://www.w3.org/2000/svg\",\n              width: \"18\",\n              height: \"18\",\n              viewBox: \"0 0 24 24\",\n              fill: \"none\",\n              stroke: \"currentColor\",\n              strokeWidth: \"2\",\n              strokeLinecap: \"round\",\n              strokeLinejoin: \"round\",\n              children: [\n                /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(\"path\", {\n                  d: \"m22 8-6 4 6 4V8Z\"\n                }, undefined, false, undefined, this),\n                /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(\"rect\", {\n                  x: \"2\",\n                  y: \"6\",\n                  width: \"14\",\n                  height: \"12\",\n                  rx: \"2\",\n                  ry: \"2\"\n                }, undefined, false, undefined, this)\n              ]\n            }, undefined, true, undefined, this),\n            /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(\"span\", {\n              children: recording ? \"Stop\" : \"Rec\"\n            }, undefined, false, undefined, this)\n          ]\n        }, undefined, true, undefined, this)\n      ]\n    }, undefined, true, undefined, this)\n  }, undefined, false, undefined, this);\n};\n\n// src/frame/wrapper-app/components/SandboxContainer.tsx\nvar import_react4 = __toESM(require_react(), 1);\n\n// src/frame/wrapper-app/context/CanvasContext.tsx\nvar import_react3 = __toESM(require_react(), 1);\nvar jsx_dev_runtime3 = __toESM(require_jsx_dev_runtime(), 1);\nvar CanvasContext = import_react3.createContext(null);\nvar calculateAvailableSpace = () => {\n  const availableWidth = window.innerWidth;\n  const availableHeight = window.innerHeight;\n  return {\n    width: Math.max(100, Math.round(availableWidth)),\n    height: Math.max(100, Math.round(availableHeight))\n  };\n};\nvar CanvasProvider = ({ children }) => {\n  const initialSpace = import_react3.useMemo(() => calculateAvailableSpace(), []);\n  const [width, setWidthState] = import_react3.useState(initialSpace.width);\n  const [height, setHeightState] = import_react3.useState(initialSpace.height);\n  const [maxWidth, setMaxWidth] = import_react3.useState(initialSpace.width);\n  const [maxHeight, setMaxHeight] = import_react3.useState(initialSpace.height);\n  const [isFittedToScreen, setIsFittedToScreen] = import_react3.useState(true);\n  import_react3.useEffect(() => {\n    const handleResize = () => {\n      const space = calculateAvailableSpace();\n      setMaxWidth(space.width);\n      setMaxHeight(space.height);\n      if (isFittedToScreen) {\n        setWidthState(space.width);\n        setHeightState(space.height);\n      }\n    };\n    window.addEventListener(\"resize\", handleResize);\n    return () => window.removeEventListener(\"resize\", handleResize);\n  }, [isFittedToScreen]);\n  const setWidth = import_react3.useCallback((w) => {\n    const clampedWidth = Math.max(100, Math.min(w, maxWidth));\n    setWidthState(clampedWidth);\n    setIsFittedToScreen(false);\n  }, [maxWidth]);\n  const setHeight = import_react3.useCallback((h) => {\n    const clampedHeight = Math.max(100, Math.min(h, maxHeight));\n    setHeightState(clampedHeight);\n    setIsFittedToScreen(false);\n  }, [maxHeight]);\n  const fitToScreen = import_react3.useCallback(() => {\n    const space = calculateAvailableSpace();\n    setWidthState(space.width);\n    setHeightState(space.height);\n    setIsFittedToScreen(true);\n  }, []);\n  const value = {\n    width,\n    height,\n    maxWidth,\n    maxHeight,\n    isFittedToScreen,\n    setWidth,\n    setHeight,\n    fitToScreen\n  };\n  return /* @__PURE__ */ jsx_dev_runtime3.jsxDEV(CanvasContext.Provider, {\n    value,\n    children\n  }, undefined, false, undefined, this);\n};\nvar useCanvas = () => {\n  const context = import_react3.useContext(CanvasContext);\n  if (!context) {\n    throw new Error(\"useCanvas must be used within a CanvasProvider\");\n  }\n  return context;\n};\n\n// src/frame/wrapper-app/components/SandboxContainer.tsx\nvar jsx_dev_runtime4 = __toESM(require_jsx_dev_runtime(), 1);\nvar SandboxContainer = ({ onReady }) => {\n  const containerRef = import_react4.useRef(null);\n  const { width, height } = useCanvas();\n  import_react4.useEffect(() => {\n    if (containerRef.current) {\n      onReady(containerRef.current);\n    }\n  }, [onReady]);\n  import_react4.useEffect(() => {\n    const resizeEvent = new Event(\"resize\");\n    window.dispatchEvent(resizeEvent);\n    console.log(\"[SandboxContainer] Dispatched resize event:\", { width, height });\n  }, [width, height]);\n  return /* @__PURE__ */ jsx_dev_runtime4.jsxDEV(\"div\", {\n    className: \"hyper-frame-sandbox-wrapper absolute inset-0 flex items-center justify-center pointer-events-none\",\n    children: /* @__PURE__ */ jsx_dev_runtime4.jsxDEV(\"div\", {\n      ref: containerRef,\n      className: \"hyper-frame-sandbox-container pointer-events-auto\",\n      style: {\n        width: `${width}px`,\n        height: `${height}px`\n      }\n    }, undefined, false, undefined, this)\n  }, undefined, false, undefined, this);\n};\n\n// src/frame/wrapper-app/components/CanvasSizeWidget.tsx\nvar import_react5 = __toESM(require_react(), 1);\nvar jsx_dev_runtime5 = __toESM(require_jsx_dev_runtime(), 1);\nvar CanvasSizeWidget = () => {\n  const { width, height, maxWidth, maxHeight, setWidth, setHeight, fitToScreen } = useCanvas();\n  const [widthInput, setWidthInput] = import_react5.useState(width.toString());\n  const [heightInput, setHeightInput] = import_react5.useState(height.toString());\n  import_react5.useEffect(() => {\n    setWidthInput(width.toString());\n  }, [width]);\n  import_react5.useEffect(() => {\n    setHeightInput(height.toString());\n  }, [height]);\n  const applyWidth = () => {\n    const value = parseInt(widthInput);\n    if (!isNaN(value) && value >= 100 && value <= maxWidth) {\n      setWidth(value);\n    } else {\n      setWidthInput(width.toString());\n    }\n  };\n  const applyHeight2 = () => {\n    const value = parseInt(heightInput);\n    if (!isNaN(value) && value >= 100 && value <= maxHeight) {\n      setHeight(value);\n    } else {\n      setHeightInput(height.toString());\n    }\n  };\n  const handleWidthKeyDown = (e) => {\n    if (e.key === \"Enter\") {\n      applyWidth();\n      e.currentTarget.blur();\n    }\n  };\n  const handleHeightKeyDown = (e) => {\n    if (e.key === \"Enter\") {\n      applyHeight2();\n      e.currentTarget.blur();\n    }\n  };\n  return /* @__PURE__ */ jsx_dev_runtime5.jsxDEV(\"div\", {\n    className: \"canvas-size-widget-container absolute top-0 center px-2 py-2 z-[9999] flex items-center gap-2\",\n    children: [\n      /* @__PURE__ */ jsx_dev_runtime5.jsxDEV(\"div\", {\n        className: \"flex items-center gap-2\",\n        children: [\n          /* @__PURE__ */ jsx_dev_runtime5.jsxDEV(\"label\", {\n            className: \"text-sm text-accent\",\n            children: \"W:\"\n          }, undefined, false, undefined, this),\n          /* @__PURE__ */ jsx_dev_runtime5.jsxDEV(\"input\", {\n            type: \"number\",\n            value: widthInput,\n            onChange: (e) => setWidthInput(e.target.value),\n            onBlur: applyWidth,\n            onKeyDown: handleWidthKeyDown,\n            className: \"rounded border border-border bg-background px-2 py-1 text-sm text-text focus:border-accent focus:outline-none\",\n            style: { width: `${Math.max(widthInput.length * 8 + 16, 80)}px` },\n            min: \"100\",\n            max: maxWidth\n          }, undefined, false, undefined, this)\n        ]\n      }, undefined, true, undefined, this),\n      /* @__PURE__ */ jsx_dev_runtime5.jsxDEV(\"div\", {\n        className: \"flex items-center gap-2\",\n        children: [\n          /* @__PURE__ */ jsx_dev_runtime5.jsxDEV(\"label\", {\n            className: \"text-sm text-accent\",\n            children: \"H:\"\n          }, undefined, false, undefined, this),\n          /* @__PURE__ */ jsx_dev_runtime5.jsxDEV(\"input\", {\n            type: \"number\",\n            value: heightInput,\n            onChange: (e) => setHeightInput(e.target.value),\n            onBlur: applyHeight2,\n            onKeyDown: handleHeightKeyDown,\n            className: \"rounded border border-border bg-background px-2 py-1 text-sm text-text focus:border-accent focus:outline-none\",\n            style: { width: `${Math.max(heightInput.length * 8 + 16, 80)}px` },\n            min: \"100\",\n            max: maxHeight\n          }, undefined, false, undefined, this)\n        ]\n      }, undefined, true, undefined, this),\n      /* @__PURE__ */ jsx_dev_runtime5.jsxDEV(\"button\", {\n        type: \"button\",\n        className: \"inline-flex items-center gap-1 h-[30px] rounded-lg border border-border bg-background px-3 py-2 text-sm text-text transition hover:bg-muted/80 whitespace-nowrap\",\n        onClick: fitToScreen,\n        title: \"Fit to screen\",\n        children: /* @__PURE__ */ jsx_dev_runtime5.jsxDEV(\"svg\", {\n          xmlns: \"http://www.w3.org/2000/svg\",\n          width: \"16\",\n          height: \"16\",\n          viewBox: \"0 0 24 24\",\n          fill: \"none\",\n          stroke: \"currentColor\",\n          strokeWidth: \"2\",\n          strokeLinecap: \"round\",\n          strokeLinejoin: \"round\",\n          children: [\n            /* @__PURE__ */ jsx_dev_runtime5.jsxDEV(\"path\", {\n              d: \"M8 3H5a2 2 0 0 0-2 2v3\"\n            }, undefined, false, undefined, this),\n            /* @__PURE__ */ jsx_dev_runtime5.jsxDEV(\"path\", {\n              d: \"M21 8V5a2 2 0 0 0-2-2h-3\"\n            }, undefined, false, undefined, this),\n            /* @__PURE__ */ jsx_dev_runtime5.jsxDEV(\"path\", {\n              d: \"M3 16v3a2 2 0 0 0 2 2h3\"\n            }, undefined, false, undefined, this),\n            /* @__PURE__ */ jsx_dev_runtime5.jsxDEV(\"path\", {\n              d: \"M16 21h3a2 2 0 0 0 2-2v-3\"\n            }, undefined, false, undefined, this)\n          ]\n        }, undefined, true, undefined, this)\n      }, undefined, false, undefined, this)\n    ]\n  }, undefined, true, undefined, this);\n};\n\n// src/frame/wrapper-app/styles/controls.css\nvar style = document.createElement(\"style\");\nstyle.textContent = `/**\n * Controls Panel Styles\n **/\n\n.hyper-frame-controls-panel {\n  position: absolute;\n  z-index: 1000;\n  pointer-events: auto;\n}\n\n`;\ndocument.head.appendChild(style);\n\n// src/frame/wrapper-app/styles/wrapper-app.css\nvar style2 = document.createElement(\"style\");\nstyle2.textContent = `/* \n * Wrapper App Styles\n * Note: controls.css is imported directly in WrapperApp.tsx\n */\n\n/* .hyper-frame-controls-panel {\n  position: absolute;\n  z-index: 1000;\n  pointer-events: auto;\n} */\n\n`;\ndocument.head.appendChild(style2);\n\n// src/frame/wrapper-app/WrapperApp.tsx\nvar jsx_dev_runtime6 = __toESM(require_jsx_dev_runtime(), 1);\nvar WrapperApp = ({\n  onContainerReady,\n  controls,\n  exportWidget\n}) => {\n  const [container, setContainer] = import_react6.useState(null);\n  const handleContainerReady = import_react6.useCallback((node) => {\n    setContainer(node);\n    onContainerReady(node);\n  }, [onContainerReady]);\n  return /* @__PURE__ */ jsx_dev_runtime6.jsxDEV(CanvasProvider, {\n    children: /* @__PURE__ */ jsx_dev_runtime6.jsxDEV(\"div\", {\n      className: \"hyper-container flex flex-col items-center justify-center\",\n      children: [\n        exportWidget && exportWidget.enabled && /* @__PURE__ */ jsx_dev_runtime6.jsxDEV(ExportWidget, {\n          getContainer: () => container,\n          filename: exportWidget.filename,\n          useCanvasCapture: exportWidget.useCanvasCapture\n        }, undefined, false, undefined, this),\n        /* @__PURE__ */ jsx_dev_runtime6.jsxDEV(CanvasSizeWidget, {}, undefined, false, undefined, this),\n        /* @__PURE__ */ jsx_dev_runtime6.jsxDEV(SandboxContainer, {\n          onReady: handleContainerReady\n        }, undefined, false, undefined, this),\n        controls && /* @__PURE__ */ jsx_dev_runtime6.jsxDEV(ControlsPanel, {\n          definitions: controls.definitions,\n          options: controls.options,\n          onChange: controls.onChange,\n          onReady: controls.onReady\n        }, undefined, false, undefined, this)\n      ]\n    }, undefined, true, undefined, this)\n  }, undefined, false, undefined, this);\n};\n\n// src/frame/runtime.ts\nfunction runCleanups(cleanups) {\n  while (cleanups.length > 0) {\n    const cleanup = cleanups.pop();\n    if (cleanup) {\n      try {\n        cleanup();\n      } catch (error) {\n        console.error(\"[hyper-frame] cleanup failed\", error);\n      }\n    }\n  }\n}\n\nclass HyperFrameRuntime {\n  cssBridge = null;\n  config;\n  constructor(config = {}) {\n    this.config = config;\n  }\n  mirrorCss() {\n    if (this.cssBridge) {\n      return;\n    }\n    this.cssBridge = new CssBridge({ mirror: this.config.mirrorCss !== false });\n    this.cssBridge.start();\n  }\n  async createSandbox(options) {\n    if (this.config.mirrorCss !== false && options.mirrorCss !== false) {\n      this.mirrorCss();\n    }\n    const cleanups = [];\n    const pushCleanup = (cleanup) => {\n      if (typeof cleanup === \"function\") {\n        cleanups.push(cleanup);\n      }\n    };\n    const environment = this.createEnvironment(pushCleanup);\n    const exportsApi = {\n      registerImageCapture: () => {},\n      registerVideoCapture: () => {},\n      setFilename: () => {},\n      setVisible: () => {},\n      useDefaultCanvasCapture: () => {},\n      destroy: () => {}\n    };\n    let controlsHandle = null;\n    const context = {\n      mount: null,\n      params: {},\n      controls: null,\n      exports: exportsApi,\n      runtime: this,\n      environment\n    };\n    const controlsConfig = options.controls?.definitions ? {\n      definitions: options.controls.definitions,\n      options: options.controls.options,\n      onChange: (change) => options.controls?.onChange?.(change, context),\n      onReady: (controls) => {\n        if (controlsHandle) {\n          controlsHandle.params = controls.params;\n          controlsHandle.dispose = controls.dispose || controls.destroy;\n        }\n        context.params = controls.params;\n        context.controls = controlsHandle;\n      }\n    } : null;\n    if (controlsConfig) {\n      controlsHandle = {\n        params: {},\n        dispose: () => {}\n      };\n      context.controls = controlsHandle;\n    }\n    const mount = await this.createReactMount({\n      ...options,\n      controls: controlsConfig\n    });\n    context.mount = mount.sandboxContainer;\n    pushCleanup(() => mount.destroy());\n    let setupCleanup;\n    try {\n      setupCleanup = await options.setup(context);\n    } catch (error) {\n      console.error(\"[hyper-frame] sandbox setup failed\", error);\n      runCleanups(cleanups);\n      throw error;\n    }\n    if (typeof setupCleanup === \"function\") {\n      pushCleanup(() => {\n        try {\n          setupCleanup?.();\n        } catch (error) {\n          console.error(\"[hyper-frame] teardown failed\", error);\n        }\n      });\n    }\n    const handle = {\n      container: mount.sandboxContainer,\n      controls: controlsHandle,\n      params: context.params,\n      destroy: () => {\n        runCleanups(cleanups);\n      }\n    };\n    return handle;\n  }\n  createEnvironment(pushCleanup) {\n    if (typeof window === \"undefined\" || typeof document === \"undefined\") {\n      throw new Error(\"[hyper-frame] window or document is not available\");\n    }\n    return {\n      window,\n      document,\n      addCleanup: (cleanup) => {\n        if (typeof cleanup === \"function\") {\n          pushCleanup(cleanup);\n        }\n      },\n      onResize: (handler, options) => {\n        window.addEventListener(\"resize\", handler, options);\n        const dispose = () => window.removeEventListener(\"resize\", handler, options);\n        pushCleanup(dispose);\n        return dispose;\n      }\n    };\n  }\n  async createReactMount(options) {\n    const baseOptions = options.mount;\n    const resolved = resolveContainer({\n      target: baseOptions?.target,\n      containerClassName: baseOptions?.containerClassName\n    });\n    const root = import_client.createRoot(resolved.element);\n    const containerPromise = new Promise((resolve) => {\n      root.render(import_react7.default.createElement(WrapperApp, {\n        onContainerReady: resolve,\n        controls: options.controls || null,\n        exportWidget: {\n          enabled: options.exportWidget?.enabled !== false,\n          filename: options.exportWidget?.filename,\n          position: options.exportWidget?.position,\n          useCanvasCapture: options.exportWidget?.useCanvasCapture !== false\n        }\n      }));\n    });\n    const sandboxContainer = await containerPromise;\n    if (typeof baseOptions?.onReady === \"function\") {\n      baseOptions.onReady({ container: sandboxContainer });\n    }\n    return {\n      sandboxContainer,\n      destroy: () => {\n        root.unmount();\n        if (resolved.createdInternally) {\n          resolved.element.remove();\n        }\n      }\n    };\n  }\n}\n\n// src/frame/index.ts\nvar defaultConfig = { mirrorCss: true };\nvar runtime = new HyperFrameRuntime(defaultConfig);\nfunction configureRuntime(config) {\n  return new HyperFrameRuntime(config);\n}\nfunction createSandbox(options) {\n  return runtime.createSandbox(options);\n}\nfunction mirrorCss() {\n  runtime.mirrorCss();\n}\n\n// src/index.ts\nif (typeof window !== \"undefined\") {\n  window.hypertoolControls = {\n    createControls,\n    createControlPanel,\n    HypertoolControls,\n    injectThemeVariables,\n    studioTheme\n  };\n  const existing = window.hyperFrame || {};\n  window.hyperFrame = {\n    ...existing,\n    version: \"universal\",\n    runtime,\n    createSandbox,\n    mirrorCss\n  };\n  setupCaptureHandlers();\n}\nfunction setupCaptureHandlers() {\n  if (typeof window === \"undefined\") {\n    return;\n  }\n  let recordingState = {\n    isRecording: false,\n    recorder: null,\n    recordedChunks: []\n  };\n  window.addEventListener(\"message\", (event) => {\n    if (event.data?.source !== \"hypertool-main\")\n      return;\n    const { type } = event.data;\n    switch (type) {\n      case \"HYPERTOOL_CAPTURE_PNG\":\n        handleCapturePNG();\n        break;\n      case \"HYPERTOOL_START_RECORDING\":\n        handleStartRecording();\n        break;\n      case \"HYPERTOOL_STOP_RECORDING\":\n        handleStopRecording();\n        break;\n    }\n  });\n  function handleCapturePNG() {\n    const canvas = document.querySelector(\"canvas\");\n    if (canvas) {\n      canvas.toBlob((blob) => {\n        if (blob) {\n          window.parent.postMessage({\n            type: \"HYPERTOOL_CAPTURE_RESPONSE\",\n            data: {\n              blob,\n              filename: \"hypertool-capture.png\"\n            }\n          }, \"*\");\n        }\n      }, \"image/png\");\n    } else {\n      console.warn(\"No canvas found for capture\");\n    }\n  }\n  function handleStartRecording() {\n    console.log(\"Starting recording...\");\n    const canvas = document.querySelector(\"canvas\");\n    if (canvas && typeof canvas.captureStream === \"function\") {\n      const stream = canvas.captureStream(60);\n      const recorder = new MediaRecorder(stream, {\n        mimeType: \"video/webm;codecs=vp9\"\n      });\n      recordingState.recordedChunks = [];\n      recorder.ondataavailable = (event) => {\n        if (event.data.size > 0) {\n          recordingState.recordedChunks.push(event.data);\n          console.log(\"Recording data available:\", event.data.size, \"bytes\");\n        }\n      };\n      recorder.onstop = () => {\n        console.log(\"Recording stopped, processing...\");\n        const blob = new Blob(recordingState.recordedChunks, { type: \"video/webm\" });\n        console.log(\"Recording blob size:\", blob.size, \"bytes\");\n        window.parent.postMessage({\n          type: \"HYPERTOOL_RECORDING_RESPONSE\",\n          data: {\n            blob,\n            filename: \"hypertool-recording.webm\"\n          }\n        }, \"*\");\n        recordingState.isRecording = false;\n        recordingState.recorder = null;\n      };\n      recorder.start();\n      recordingState.recorder = recorder;\n      recordingState.isRecording = true;\n      console.log(\"Recording started successfully\");\n    } else {\n      console.warn(\"Canvas not found or captureStream not supported\");\n    }\n  }\n  function handleStopRecording() {\n    console.log(\"Stopping recording...\");\n    if (recordingState.recorder) {\n      recordingState.recorder.stop();\n      window.parent.postMessage({\n        type: \"HYPERTOOL_RECORDING_STOPPED\",\n        data: {}\n      }, \"*\");\n      console.log(\"Stop recording message sent\");\n    } else {\n      console.warn(\"No active recorder to stop\");\n    }\n  }\n}\nexport {\n  studioTheme,\n  runtime,\n  mirrorCss,\n  injectThemeVariables,\n  createSandbox,\n  createControls,\n  createControlPanel,\n  configureRuntime,\n  HypertoolControls\n};\n\n//# debugId=12BF6CCD7461308C64756E2164756E21\n"
  },
  "timestamp": 1763329139427
} as const;

export type FileMap = Record<string, string>;

export function loadRuntimeBundles(): FileMap {
  return RUNTIME_DATA.files;
}
