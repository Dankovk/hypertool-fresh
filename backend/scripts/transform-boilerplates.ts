#!/usr/bin/env bun
/**
 * Transform boilerplate presets into a bundled JS module
 * This ensures they survive Vercel deployments where only imported files are included
 */

import { existsSync, readdirSync, readFileSync, writeFileSync, mkdirSync } from "node:fs";
import { join, resolve } from "node:path";

type FileMap = Record<string, string>;

interface PresetData {
  id: string;
  name: string;
  description: string;
  files: FileMap;
}

interface BoilerplateData {
  presets: PresetData[];
  universal: FileMap;
}

function readDirectoryRecursive(dir: string, base: string = dir, out: FileMap = {}): FileMap {
  const entries = readdirSync(dir, { withFileTypes: true });
  for (const entry of entries) {
    const full = join(dir, entry.name);
    if (entry.isDirectory()) {
      readDirectoryRecursive(full, base, out);
    } else {
      const rel = full.replace(base + "/", "");
      out["/" + rel] = readFileSync(full, "utf8");
    }
  }
  return out;
}

function transformPresets(): BoilerplateData {
  const projectRoot = resolve(process.cwd(), "..");
  const presetsPath = join(projectRoot, "boilerplate-presets");

  if (!existsSync(presetsPath)) {
    throw new Error(`Presets directory not found at: ${presetsPath}`);
  }

  const data: BoilerplateData = {
    presets: [],
    universal: {},
  };

  const entries = readdirSync(presetsPath, { withFileTypes: true });

  for (const entry of entries) {
    if (!entry.isDirectory() || entry.name === '__non-migrated__') {
      continue;
    }

    const presetPath = join(presetsPath, entry.name);
    const packageJsonPath = join(presetPath, "package.json");
    const indexHtmlPath = join(presetPath, "index.html");

    // Skip if no index.html
    if (!existsSync(indexHtmlPath)) {
      console.log(`‚ö†Ô∏è  Skipping ${entry.name} (no index.html)`);
      continue;
    }

    let name = entry.name;
    let description = "";

    // Read package.json if exists
    if (existsSync(packageJsonPath)) {
      try {
        const packageJson = JSON.parse(readFileSync(packageJsonPath, "utf8"));
        name = packageJson.name || entry.name;
        description = packageJson.description || "";
      } catch (e) {
        console.warn(`‚ö†Ô∏è  Failed to parse package.json for ${entry.name}`);
      }
    }

    // Read all files in this preset
    const files = readDirectoryRecursive(presetPath);

    console.log(`‚úÖ Loaded preset: ${entry.name} (${Object.keys(files).length} files)`);

    data.presets.push({
      id: entry.name,
      name,
      description,
      files,
    });

    // If this is the universal preset, store it separately
    if (entry.name === "universal") {
      data.universal = files;
    }
  }

  return data;
}

function generateModule(data: BoilerplateData): string {
  return `/**
 * Auto-generated boilerplate data
 * Generated at: ${new Date().toISOString()}
 *
 * This file is generated by scripts/transform-boilerplates.ts
 * Do not edit manually - run 'bun run transform:boilerplate' to regenerate
 */

export const BOILERPLATE_DATA = ${JSON.stringify(data, null, 2)} as const;

export type FileMap = Record<string, string>;

export interface PresetInfo {
  id: string;
  name: string;
  description: string;
}

export function listAvailablePresets(): PresetInfo[] {
  return BOILERPLATE_DATA.presets.map(({ id, name, description }) => ({
    id,
    name,
    description,
  }));
}

export function loadBoilerplateFiles(presetId?: string): FileMap {
  if (presetId) {
    const preset = BOILERPLATE_DATA.presets.find(p => p.id === presetId);
    if (preset) {
      return preset.files;
    }
  }

  // Fallback to universal
  return BOILERPLATE_DATA.universal;
}
`;
}

// Main execution
try {
  console.log("üîÑ Transforming boilerplate presets...\n");

  const data = transformPresets();
  const moduleCode = generateModule(data);

  // Ensure lib directory exists
  const libDir = join(process.cwd(), "src", "lib");
  if (!existsSync(libDir)) {
    mkdirSync(libDir, { recursive: true });
  }

  const outputPath = join(libDir, "boilerplate-data.ts");
  writeFileSync(outputPath, moduleCode, "utf8");

  console.log(`\n‚úÖ Generated: ${outputPath}`);
  console.log(`üì¶ Presets: ${data.presets.length}`);
  console.log(`üìÑ Total files: ${data.presets.reduce((sum, p) => sum + Object.keys(p.files).length, 0)}`);
} catch (error) {
  console.error("‚ùå Error transforming boilerplates:", error);
  process.exit(1);
}
